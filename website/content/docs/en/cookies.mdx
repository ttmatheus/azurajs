---
title: Cookies
description: Complete cookie management guide - security, authentication, sessions, GDPR compliance, and best practices
icon: Cookie
---

# Cookies ðŸª

AzuraJS provides a powerful and secure cookie management system with signing, encryption, session support, and GDPR-compliant features - going beyond Express with more security and flexibility.

## Quick Start ðŸš€

```typescript
import { CookieJar, SessionManager, MemorySessionStore, CookiePresets } from 'azurajs/cookies';

// Simple cookie usage
const jar = new CookieJar();
const cookie = jar.set('user_id', '123', {
  httpOnly: true,
  secure: true,
  maxAge: 3600 // 1 hour
});

res.setHeader('Set-Cookie', cookie);
```

## How Cookies Work ðŸ“š

### The Cookie Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Browser   â”‚                           â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                         â”‚
       â”‚ 1. Initial Request                      â”‚
       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚                                         â”‚
       â”‚ 2. Response + Set-Cookie Header         â”‚
       â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
       â”‚ (Browser stores cookie)                 â”‚
       â”‚                                         â”‚
       â”‚ 3. Subsequent Requests + Cookie         â”‚
       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚ (Cookie automatically sent)             â”‚
       â”‚                                         â”‚
       â”‚ 4. Response (uses cookie data)          â”‚
       â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
       â”‚                                         â”‚
```

### What Are Cookies?

Cookies are small pieces of data (max 4KB) that:
- **Stored on client side** - Browser stores cookies per domain
- **Sent automatically** - Browser sends cookies with every request to the domain
- **Can expire** - Set expiration dates or session-only lifetime
- **Domain-scoped** - Only sent to the domain that set them
- **Path-scoped** - Can be limited to specific URL paths

**Common Use Cases:**
- ðŸ” **Authentication** - Store session IDs or tokens
- ðŸŽ¨ **Preferences** - Remember user settings (theme, language)
- ðŸ›’ **Shopping Carts** - Track items before checkout
- ðŸ“Š **Analytics** - Track user behavior
- ðŸŽ¯ **Marketing** - Show targeted content

## Cookie Security Explained ðŸ”’

### Security Flags Deep Dive

#### httpOnly Flag

**Purpose**: Prevent JavaScript access to cookies

```typescript
jar.set('session_id', 'abc123', {
  httpOnly: true  // âœ… JavaScript CANNOT access
});

// In browser console:
document.cookie;  // Won't see httpOnly cookies
```

**Why it matters**: Protects against XSS (Cross-Site Scripting) attacks. Even if attacker injects malicious JavaScript, they cannot steal httpOnly cookies.

**When to use**:
- âœ… **Always** for authentication tokens
- âœ… **Always** for session IDs
- âŒ Never for data that JavaScript needs (like theme preferences)

#### secure Flag

**Purpose**: Only send cookies over HTTPS

```typescript
jar.set('session_id', 'abc123', {
  secure: true  // Only sent over HTTPS
});
```

**Why it matters**: Prevents man-in-the-middle attacks. Cookies sent over HTTP can be intercepted.

**When to use**:
- âœ… **Always** in production
- âœ… For any sensitive data
- âš ï¸ Set to `false` only in development (localhost)

```typescript
const cookieOptions = {
  secure: process.env.NODE_ENV === 'production'  // Auto-detect environment
};
```

#### sameSite Flag

**Purpose**: Control when cookies are sent in cross-site requests

```typescript
// Three options:

// 1. Strict - Maximum protection
jar.set('session_id', 'abc123', {
  sameSite: 'strict'  // Never sent on cross-site requests
});

// 2. Lax - Balanced (default)
jar.set('session_id', 'abc123', {
  sameSite: 'lax'  // Sent on top-level navigation only
});

// 3. None - Least protection
jar.set('tracking_id', 'xyz789', {
  sameSite: 'none',
  secure: true  // Required when sameSite=none
});
```

**Comparison Table:**

| sameSite | Link Click | Form POST | AJAX/Fetch | iframe |
|----------|-----------|-----------|------------|---------|
| `strict` | âŒ Not sent | âŒ Not sent | âŒ Not sent | âŒ Not sent |
| `lax` | âœ… Sent | âŒ Not sent | âŒ Not sent | âŒ Not sent |
| `none` | âœ… Sent | âœ… Sent | âœ… Sent | âœ… Sent |

**When to use**:
- âœ… `strict` - Authentication cookies for maximum security
- âœ… `lax` - Session cookies that need to work with external links
- âœ… `none` - Third-party integrations, embeds (requires `secure: true`)

**Example Attack Prevented by sameSite:**

```
Without sameSite:
1. User logs into bank.com (gets session cookie)
2. User visits evil.com
3. evil.com makes POST to bank.com/transfer
4. Browser sends bank.com cookie â†’ Money transferred! ðŸ’¸

With sameSite=strict:
3. evil.com makes POST to bank.com/transfer
4. Browser BLOCKS cookie â†’ Transfer fails! âœ…
```

### Complete Security Example

```typescript
const jar = new CookieJar('your-secret-key');

// Maximum security for authentication
app.post('/auth/login', (req, res) => {
  const user = authenticateUser(req.body);
  
  const cookie = jar.set('session_id', user.sessionId, {
    httpOnly: true,      // âœ… No JavaScript access
    secure: true,        // âœ… HTTPS only
    sameSite: 'strict',  // âœ… No cross-site requests
    signed: true,        // âœ… Tamper-proof
    maxAge: 3600,        // âœ… Limited lifetime (1 hour)
    path: '/'            // âœ… Available site-wide
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Logged in securely' });
});
```

## Reading and Writing Cookies ðŸ“–

### Basic Operations

```typescript
import { CookieJar } from 'azurajs/cookies';

const jar = new CookieJar();

// Set a cookie
app.get('/set-cookie', (req, res) => {
  const cookie = jar.set('username', 'john_doe', {
    maxAge: 86400, // 24 hours
    httpOnly: true,
    secure: true,
    sameSite: 'lax'
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Cookie set!' });
});

// Get a cookie
app.get('/get-cookie', (req, res) => {
  const username = jar.get('username');
  
  if (!username) {
    return res.status(404).json({ error: 'Cookie not found' });
  }
  
  res.json({ username });
});

// Delete a cookie
app.get('/delete-cookie', (req, res) => {
  const cookie = jar.delete('username');
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Cookie deleted' });
});

// Check if cookie exists
app.get('/has-cookie', (req, res) => {
  const exists = jar.has('username');
  res.json({ exists });
});

// Get all cookies
app.get('/all-cookies', (req, res) => {
  const cookies = jar.all();
  res.json({ cookies });
});
```

### Multiple Cookies

```typescript
app.post('/login', (req, res) => {
  const user = authenticateUser(req.body);
  
  // Set multiple cookies
  const cookies = [
    jar.set('session_id', user.sessionId, {
      httpOnly: true,
      secure: true,
      maxAge: 3600
    }),
    jar.set('user_id', user.id, {
      httpOnly: true,
      secure: true,
      maxAge: 3600
    }),
    jar.set('theme', user.preferences.theme, {
      maxAge: 31536000  // 1 year
    })
  ];
  
  res.setHeader('Set-Cookie', cookies);
  res.json({ user });
});
```

## Complete Cookie Options Table ðŸ“‹

```typescript
interface CookieOptions {
  domain?: string;           // Cookie domain
  encode?: (value: string) => string;  // Custom encoder
  expires?: Date;            // Expiration date
  httpOnly?: boolean;        // HTTP only flag
  maxAge?: number;           // Max age in seconds
  path?: string;             // Cookie path
  sameSite?: 'strict' | 'lax' | 'none';  // SameSite policy
  secure?: boolean;          // Secure flag (HTTPS only)
  signed?: boolean;          // Sign cookie
  encrypted?: boolean;       // Encrypt cookie
  priority?: 'low' | 'medium' | 'high';  // Priority (Chrome)
}
```

### Option Details

| Option | Type | Default | Description | Example |
|--------|------|---------|-------------|---------|
| `domain` | string | current domain | Cookie domain scope | `.example.com` |
| `expires` | Date | - | Absolute expiration date | `new Date('2025-12-31')` |
| `httpOnly` | boolean | `false` | Prevent JavaScript access | `true` |
| `maxAge` | number | - | Lifetime in seconds (relative) | `3600` (1 hour) |
| `path` | string | `/` | URL path scope | `/admin` |
| `sameSite` | string | `lax` | Cross-site request policy | `strict` |
| `secure` | boolean | `false` | HTTPS only | `true` |
| `signed` | boolean | `false` | Add signature for tamper detection | `true` |
| `encrypted` | boolean | `false` | Encrypt cookie value | `true` |
| `priority` | string | - | Browser priority (Chrome only) | `high` |

### Option Examples

```typescript
// Domain scope
jar.set('data', 'value', {
  domain: '.example.com'  // Available on *.example.com
});

// Path scope
jar.set('admin_token', 'secret', {
  path: '/admin'  // Only sent to /admin/* routes
});

// Expiration (absolute)
jar.set('promo', 'code123', {
  expires: new Date('2025-12-31')  // Expires on specific date
});

// Max age (relative)
jar.set('session', 'abc', {
  maxAge: 3600  // Expires in 1 hour from now
});

// Custom encoder
jar.set('data', 'special chars!', {
  encode: (value) => Buffer.from(value).toString('base64')
});

// Priority (Chrome)
jar.set('critical_data', 'value', {
  priority: 'high'  // Keep this cookie when storage is full
});
```

## Signed Cookies ðŸ”

**Purpose**: Detect cookie tampering

### How Signing Works

```
1. Server creates cookie value: "user_id=123"
2. Server generates signature: HMAC-SHA256(value, secret)
3. Server sends: "user_id=123.signature"
4. Client stores: "user_id=123.signature"
5. Client sends back: "user_id=123.signature"
6. Server verifies: signature matches? âœ… Valid : âŒ Tampered
```

### Implementation

```typescript
const jar = new CookieJar('my-secret-key-change-in-production');

// Set signed cookie
app.post('/auth/login', (req, res) => {
  const user = authenticateUser(req.body);
  
  const cookie = jar.set('user_id', user.id, {
    signed: true,       // Enable signing
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 86400
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Logged in' });
});

// Verify signed cookie
app.get('/auth/me', (req, res) => {
  const userId = jar.get('user_id', true);  // true = verify signature
  
  if (!userId) {
    return res.status(401).json({ 
      error: 'Invalid or tampered cookie' 
    });
  }
  
  const user = getUserById(userId);
  res.json({ user });
});
```

### When to Use Signed Cookies

âœ… **Use signed cookies when**:
- Storing user IDs
- Storing role/permission data
- Storing any data used for authorization
- Data that affects security if tampered

âŒ **Don't use signed cookies for**:
- Public data (theme, language)
- Data that doesn't affect security
- Encrypted cookies (already secure)

## Cookie-Based Authentication Flow ðŸ”

### Complete Step-by-Step Example

```typescript
import { CookieJar, SessionManager, MemorySessionStore } from 'azurajs/cookies';
import { randomUUID } from 'crypto';

// Step 1: Setup
const jar = new CookieJar('your-secret-key');
const sessionManager = new SessionManager(new MemorySessionStore(), {
  cookieName: 'azura.sid',
  secret: 'session-secret-key',
  cookieOptions: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 86400  // 24 hours
  }
});

// Step 2: Login - Create Session
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate credentials
  const user = await validateCredentials(email, password);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Create session
  const { id, cookie } = await sessionManager.create({
    userId: user.id,
    email: user.email,
    role: user.role,
    loginAt: new Date().toISOString(),
    ip: req.ip
  });
  
  // Set session cookie
  res.setHeader('Set-Cookie', cookie);
  
  // Return user data (don't include password!)
  res.json({
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role
    },
    sessionId: id
  });
});

// Step 3: Authentication Middleware
async function authenticateUser(req, res, next) {
  const session = await sessionManager.get(req.cookies);
  
  if (!session) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  // Attach session data to request
  req.session = session.data;
  req.sessionId = session.id;
  
  // Update last activity
  await sessionManager.touch(session.id);
  
  next();
}

// Step 4: Protected Routes
app.get('/api/dashboard', authenticateUser, (req, res) => {
  res.json({
    message: 'Welcome to your dashboard',
    user: {
      email: req.session.email,
      role: req.session.role,
      loginAt: req.session.loginAt
    }
  });
});

// Role-based authorization
function requireRole(role) {
  return (req, res, next) => {
    if (req.session.role !== role) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
}

app.get('/api/admin', authenticateUser, requireRole('admin'), (req, res) => {
  res.json({ message: 'Admin area' });
});

// Step 5: Logout - Destroy Session
app.post('/auth/logout', async (req, res) => {
  if (req.sessionId) {
    const cookie = await sessionManager.destroy(req.sessionId);
    res.setHeader('Set-Cookie', cookie);
  }
  
  res.json({ message: 'Logged out successfully' });
});

// Step 6: Refresh Session
app.post('/auth/refresh', authenticateUser, async (req, res) => {
  // Update session data
  await sessionManager.update(req.sessionId, {
    ...req.session,
    lastRefresh: new Date().toISOString()
  });
  
  res.json({ message: 'Session refreshed' });
});

// Step 7: Get Current User
app.get('/auth/me', authenticateUser, (req, res) => {
  res.json({
    user: {
      userId: req.session.userId,
      email: req.session.email,
      role: req.session.role
    }
  });
});
```

### Authentication Flow Diagram

```
1. Login Request
   POST /auth/login
   { email, password }
          â”‚
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Validate User  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ Valid
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Create Session  â”‚
   â”‚  Store in DB    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Set Cookie     â”‚
   â”‚  Response       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
   Browser stores cookie
   
2. Authenticated Request
   GET /api/dashboard
   Cookie: azura.sid=abc123
          â”‚
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Read Cookie     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Load Session    â”‚
   â”‚  from DB        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ Valid
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Process Request â”‚
   â”‚  Send Response  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. Logout Request
   POST /auth/logout
   Cookie: azura.sid=abc123
          â”‚
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Delete Session  â”‚
   â”‚  from DB        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Clear Cookie    â”‚
   â”‚  Response       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Session Management ðŸ’¼

### Basic Session Usage

```typescript
import { SessionManager, MemorySessionStore } from 'azurajs/cookies';

const sessionManager = new SessionManager(new MemorySessionStore(), {
  cookieName: 'azura.sid',
  secret: 'session-secret-key',
  cookieOptions: {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 86400  // 24 hours
  }
});

// Load session middleware
app.use(async (req, res, next) => {
  const session = await sessionManager.get(req.cookies);
  
  if (session) {
    req.session = session.data;
    req.sessionId = session.id;
  }
  
  next();
});
```

### Custom Session Store (Redis)

```typescript
import { SessionStore } from 'azurajs/cookies';
import Redis from 'ioredis';

class RedisSessionStore implements SessionStore {
  private redis: Redis;
  
  constructor(redisClient: Redis) {
    this.redis = redisClient;
  }
  
  async get(id: string): Promise<any | undefined> {
    const data = await this.redis.get(`session:${id}`);
    return data ? JSON.parse(data) : undefined;
  }
  
  async set(id: string, data: any, maxAge: number): Promise<void> {
    await this.redis.set(
      `session:${id}`,
      JSON.stringify(data),
      'PX',  // milliseconds
      maxAge * 1000
    );
  }
  
  async destroy(id: string): Promise<void> {
    await this.redis.del(`session:${id}`);
  }
  
  async touch(id: string, maxAge: number): Promise<void> {
    await this.redis.expire(`session:${id}`, maxAge);
  }
}

// Use custom store
const redisClient = new Redis();
const sessionManager = new SessionManager(
  new RedisSessionStore(redisClient),
  {
    cookieName: 'sid',
    secret: 'secret',
    cookieOptions: { httpOnly: true, secure: true }
  }
);
```

### Custom Session Store (MongoDB)

```typescript
import { SessionStore } from 'azurajs/cookies';
import { MongoClient, Collection } from 'mongodb';

interface SessionDocument {
  _id: string;
  data: any;
  expiresAt: Date;
}

class MongoSessionStore implements SessionStore {
  private collection: Collection<SessionDocument>;
  
  constructor(collection: Collection<SessionDocument>) {
    this.collection = collection;
    
    // Create TTL index for auto-cleanup
    this.collection.createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 });
  }
  
  async get(id: string): Promise<any | undefined> {
    const doc = await this.collection.findOne({ _id: id });
    
    if (!doc) return undefined;
    if (doc.expiresAt < new Date()) {
      await this.destroy(id);
      return undefined;
    }
    
    return doc.data;
  }
  
  async set(id: string, data: any, maxAge: number): Promise<void> {
    const expiresAt = new Date(Date.now() + maxAge * 1000);
    
    await this.collection.updateOne(
      { _id: id },
      {
        $set: {
          data,
          expiresAt
        }
      },
      { upsert: true }
    );
  }
  
  async destroy(id: string): Promise<void> {
    await this.collection.deleteOne({ _id: id });
  }
  
  async touch(id: string, maxAge: number): Promise<void> {
    const expiresAt = new Date(Date.now() + maxAge * 1000);
    await this.collection.updateOne(
      { _id: id },
      { $set: { expiresAt } }
    );
  }
}

// Setup
const client = new MongoClient('mongodb://localhost:27017');
await client.connect();
const db = client.db('myapp');
const sessions = db.collection<SessionDocument>('sessions');

const sessionManager = new SessionManager(
  new MongoSessionStore(sessions),
  {
    cookieName: 'sid',
    secret: 'secret',
    cookieOptions: { httpOnly: true, secure: true }
  }
);
```

## Security Best Practices ðŸ’Ž

### 10+ Essential Security Practices

#### 1. Always Use httpOnly for Auth Cookies

```typescript
// âŒ Bad - JavaScript can access
jar.set('session_id', id, {
  httpOnly: false
});

// âœ… Good - Protected from XSS
jar.set('session_id', id, {
  httpOnly: true
});
```

#### 2. Enable secure in Production

```typescript
// âœ… Good - Environment-aware
const cookieOptions = {
  secure: process.env.NODE_ENV === 'production',
  httpOnly: true,
  sameSite: 'strict'
};
```

#### 3. Use sameSite for CSRF Protection

```typescript
// âœ… Good - Maximum CSRF protection
jar.set('session_id', id, {
  sameSite: 'strict',  // or 'lax' if needed
  httpOnly: true,
  secure: true
});
```

#### 4. Set Appropriate Expiration

```typescript
// âŒ Bad - Never expires
jar.set('session_id', id, {});

// âœ… Good - Limited lifetime
jar.set('session_id', id, {
  maxAge: 3600  // 1 hour
});

// âœ… Good - Longer for "remember me"
jar.set('remember_token', token, {
  maxAge: 30 * 24 * 3600  // 30 days
});
```

#### 5. Sign Sensitive Cookies

```typescript
// âœ… Good - Detect tampering
jar.set('user_role', 'admin', {
  signed: true,
  httpOnly: true,
  secure: true
});
```

#### 6. Encrypt PII (Personal Identifiable Information)

```typescript
// âœ… Good - Encrypt sensitive data
jar.set('user_ssn', ssn, {
  encrypted: true,
  httpOnly: true,
  secure: true,
  signed: true
});
```

#### 7. Use Secure Random for Session IDs

```typescript
import { randomBytes } from 'crypto';

// âœ… Good - Cryptographically secure
const sessionId = randomBytes(32).toString('hex');

// âŒ Bad - Predictable
const sessionId = Date.now().toString();
```

#### 8. Implement Session Rotation

```typescript
// Rotate session ID on privilege escalation
app.post('/upgrade-to-premium', authenticateUser, async (req, res) => {
  // Destroy old session
  await sessionManager.destroy(req.sessionId);
  
  // Create new session with updated role
  const { id, cookie } = await sessionManager.create({
    ...req.session,
    role: 'premium',
    upgradedAt: new Date()
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Upgraded!' });
});
```

#### 9. Validate Cookie Values

```typescript
import { v } from 'azurajs/validators';

const SessionSchema = v.object({
  userId: v.string().uuid(),
  role: v.enum(['user', 'admin', 'premium']),
  expiresAt: v.number()
});

app.use(async (req, res, next) => {
  const session = await sessionManager.get(req.cookies);
  
  if (session) {
    const result = SessionSchema.safeParse(session.data);
    
    if (!result.success) {
      // Invalid session data - destroy it
      await sessionManager.destroy(session.id);
      return res.status(401).json({ error: 'Invalid session' });
    }
    
    req.session = result.data;
  }
  
  next();
});
```

#### 10. Implement Rate Limiting

```typescript
const loginAttempts = new Map<string, number>();

app.post('/auth/login', (req, res) => {
  const ip = req.ip;
  const attempts = loginAttempts.get(ip) || 0;
  
  if (attempts >= 5) {
    return res.status(429).json({ 
      error: 'Too many login attempts. Try again in 15 minutes.' 
    });
  }
  
  const user = authenticateUser(req.body);
  
  if (!user) {
    loginAttempts.set(ip, attempts + 1);
    setTimeout(() => loginAttempts.delete(ip), 15 * 60 * 1000);
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Success - reset attempts
  loginAttempts.delete(ip);
  
  // ... create session
});
```

#### 11. Log Security Events

```typescript
import { createLogger } from 'winston';

const securityLogger = createLogger({
  // ... config
});

app.post('/auth/login', async (req, res) => {
  const result = await attemptLogin(req.body);
  
  securityLogger.info('Login attempt', {
    success: result.success,
    email: req.body.email,
    ip: req.ip,
    userAgent: req.headers['user-agent'],
    timestamp: new Date()
  });
  
  // ... rest of login logic
});
```

#### 12. Clean Up Expired Sessions

```typescript
// Run cleanup task periodically
setInterval(async () => {
  const now = Date.now();
  const sessions = await getAllSessions();
  
  for (const session of sessions) {
    if (session.expiresAt < now) {
      await sessionManager.destroy(session.id);
    }
  }
}, 60 * 60 * 1000);  // Every hour
```

## GDPR Considerations ðŸ‡ªðŸ‡º

### Cookie Consent

```typescript
app.get('/', (req, res) => {
  const consent = jar.get('cookie_consent');
  
  if (!consent) {
    // Show cookie banner
    return res.send(`
      <div class="cookie-banner">
        <p>We use cookies to improve your experience.</p>
        <button onclick="acceptCookies()">Accept All</button>
        <button onclick="rejectCookies()">Reject Non-Essential</button>
      </div>
    `);
  }
  
  // User has consented
  if (consent === 'accepted') {
    // Set analytics cookies
    jar.set('analytics_id', generateId(), { maxAge: 31536000 });
  }
  
  res.send('Welcome!');
});

app.post('/api/cookie-consent', (req, res) => {
  const { consent } = req.body;  // 'accepted' or 'rejected'
  
  const cookie = jar.set('cookie_consent', consent, {
    maxAge: 365 * 24 * 3600  // 1 year
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Consent recorded' });
});
```

### Cookie Policy Page

```typescript
app.get('/cookie-policy', (req, res) => {
  res.json({
    essential: [
      {
        name: 'session_id',
        purpose: 'User authentication',
        duration: '24 hours',
        type: 'essential'
      }
    ],
    analytics: [
      {
        name: 'analytics_id',
        purpose: 'Usage analytics',
        duration: '1 year',
        type: 'analytics',
        provider: 'Google Analytics'
      }
    ]
  });
});
```

### Right to be Forgotten

```typescript
app.delete('/api/user/data', authenticateUser, async (req, res) => {
  const userId = req.session.userId;
  
  // Delete user data
  await deleteUserData(userId);
  
  // Delete session
  await sessionManager.destroy(req.sessionId);
  
  // Clear all cookies
  const cookies = [
    jar.delete('session_id'),
    jar.delete('analytics_id'),
    jar.delete('preferences')
  ];
  
  res.setHeader('Set-Cookie', cookies);
  res.json({ message: 'All data deleted' });
});
```

### Minimal Data Collection

```typescript
// âŒ Bad - Collecting unnecessary data
const session = {
  userId: user.id,
  email: user.email,
  phone: user.phone,
  address: user.address,
  creditCard: user.creditCard  // Never!
};

// âœ… Good - Minimal necessary data
const session = {
  userId: user.id,
  role: user.role,
  expiresAt: Date.now() + 3600000
};
```

### Cookie Audit Log

```typescript
app.use((req, res, next) => {
  const originalSetHeader = res.setHeader;
  
  res.setHeader = function(name, value) {
    if (name.toLowerCase() === 'set-cookie') {
      // Log cookie being set
      auditLogger.info('Cookie set', {
        cookie: typeof value === 'string' ? parseCookieName(value) : value.map(parseCookieName),
        route: req.path,
        timestamp: new Date()
      });
    }
    
    return originalSetHeader.call(this, name, value);
  };
  
  next();
});

function parseCookieName(cookieString: string): string {
  return cookieString.split('=')[0];
}
```

## Troubleshooting ðŸ”§

### Issue: Cookies Not Being Set

**Symptoms**: Cookie doesn't appear in browser

**Possible Causes & Solutions**:

```typescript
// 1. Check secure flag in development
// âŒ Problem
jar.set('token', 'value', {
  secure: true  // Won't work on localhost HTTP
});

// âœ… Solution
jar.set('token', 'value', {
  secure: process.env.NODE_ENV === 'production'
});

// 2. Check sameSite=none requires secure
// âŒ Problem
jar.set('token', 'value', {
  sameSite: 'none'  // Must have secure: true
});

// âœ… Solution
jar.set('token', 'value', {
  sameSite: 'none',
  secure: true
});

// 3. Check domain mismatch
// âŒ Problem
jar.set('token', 'value', {
  domain: 'example.com'  // Won't work on localhost
});

// âœ… Solution
jar.set('token', 'value', {
  domain: process.env.NODE_ENV === 'production' ? '.example.com' : undefined
});

// 4. Check browser blocking third-party cookies
// Solution: Use sameSite='lax' or 'strict' for first-party cookies
```

### Issue: Cookies Not Being Sent

**Symptoms**: Cookie exists but not sent with requests

**Possible Causes & Solutions**:

```typescript
// 1. Path mismatch
// Cookie set with path: '/admin'
// Request to: '/api/users' â†’ Cookie not sent

// âœ… Solution: Use path: '/' for site-wide cookies
jar.set('token', 'value', {
  path: '/'
});

// 2. Domain mismatch
// Cookie domain: 'api.example.com'
// Request to: 'www.example.com' â†’ Cookie not sent

// âœ… Solution: Use parent domain
jar.set('token', 'value', {
  domain: '.example.com'  // Works for all subdomains
});

// 3. Expired cookie
// âœ… Solution: Check expiration
const cookie = jar.get('token');
if (!cookie) {
  console.log('Cookie expired or not set');
}
```

### Issue: Cookie Signature Invalid

**Symptoms**: `jar.get(name, true)` returns `null`

**Solution**:

```typescript
// Make sure secret key is consistent
const SECRET = process.env.COOKIE_SECRET;

// âŒ Bad - Different secrets
const jar1 = new CookieJar('secret1');
jar1.set('token', 'value', { signed: true });

const jar2 = new CookieJar('secret2');
jar2.get('token', true);  // Returns null - signatures don't match

// âœ… Good - Same secret
const jar1 = new CookieJar(SECRET);
jar1.set('token', 'value', { signed: true });

const jar2 = new CookieJar(SECRET);
jar2.get('token', true);  // Works!
```

### Issue: Session Lost on Refresh

**Causes & Solutions**:

```typescript
// 1. Session not persisted
// âœ… Solution: Use persistent store (Redis/MongoDB)
const sessionManager = new SessionManager(
  new RedisSessionStore(redis),  // Not MemorySessionStore
  { /* options */ }
);

// 2. Cookie expired
// âœ… Solution: Increase maxAge
cookieOptions: {
  maxAge: 86400  // 24 hours instead of 3600 (1 hour)
}

// 3. Touch session on activity
app.use(async (req, res, next) => {
  if (req.sessionId) {
    await sessionManager.touch(req.sessionId);  // Extend session
  }
  next();
});
```

## Common Patterns ðŸŽ¨

### 1. Remember Me Functionality

```typescript
app.post('/auth/login', async (req, res) => {
  const { email, password, rememberMe } = req.body;
  const user = await authenticateUser(email, password);
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Short-lived session
  const sessionCookie = jar.set('session_id', user.sessionId, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 3600  // 1 hour
  });
  
  const cookies = [sessionCookie];
  
  // Long-lived remember token (if requested)
  if (rememberMe) {
    const rememberToken = generateSecureToken();
    await storeRememberToken(user.id, rememberToken);
    
    const rememberCookie = jar.set('remember_token', rememberToken, {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      signed: true,
      maxAge: 30 * 24 * 3600  // 30 days
    });
    
    cookies.push(rememberCookie);
  }
  
  res.setHeader('Set-Cookie', cookies);
  res.json({ user });
});

// Remember me middleware
app.use(async (req, res, next) => {
  // Check session first
  if (req.session) {
    return next();
  }
  
  // Try remember token
  const rememberToken = jar.get('remember_token', true);
  if (rememberToken) {
    const userId = await validateRememberToken(rememberToken);
    
    if (userId) {
      // Create new session
      const user = await getUserById(userId);
      const { id, cookie } = await sessionManager.create({
        userId: user.id,
        email: user.email,
        role: user.role,
        rememberedLogin: true
      });
      
      res.setHeader('Set-Cookie', cookie);
      req.session = { userId, email: user.email, role: user.role };
    }
  }
  
  next();
});
```

### 2. Theme/Preference Storage

```typescript
app.post('/api/preferences', (req, res) => {
  const { theme, language, timezone, fontSize } = req.body;
  
  const cookies = [
    jar.set('pref_theme', theme, {
      maxAge: 365 * 24 * 3600,  // 1 year
      sameSite: 'lax'
    }),
    jar.set('pref_language', language, {
      maxAge: 365 * 24 * 3600,
      sameSite: 'lax'
    }),
    jar.set('pref_timezone', timezone, {
      maxAge: 365 * 24 * 3600,
      sameSite: 'lax'
    }),
    jar.set('pref_fontSize', fontSize, {
      maxAge: 365 * 24 * 3600,
      sameSite: 'lax'
    })
  ];
  
  res.setHeader('Set-Cookie', cookies);
  res.json({ message: 'Preferences saved' });
});

// Apply preferences middleware
app.use((req, res, next) => {
  req.preferences = {
    theme: jar.get('pref_theme') || 'light',
    language: jar.get('pref_language') || 'en',
    timezone: jar.get('pref_timezone') || 'UTC',
    fontSize: jar.get('pref_fontSize') || 'medium'
  };
  next();
});
```

### 3. Shopping Cart

```typescript
interface CartItem {
  productId: string;
  quantity: number;
  price: number;
}

app.post('/api/cart/add', (req, res) => {
  const { productId, quantity } = req.body;
  
  // Get existing cart
  const cartCookie = jar.get('cart');
  const cart: CartItem[] = cartCookie ? JSON.parse(cartCookie) : [];
  
  // Add or update item
  const existingItem = cart.find(item => item.productId === productId);
  if (existingItem) {
    existingItem.quantity += quantity;
  } else {
    const product = getProduct(productId);
    cart.push({
      productId,
      quantity,
      price: product.price
    });
  }
  
  // Save cart
  const cookie = jar.set('cart', JSON.stringify(cart), {
    maxAge: 7 * 24 * 3600,  // 7 days
    sameSite: 'lax'
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({ cart, total: calculateTotal(cart) });
});

app.get('/api/cart', (req, res) => {
  const cartCookie = jar.get('cart');
  const cart: CartItem[] = cartCookie ? JSON.parse(cartCookie) : [];
  
  res.json({
    cart,
    total: calculateTotal(cart),
    itemCount: cart.reduce((sum, item) => sum + item.quantity, 0)
  });
});

app.delete('/api/cart', (req, res) => {
  const cookie = jar.delete('cart');
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Cart cleared' });
});
```

### 4. Flash Messages

```typescript
app.use((req, res, next) => {
  // Get flash message
  const flashCookie = jar.get('_flash');
  if (flashCookie) {
    req.flash = JSON.parse(decodeURIComponent(flashCookie));
    
    // Clear flash cookie
    const clearCookie = jar.delete('_flash');
    res.setHeader('Set-Cookie', clearCookie);
  }
  
  // Helper to set flash
  res.flash = function(type: string, message: string) {
    const flashData = JSON.stringify({ type, message });
    const cookie = jar.set('_flash', encodeURIComponent(flashData), {
      httpOnly: true,
      sameSite: 'lax'
      // No maxAge - session only
    });
    this.setHeader('Set-Cookie', cookie);
    return this;
  };
  
  next();
});

// Usage
app.post('/api/save', (req, res) => {
  saveData(req.body);
  res.flash('success', 'Data saved successfully!');
  res.redirect('/dashboard');
});

app.get('/dashboard', (req, res) => {
  res.json({
    flash: req.flash || null,  // { type: 'success', message: 'Data saved successfully!' }
    data: getDashboardData()
  });
});
```

### 5. CSRF Token Management

```typescript
import { randomBytes } from 'crypto';

const csrfTokens = new Map<string, { token: string; expiresAt: number }>();

// Generate CSRF token middleware
app.use((req, res, next) => {
  let csrfToken = jar.get('csrf_token');
  
  if (!csrfToken || !csrfTokens.has(csrfToken)) {
    csrfToken = randomBytes(32).toString('hex');
    csrfTokens.set(csrfToken, {
      token: csrfToken,
      expiresAt: Date.now() + 3600000  // 1 hour
    });
    
    const cookie = jar.set('csrf_token', csrfToken, {
      httpOnly: false,  // Needs to be accessible to JavaScript
      secure: true,
      sameSite: 'strict',
      maxAge: 3600
    });
    
    res.setHeader('Set-Cookie', cookie);
  }
  
  req.csrfToken = csrfToken;
  next();
});

// Verify CSRF token
function verifyCsrfToken(req, res, next) {
  const tokenFromRequest = req.header('x-csrf-token') || req.body._csrf;
  const tokenFromCookie = jar.get('csrf_token');
  
  if (!tokenFromRequest || !tokenFromCookie || tokenFromRequest !== tokenFromCookie) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  const tokenData = csrfTokens.get(tokenFromCookie);
  if (!tokenData || tokenData.expiresAt < Date.now()) {
    csrfTokens.delete(tokenFromCookie);
    return res.status(403).json({ error: 'CSRF token expired' });
  }
  
  next();
}

// Use on state-changing routes
app.post('/api/transfer', verifyCsrfToken, (req, res) => {
  // Safe from CSRF attacks
  performTransfer(req.body);
  res.json({ success: true });
});

// Cleanup expired tokens
setInterval(() => {
  const now = Date.now();
  for (const [token, data] of csrfTokens.entries()) {
    if (data.expiresAt < now) {
      csrfTokens.delete(token);
    }
  }
}, 60000);  // Every minute
```

## Complete API Reference ðŸ“–

### CookieJar

```typescript
class CookieJar {
  constructor(secret?: string);
  
  set(name: string, value: string, options?: CookieOptions): string;
  get(name: string, signed?: boolean, encrypted?: boolean): string | undefined;
  delete(name: string, options?: Partial<CookieOptions>): string;
  has(name: string): boolean;
  all(): Record<string, string>;
  clear(): void;
}
```

### SessionManager

```typescript
class SessionManager {
  constructor(store: SessionStore, options: SessionOptions);
  
  get(cookies: Record<string, string>): Promise<Session | undefined>;
  create(data: any): Promise<{ id: string; cookie: string }>;
  update(id: string, data: any): Promise<void>;
  destroy(id: string): Promise<string>;
  touch(id: string): Promise<void>;
}

interface SessionStore {
  get(id: string): Promise<any | undefined>;
  set(id: string, data: any, maxAge: number): Promise<void>;
  destroy(id: string): Promise<void>;
  touch(id: string, maxAge: number): Promise<void>;
}

interface SessionOptions {
  cookieName: string;
  secret: string;
  cookieOptions: CookieOptions;
}
```

### CookiePresets

```typescript
class CookiePresets {
  static session(secure?: boolean): CookieOptions;      // 24 hours
  static rememberMe(secure?: boolean): CookieOptions;   // 30 days
  static tracking(secure?: boolean): CookieOptions;     // 1 year
  static flash(secure?: boolean): CookieOptions;        // Session-only
  static csrf(secure?: boolean): CookieOptions;         // 1 hour
}
```

## Migration from Express ðŸ”„

```typescript
// Express
const cookieParser = require('cookie-parser');
app.use(cookieParser('secret'));

app.get('/set', (req, res) => {
  res.cookie('name', 'value', {
    signed: true,
    httpOnly: true
  });
});

app.get('/get', (req, res) => {
  const value = req.signedCookies.name;
  res.json({ value });
});

// AzuraJS - More powerful!
import { CookieJar } from 'azurajs/cookies';
const jar = new CookieJar('secret');

app.get('/set', (req, res) => {
  const cookie = jar.set('name', 'value', {
    signed: true,
    httpOnly: true,
    encrypted: true  // âœ… Extra feature!
  });
  res.setHeader('Set-Cookie', cookie);
});

app.get('/get', (req, res) => {
  const value = jar.get('name', true, true);  // signed & encrypted
  res.json({ value });
});
```

## Next Steps ðŸ“–

- [**Middleware**](middleware) - Create authentication middleware with cookies
- [**Error Handling**](error-handling) - Handle cookie and session errors
- [**Security**](security) - Advanced security patterns

---

**Pro Tip**: Always audit your cookies regularly. Use browser DevTools â†’ Application â†’ Cookies to inspect what's being stored!

### Encrypted Cookies ðŸ”

Store sensitive data securely:

```typescript
const jar = new CookieJar('encryption-secret-key');

// Encrypt sensitive data
app.post('/secure/set', (req, res) => {
  const sensitiveData = JSON.stringify({
    ssn: '123-45-6789',
    creditCard: '1234-5678-9012-3456'
  });
  
  const cookie = jar.set('secure_data', sensitiveData, {
    encrypted: true,
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({ message: 'Secure data stored' });
});

// Decrypt cookie
app.get('/secure/get', (req, res) => {
  const encryptedData = jar.get('secure_data', false, true); // true = decrypt
  
  if (!encryptedData) {
    return res.status(404).json({ error: 'No data found' });
  }
  
  const data = JSON.parse(encryptedData);
  res.json(data);
});
```

## Session Management ðŸ’¼

Built-in session management with cookie-based storage.

### Basic Sessions

```typescript
import { SessionManager, MemorySessionStore } from 'azurajs/cookies';

const sessionManager = new SessionManager(new MemorySessionStore(), {
  cookieName: 'azura.sid',
  secret: 'session-secret-key',
  cookieOptions: {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 86400 // 24 hours
  }
});

// Middleware to load sessions
app.use(async (req, res, next) => {
  const session = await sessionManager.get(req.cookies);
  
  if (session) {
    req.session = session.data;
    req.sessionId = session.id;
  }
  
  next();
});

// Create session on login
app.post('/session/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate credentials...
  
  const { id, cookie } = await sessionManager.create({
    userId: '12345',
    email,
    loginAt: new Date()
  });
  
  res.setHeader('Set-Cookie', cookie);
  res.json({
    message: 'Session created',
    sessionId: id
  });
});

// Access session data
app.get('/session/data', (req, res) => {
  if (!req.session) {
    return res.status(401).json({ error: 'No active session' });
  }
  
  res.json({ session: req.session });
});

// Destroy session
app.post('/session/logout', async (req, res) => {
  if (req.sessionId) {
    const cookie = await sessionManager.destroy(req.sessionId);
    res.setHeader('Set-Cookie', cookie);
  }
  
  res.json({ message: 'Logged out' });
});
```

### Custom Session Store

Implement your own session storage (Redis, MongoDB, etc.):

```typescript
import { SessionStore } from 'azurajs/cookies';

class RedisSessionStore implements SessionStore {
  private redis: RedisClient;
  
  constructor(redisClient: RedisClient) {
    this.redis = redisClient;
  }
  
  async get(id: string): Promise<any | undefined> {
    const data = await this.redis.get(`session:${id}`);
    return data ? JSON.parse(data) : undefined;
  }
  
  async set(id: string, data: any, maxAge: number): Promise<void> {
    await this.redis.set(
      `session:${id}`,
      JSON.stringify(data),
      'PX',
      maxAge
    );
  }
  
  async destroy(id: string): Promise<void> {
    await this.redis.del(`session:${id}`);
  }
  
  async touch(id: string, maxAge: number): Promise<void> {
    await this.redis.expire(`session:${id}`, Math.floor(maxAge / 1000));
  }
}

// Use custom store
const sessionManager = new SessionManager(
  new RedisSessionStore(redisClient),
  { cookieName: 'sid', secret: 'secret' }
);
```

## Cookie Presets ðŸŽ¨

Pre-configured cookie options for common use cases:

```typescript
import { CookiePresets } from 'azurajs/cookies';

// Session cookie (24 hours)
res.cookie('user', data, CookiePresets.session(true));

// Remember me cookie (30 days)
res.cookie('remember_token', token, CookiePresets.rememberMe(true));

// Tracking cookie (1 year)
res.cookie('tracking_id', id, CookiePresets.tracking());

// Flash message (session-only)
res.cookie('flash', message, CookiePresets.flash(true));

// CSRF token
res.cookie('csrf_token', token, CookiePresets.csrf(true));
```

## Cookie Options ðŸ“‹

Complete list of available cookie options:

```typescript
interface CookieOptions {
  domain?: string;           // Cookie domain
  encode?: (value: string) => string;  // Custom encoder
  expires?: Date;            // Expiration date
  httpOnly?: boolean;        // HTTP only flag
  maxAge?: number;           // Max age in seconds
  path?: string;             // Cookie path
  sameSite?: 'strict' | 'lax' | 'none';  // SameSite policy
  secure?: boolean;          // Secure flag (HTTPS only)
  signed?: boolean;          // Sign cookie
  encrypted?: boolean;       // Encrypt cookie
  priority?: 'low' | 'medium' | 'high';  // Priority (Chrome)
}
```

### httpOnly

Prevents JavaScript access (security):

```typescript
jar.set('token', 'value', {
  httpOnly: true  // Cannot be accessed via document.cookie
});
```

### secure

Only sent over HTTPS:

```typescript
jar.set('token', 'value', {
  secure: true  // HTTPS only
});
```

### sameSite

CSRF protection:

```typescript
jar.set('token', 'value', {
  sameSite: 'strict'  // Never sent on cross-site requests
});

jar.set('token', 'value', {
  sameSite: 'lax'  // Sent on top-level navigation
});

jar.set('token', 'value', {
  sameSite: 'none',  // Sent on all requests
  secure: true       // Must be secure when sameSite=none
});
```

### maxAge vs expires

```typescript
// Max age (relative)
jar.set('token', 'value', {
  maxAge: 3600  // Expires in 1 hour
});

// Expires (absolute)
jar.set('token', 'value', {
  expires: new Date('2025-12-31')
});
```

### domain and path

Control cookie scope:

```typescript
// Available on all subdomains
jar.set('data', 'value', {
  domain: '.example.com',  // *.example.com
  path: '/'
});

// Only on specific path
jar.set('admin_token', 'secret', {
  path: '/admin'  // Only /admin/* routes
});
```

## Advanced Patterns ðŸŽ¯

### Flash Messages

Temporary messages that expire after being read:

```typescript
app.use((req, res, next) => {
  // Get flash message
  const flash = req.cookies['_flash'];
  if (flash) {
    req.flash = JSON.parse(decodeURIComponent(flash));
    // Clear flash cookie
    res.clearCookie('_flash', { path: '/' });
  }
  
  // Helper to set flash
  res.setFlash = function(type: string, message: string) {
    const flashData = JSON.stringify({ type, message });
    this.cookie('_flash', flashData, CookiePresets.flash());
    return this;
  };
  
  next();
});

// Usage
app.post('/action', (req, res) => {
  // Do something...
  res.setFlash('success', 'Action completed!');
  res.redirect('/dashboard');
});

app.get('/dashboard', (req, res) => {
  res.json({
    flash: req.flash || null,  // { type: 'success', message: 'Action completed!' }
    message: 'Dashboard'
  });
});
```

### CSRF Protection

```typescript
const csrfTokens = new Map<string, number>();

app.use((req, res, next) => {
  // Generate CSRF token
  if (!req.cookies['csrf_token']) {
    const token = generateCSRFToken();
    csrfTokens.set(token, Date.now() + 3600000); // 1 hour
    
    res.cookie('csrf_token', token, CookiePresets.csrf(true));
  }
  
  next();
});

app.post('/protected-action', (req, res) => {
  const token = req.header('x-csrf-token') || req.body.csrfToken;
  const cookieToken = req.cookies['csrf_token'];
  
  if (!token || token !== cookieToken || !csrfTokens.has(token)) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  // Check expiration
  const expiry = csrfTokens.get(token)!;
  if (expiry < Date.now()) {
    csrfTokens.delete(token);
    return res.status(403).json({ error: 'CSRF token expired' });
  }
  
  // Process action...
  res.json({ message: 'Action completed' });
});
```

### Remember Me

```typescript
app.post('/remember-me', (req, res) => {
  const { email, rememberMe } = req.body;
  
  if (rememberMe) {
    // Use remember-me preset (30 days)
    res.cookie('user_email', email, CookiePresets.rememberMe(true));
  } else {
    // Use session preset (24 hours)
    res.cookie('user_email', email, CookiePresets.session(true));
  }
  
  res.json({ message: 'Preference saved' });
});
```

## Best Practices ðŸ’Ž

1. **Always use `httpOnly`** for authentication tokens
2. **Enable `secure`** in production (HTTPS)
3. **Use `sameSite`** for CSRF protection
4. **Sign sensitive cookies** to prevent tampering
5. **Encrypt PII** (personally identifiable information)
6. **Set appropriate `maxAge`** to limit exposure
7. **Use domain/path** to limit cookie scope
8. **Clean up expired sessions** regularly

## Migration from Express ðŸ”„

```typescript
// Express
app.use(require('cookie-parser')('secret'));
res.cookie('name', 'value', { signed: true });
const value = req.signedCookies.name;

// Azura
const jar = new CookieJar('secret');
const cookie = jar.set('name', 'value', { signed: true });
res.setHeader('Set-Cookie', cookie);
const value = jar.get('name', true);
```

Almost the same, but more powerful! ðŸŽ‰

## API Reference ðŸ“–

### CookieJar

- `new CookieJar(secret?: string)` - Create cookie manager
- `set(name, value, options)` - Set cookie
- `get(name, signed?, encrypted?)` - Get cookie value
- `delete(name, options?)` - Delete cookie
- `has(name)` - Check if cookie exists
- `all()` - Get all cookies
- `clear()` - Clear all cookies

### SessionManager

- `new SessionManager(store, options)` - Create session manager
- `get(cookies)` - Get session
- `create(data)` - Create new session
- `update(id, data)` - Update session
- `destroy(id)` - Destroy session
- `touch(id)` - Update expiration

### CookiePresets

- `session(secure?)` - Session cookie (24h)
- `rememberMe(secure?)` - Remember me (30 days)
- `tracking(secure?)` - Tracking cookie (1 year)
- `flash(secure?)` - Flash message (session-only)
- `csrf(secure?)` - CSRF token

## Examples ðŸ“š

Check out the complete examples:
- [cookies.example.ts](https://github.com/0xvin/azurajs/blob/main/examples/servers/cookies.example.ts) - All cookie features
  httpOnly: true  // Recommended for session cookies
});
```

### secure

Only send cookie over HTTPS:

```typescript
serializeCookie("token", "value", {
  secure: true  // Required for production
});
```

### maxAge

Cookie lifetime in seconds:

```typescript
serializeCookie("sessionId", "value", {
  maxAge: 3600  // 1 hour
});

serializeCookie("rememberMe", "value", {
  maxAge: 30 * 24 * 60 * 60  // 30 days
});
```

### path

Cookie path scope:

```typescript
serializeCookie("token", "value", {
  path: "/"  // Available on all paths
});

serializeCookie("admin", "value", {
  path: "/admin"  // Only on /admin routes
});
```

### domain

Cookie domain scope:

```typescript
serializeCookie("token", "value", {
  domain: ".example.com"  // Available on all subdomains
});
```

### sameSite

CSRF protection:

```typescript
serializeCookie("token", "value", {
  sameSite: "Strict"  // Strict, Lax, or None
});
```

## Complete Cookie Example ðŸŽ¯

### TypeScript

```typescript
import { Controller, Post, Body, Res } from "azurajs/decorators";
import { parseCookiesHeader, serializeCookie } from "azurajs/cookies";
import type { CookieOptions } from "azurajs/cookies";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/auth")
export class AuthController {
  // Login and set session cookie
  @Post("/login")
  login(@Body() credentials: any, @Res() res: ResponseServer) {
    // Validate credentials
    if (!isValidCredentials(credentials)) {
      return res.status(401).json({ error: "Invalid credentials" });
    }
    
    // Create session
    const sessionId = createSession(credentials.username);
    
    const options: CookieOptions = {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      maxAge: 24 * 60 * 60, // 24 hours
      path: "/",
      sameSite: "Strict",
    };
    
    const cookie = serializeCookie("sessionId", sessionId, options);
    res.setHeader("Set-Cookie", cookie);
    
    res.json({ success: true });
  }

  // Get user from session cookie
  @Get("/me")
  getCurrentUser(@Req() req: RequestServer, @Res() res: ResponseServer) {
    const cookies = parseCookiesHeader(req.headers.cookie || "");
    const sessionId = cookies.sessionId;
    
    if (!sessionId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    
    const user = getUserFromSession(sessionId);
    if (!user) {
      return res.status(401).json({ error: "Invalid session" });
    }
    
    res.json({ user });
  }

  // Logout and clear cookie
  @Post("/logout")
  logout(@Res() res: ResponseServer) {
    // Clear cookie by setting maxAge to 0
    const cookie = serializeCookie("sessionId", "", {
      httpOnly: true,
      maxAge: 0,
      path: "/",
    });
    
    res.setHeader("Set-Cookie", cookie);
    res.json({ success: true });
  }
}
```

### JavaScript

```javascript
const { parseCookiesHeader, serializeCookie } = require("azurajs/cookies");

// Login and set session cookie
app.post("/api/auth/login", ({ req, res }) => {
  const credentials = req.body;
  
  // Validate credentials
  if (!isValidCredentials(credentials)) {
    return res.status(401).json({ error: "Invalid credentials" });
  }
  
  // Create session
  const sessionId = createSession(credentials.username);
  
  const options = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    maxAge: 24 * 60 * 60, // 24 hours
    path: "/",
    sameSite: "Strict",
  };
  
  const cookie = serializeCookie("sessionId", sessionId, options);
  res.setHeader("Set-Cookie", cookie);
  
  res.json({ success: true });
});

// Get user from session cookie
app.get("/api/auth/me", ({ req, res }) => {
  const cookies = parseCookiesHeader(req.headers.cookie || "");
  const sessionId = cookies.sessionId;
  
  if (!sessionId) {
    return res.status(401).json({ error: "Not authenticated" });
  }
  
  const user = getUserFromSession(sessionId);
  if (!user) {
    return res.status(401).json({ error: "Invalid session" });
  }
  
  res.json({ user });
});

// Logout and clear cookie
app.post("/api/auth/logout", ({ req, res }) => {
  // Clear cookie by setting maxAge to 0
  const cookie = serializeCookie("sessionId", "", {
    httpOnly: true,
    maxAge: 0,
    path: "/",
  });
  
  res.setHeader("Set-Cookie", cookie);
  res.json({ success: true });
});
```

## Cookie Middleware ðŸ”Œ

Create middleware for cookie authentication:

### TypeScript

```typescript
import { parseCookiesHeader } from "azurajs/cookies";
import type { RequestHandler } from "azurajs/types";

export const cookieAuthMiddleware: RequestHandler = async (req, res, next) => {
  const cookies = parseCookiesHeader(req.headers.cookie || "");
  const sessionId = cookies.sessionId;
  
  if (!sessionId) {
    res.status(401).json({ error: "Not authenticated" });
    return;
  }
  
  const user = await getUserFromSession(sessionId);
  if (!user) {
    res.status(401).json({ error: "Invalid session" });
    return;
  }
  
  // Attach user to request
  (req as any).user = user;
  await next();
};

// Usage
app.use(cookieAuthMiddleware);
```

### JavaScript

```javascript
const { parseCookiesHeader } = require("azurajs/cookies");

const cookieAuthMiddleware = async (req, res, next) => {
  const cookies = parseCookiesHeader(req.headers.cookie || "");
  const sessionId = cookies.sessionId;
  
  if (!sessionId) {
    res.status(401).json({ error: "Not authenticated" });
    return;
  }
  
  const user = await getUserFromSession(sessionId);
  if (!user) {
    res.status(401).json({ error: "Invalid session" });
    return;
  }
  
  // Attach user to request
  req.user = user;
  await next();
};

// Usage
app.use(cookieAuthMiddleware);
```

## Multiple Cookies ðŸªðŸª

Set multiple cookies at once:

```typescript
@Post("/login")
login(@Body() credentials: any, @Res() res: ResponseServer) {
  const sessionId = createSession(credentials.username);
  const csrfToken = generateCSRFToken();
  
  const cookies = [
    serializeCookie("sessionId", sessionId, {
      httpOnly: true,
      secure: true,
      maxAge: 3600,
    }),
    serializeCookie("csrfToken", csrfToken, {
      httpOnly: false,  // Accessible to JavaScript
      secure: true,
      maxAge: 3600,
    }),
  ];
  
  res.setHeader("Set-Cookie", cookies);
  res.json({ success: true });
}
```

## Signed Cookies ðŸ”

Sign cookies for tamper protection:

```typescript
import { createHmac } from "crypto";

function signCookie(value: string, secret: string): string {
  const signature = createHmac("sha256", secret)
    .update(value)
    .digest("base64");
  return `${value}.${signature}`;
}

function verifyCookie(signedValue: string, secret: string): string | null {
  const [value, signature] = signedValue.split(".");
  const expectedSignature = createHmac("sha256", secret)
    .update(value)
    .digest("base64");
  
  if (signature === expectedSignature) {
    return value;
  }
  return null;
}

// Usage
@Post("/login")
login(@Body() credentials: any, @Res() res: ResponseServer) {
  const sessionId = createSession(credentials.username);
  const signedSessionId = signCookie(sessionId, process.env.COOKIE_SECRET!);
  
  const cookie = serializeCookie("sessionId", signedSessionId, {
    httpOnly: true,
    secure: true,
  });
  
  res.setHeader("Set-Cookie", cookie);
  res.json({ success: true });
}

@Get("/me")
getCurrentUser(@Req() req: RequestServer, @Res() res: ResponseServer) {
  const cookies = parseCookiesHeader(req.headers.cookie || "");
  const signedSessionId = cookies.sessionId;
  
  const sessionId = verifyCookie(signedSessionId, process.env.COOKIE_SECRET!);
  if (!sessionId) {
    return res.status(401).json({ error: "Invalid session" });
  }
  
  const user = getUserFromSession(sessionId);
  res.json({ user });
}
```

## Best Practices âœ¨

<Callout type="tip">
  **Always use httpOnly** for sensitive cookies (sessions, tokens)
</Callout>

<Callout type="tip">
  **Use secure in production** to ensure cookies are only sent over HTTPS
</Callout>

<Callout type="warn">
  **Set appropriate expiration** - Don't keep sessions forever
</Callout>

<Callout type="warn">
  **Use sameSite** for CSRF protection
</Callout>

## Next Steps ðŸ“–

<Cards>
  <Card title="Middleware" href="middleware" description="Create authentication middleware" />
  <Card title="Error Handling" href="error-handling" description="Handle auth errors" />
  <Card title="Examples" href="examples" description="See cookie usage examples" />
</Cards>
