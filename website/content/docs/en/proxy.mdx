---
title: Proxy & Reverse Proxy
description: Complete proxy and reverse proxy system for building API Gateways and microservices
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Proxy & Reverse Proxy System üîÑ

AzuraJS includes a **powerful, built-in proxy/reverse proxy system** for creating API Gateways, microservices architectures, and load balancers. No additional packages needed - just use `app.proxy()` and you're ready!

<Callout type="info">
**What is a Proxy?** A proxy forwards client requests to other servers and returns their responses. It's essential for microservices, API gateways, load balancing, and service composition.
</Callout>

## Why Use AzuraJS Proxy? üéØ

### Key Benefits

- ‚úÖ **Zero Configuration**: No complex setup, just works out of the box
- ‚úÖ **Path Rewriting**: Intelligent URL transformation and routing
- ‚úÖ **Built-in Load Balancing**: Distribute load across multiple services
- ‚úÖ **Custom Headers**: Add authentication, tracking, and custom headers
- ‚úÖ **Error Handling**: Comprehensive error management and retries
- ‚úÖ **WebSocket Support**: Proxy WebSocket connections seamlessly
- ‚úÖ **Middleware Integration**: Use with AzuraJS middleware system
- ‚úÖ **High Performance**: Optimized for speed and low latency

### Common Use Cases

- üåê **API Gateway**: Centralize multiple microservices behind single endpoint
- üîê **Authentication Gateway**: Add auth before proxying to services
- üìä **Load Balancer**: Distribute traffic across service instances
- üîß **Service Mesh**: Connect microservices with intelligent routing
- üåç **External API Proxy**: Proxy to third-party APIs with rate limiting
- üé≠ **A/B Testing**: Route traffic to different service versions
- üîÑ **Blue-Green Deployment**: Switch between deployment versions

## Quick Start üöÄ

### Basic Proxy Setup

<Tabs items={['TypeScript', 'JavaScript']}>
<Tab value="TypeScript">
```typescript
import { AzuraClient } from 'azurajs';

const app = new AzuraClient();

// Proxy all /api/* requests to http://localhost:4000
app.proxy('/api', 'http://localhost:4000', {
  pathRewrite: { '^/api': '' }  // Remove /api prefix
});

await app.listen(3000);
```
</Tab>
<Tab value="JavaScript">
```javascript
const { AzuraClient } = require('azurajs');

const app = new AzuraClient();

// Proxy all /api/* requests to http://localhost:4000
app.proxy('/api', 'http://localhost:4000', {
  pathRewrite: { '^/api': '' }  // Remove /api prefix
});

app.listen(3000);
```
</Tab>
</Tabs>

**How it works:**
- Client makes: `GET http://localhost:3000/api/users`
- Proxy forwards to: `GET http://localhost:4000/users`
- Response is sent back to client

<Callout type="success">
**That's it!** You now have a working reverse proxy. All `/api/*` requests are forwarded to your backend service.
</Callout>

### With Path Rewrite

```javascript
app.proxy('/api/v1', 'http://localhost:4000', {
  pathRewrite: {
    '^/api/v1': '/api',  // Rewrites /api/v1 to /api
    '/old': '/new'        // Replaces /old with /new
  }
});
```

## Proxy Options

### ProxyOptions Interface

```typescript
interface ProxyOptions {
  // Target server URL
  target: string;
  
  // Path rewriting
  pathRewrite?: Record<string, string>;
  
  // Custom headers
  headers?: Record<string, string>;
  
  // Timeout in ms (default: 30000)
  timeout?: number;
  
  // Follow redirects
  followRedirects?: boolean;
  
  // Preserve original host
  preserveHost?: boolean;
  
  // Log level: "none" | "info" | "debug"
  logLevel?: string;
  
  // Callbacks
  onProxyReq?: (proxyReq, req) => void;
  onProxyRes?: (proxyRes, req, res) => void;
  onError?: (err, req, res) => void;
}
```

### Example with All Options

```javascript
app.proxy('/api', 'http://localhost:4000', {
  // Path rewriting
  pathRewrite: { '^/api': '' },
  
  // Custom headers
  headers: {
    'X-Custom-Header': 'MyValue',
    'Authorization': 'Bearer token123'
  },
  
  // 10 second timeout
  timeout: 10000,
  
  // Detailed logging
  logLevel: 'debug',
  
  // Modify request before sending
  onProxyReq: (proxyReq, req) => {
    console.log(`Proxying ${req.method} ${req.url}`);
    proxyReq.setHeader('X-Request-ID', `req-${Date.now()}`);
  },
  
  // Modify response before sending to client
  onProxyRes: (proxyRes, req, res) => {
    console.log(`Response status: ${proxyRes.statusCode}`);
  },
  
  // Custom error handling
  onError: (err, req, res) => {
    console.error('Proxy error:', err);
    res.status(502).json({ error: 'Gateway Error' });
  }
});
```

## Use Cases

### API Gateway

Centralize all your APIs in a single endpoint:

```javascript
const gateway = new AzuraClient();

// Multiple services
gateway.proxy('/users', 'http://localhost:4001');
gateway.proxy('/products', 'http://localhost:4002');
gateway.proxy('/orders', 'http://localhost:4003');

gateway.listen(3000);
```

**Access:**
- `/users/*` ‚Üí User service on port 4001
- `/products/*` ‚Üí Product service on port 4002
- `/orders/*` ‚Üí Order service on port 4003

### Proxy to External APIs

```javascript
// Proxy to GitHub API
app.proxy('/github', 'https://api.github.com', {
  pathRewrite: { '^/github': '' },
  headers: {
    'User-Agent': 'MyApp/1.0'
  }
});

// Access: http://localhost:3000/github/users/octocat
```

### Authentication at Gateway

```javascript
// Authentication middleware
function authMiddleware({ req, res, next }) {
  const token = req.headers.authorization;
  
  if (!token) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  // Validate token
  if (!validateToken(token)) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  next();
}

// Apply authentication before proxy
app.use('/api', authMiddleware);
app.proxy('/api', 'http://localhost:4000', {
  pathRewrite: { '^/api': '' }
});
```

### Microservices with Cache

```javascript
const cache = new Map();

function cacheMiddleware({ req, res, next }) {
  const key = req.url;
  
  if (cache.has(key)) {
    return res.json(cache.get(key));
  }
  
  const originalJson = res.json.bind(res);
  res.json = (data) => {
    cache.set(key, data);
    return originalJson(data);
  };
  
  next();
}

app.use('/api/posts', cacheMiddleware);
app.proxy('/api/posts', 'https://jsonplaceholder.typicode.com', {
  pathRewrite: { '^/api': '' }
});
```

## Error Handling

### Common Errors

```javascript
app.proxy('/api', 'http://localhost:4000', {
  onError: (err, req, res) => {
    if (err.code === 'ECONNREFUSED') {
      return res.status(503).json({ 
        error: 'Service Unavailable',
        message: 'The service is temporarily unavailable'
      });
    }
    
    if (err.code === 'ETIMEDOUT') {
      return res.status(504).json({ 
        error: 'Gateway Timeout',
        message: 'The service took too long to respond'
      });
    }
    
    res.status(502).json({ 
      error: 'Bad Gateway',
      message: 'Error processing the request'
    });
  }
});
```

## Load Balancing üîÑ

Distribute traffic across multiple servers:

```javascript
const servers = [
  'http://localhost:4001',
  'http://localhost:4002',
  'http://localhost:4003'
];

let currentServer = 0;

function loadBalancer({ req, res, next }) {
  // Round-robin load balancing
  const target = servers[currentServer];
  currentServer = (currentServer + 1) % servers.length;
  
  req.proxyTarget = target;
  next();
}

app.use('/api', loadBalancer);
app.proxy('/api', (req) => req.proxyTarget, {
  pathRewrite: { '^/api': '' },
  onProxyReq: (proxyReq, req) => {
    console.log(`Routing to: ${req.proxyTarget}`);
  }
});
```

### Health Check with Failover

```javascript
const servers = [
  { url: 'http://localhost:4001', healthy: true },
  { url: 'http://localhost:4002', healthy: true },
  { url: 'http://localhost:4003', healthy: true }
];

// Check server health every 30 seconds
setInterval(async () => {
  for (const server of servers) {
    try {
      const response = await fetch(`${server.url}/health`);
      server.healthy = response.ok;
    } catch {
      server.healthy = false;
    }
  }
}, 30000);

function smartLoadBalancer({ req, res, next }) {
  const healthyServers = servers.filter(s => s.healthy);
  
  if (healthyServers.length === 0) {
    return res.status(503).json({ error: 'No servers available' });
  }
  
  // Pick random healthy server
  const server = healthyServers[Math.floor(Math.random() * healthyServers.length)];
  req.proxyTarget = server.url;
  next();
}

app.use('/api', smartLoadBalancer);
app.proxy('/api', (req) => req.proxyTarget, {
  pathRewrite: { '^/api': '' }
});
```

## WebSocket Proxying üîå

Proxy WebSocket connections:

```javascript
app.proxy('/ws', 'ws://localhost:4000', {
  ws: true,  // Enable WebSocket proxying
  onProxyReqWs: (proxyReq, req, socket) => {
    console.log('WebSocket proxied');
  },
  onError: (err, req, socket) => {
    console.error('WebSocket error:', err);
    socket.end();
  }
});
```

### Full WebSocket Example

```javascript
import { AzuraClient } from 'azurajs';

const app = new AzuraClient();

// HTTP endpoint
app.get('/status', ({ res }) => {
  res.json({ status: 'online' });
});

// WebSocket proxy
app.proxy('/socket', 'ws://localhost:8080', {
  ws: true,
  pathRewrite: { '^/socket': '' },
  headers: {
    'X-Gateway': 'AzuraJS'
  }
});

await app.listen(3000);
```

## Advanced Examples üöÄ

### Circuit Breaker Pattern

Protect your system from cascading failures:

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }
  
  async call(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}

const breaker = new CircuitBreaker();

app.proxy('/api', 'http://localhost:4000', {
  pathRewrite: { '^/api': '' },
  onError: async (err, req, res) => {
    breaker.onFailure();
    
    if (breaker.state === 'OPEN') {
      return res.status(503).json({
        error: 'Service temporarily unavailable',
        retryAfter: Math.ceil((breaker.nextAttempt - Date.now()) / 1000)
      });
    }
    
    res.status(502).json({ error: 'Bad Gateway' });
  }
});
```

### Request/Response Transformation

```javascript
app.proxy('/api', 'http://localhost:4000', {
  pathRewrite: { '^/api': '' },
  
  // Transform request
  onProxyReq: (proxyReq, req) => {
    // Add authentication
    proxyReq.setHeader('X-API-Key', process.env.API_KEY);
    
    // Add request ID for tracing
    const requestId = `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    proxyReq.setHeader('X-Request-ID', requestId);
    req.requestId = requestId;
    
    // Transform body if needed
    if (req.body) {
      const body = JSON.stringify({
        ...req.body,
        timestamp: new Date().toISOString(),
        source: 'api-gateway'
      });
      proxyReq.setHeader('Content-Length', Buffer.byteLength(body));
      proxyReq.write(body);
    }
  },
  
  // Transform response
  onProxyRes: (proxyRes, req, res) => {
    let body = '';
    
    proxyRes.on('data', (chunk) => {
      body += chunk;
    });
    
    proxyRes.on('end', () => {
      try {
        const data = JSON.parse(body);
        
        // Add metadata
        const transformed = {
          data,
          metadata: {
            requestId: req.requestId,
            timestamp: new Date().toISOString(),
            cached: false
          }
        };
        
        res.json(transformed);
      } catch {
        res.send(body);
      }
    });
  }
});
```

### Rate Limiting per Target

```javascript
import { rateLimit } from 'azurajs/rate-limit';

const limiters = {
  '/users': rateLimit({ windowMs: 60000, max: 100 }),
  '/products': rateLimit({ windowMs: 60000, max: 200 }),
  '/orders': rateLimit({ windowMs: 60000, max: 50 })
};

Object.entries(limiters).forEach(([path, limiter]) => {
  app.use(path, limiter);
  app.proxy(path, `http://localhost:4000${path}`, {
    pathRewrite: { [`^${path}`]: '' }
  });
});
```

### Service Discovery with Consul

```javascript
import Consul from 'consul';

const consul = new Consul();

async function getServiceUrl(serviceName) {
  const result = await consul.health.service({
    service: serviceName,
    passing: true
  });
  
  if (result.length === 0) {
    throw new Error(`No healthy instances of ${serviceName}`);
  }
  
  // Random load balancing
  const instance = result[Math.floor(Math.random() * result.length)];
  return `http://${instance.Service.Address}:${instance.Service.Port}`;
}

app.use('/api/users', async (req, res, next) => {
  try {
    req.serviceUrl = await getServiceUrl('user-service');
    next();
  } catch (error) {
    res.status(503).json({ error: error.message });
  }
});

app.proxy('/api/users', (req) => req.serviceUrl, {
  pathRewrite: { '^/api/users': '' }
});
```

## Best Practices üìã

### 1. Always Set Timeouts

```javascript
app.proxy('/api', 'http://localhost:4000', {
  timeout: 30000,  // 30 seconds
  onError: (err, req, res) => {
    if (err.code === 'ETIMEDOUT') {
      res.status(504).json({ error: 'Gateway Timeout' });
    }
  }
});
```

### 2. Implement Proper Error Handling

```javascript
app.proxy('/api', 'http://localhost:4000', {
  onError: (err, req, res) => {
    // Log for monitoring
    console.error('[Proxy Error]', {
      url: req.url,
      method: req.method,
      error: err.message,
      code: err.code,
      timestamp: new Date().toISOString()
    });
    
    // Return appropriate status
    const statusMap = {
      'ECONNREFUSED': 503,
      'ETIMEDOUT': 504,
      'ENOTFOUND': 502,
      'ECONNRESET': 502
    };
    
    const status = statusMap[err.code] || 502;
    res.status(status).json({
      error: 'Proxy Error',
      message: err.message
    });
  }
});
```

### 3. Use Path Rewriting Correctly

```javascript
// ‚úÖ Good - Remove prefix
app.proxy('/api/v1', 'http://localhost:4000', {
  pathRewrite: { '^/api/v1': '' }
});

// ‚ùå Bad - Incorrect regex
app.proxy('/api/v1', 'http://localhost:4000', {
  pathRewrite: { '/api/v1': '' }  // Won't match paths correctly
});
```

### 4. Add Request Tracing

```javascript
app.proxy('/api', 'http://localhost:4000', {
  onProxyReq: (proxyReq, req) => {
    const traceId = req.headers['x-trace-id'] || `trace-${Date.now()}`;
    proxyReq.setHeader('X-Trace-ID', traceId);
    proxyReq.setHeader('X-Forwarded-For', req.ip);
    proxyReq.setHeader('X-Real-IP', req.ip);
  }
});
```

### 5. Preserve Original Headers When Needed

```javascript
app.proxy('/api', 'http://localhost:4000', {
  preserveHost: true,  // Keep original Host header
  headers: {
    'X-Forwarded-Proto': 'https',
    'X-Forwarded-Port': '443'
  }
});
```

### 6. Handle Large Payloads

```javascript
app.proxy('/upload', 'http://localhost:4000', {
  timeout: 120000,  // 2 minutes for uploads
  onProxyReq: (proxyReq, req) => {
    if (req.headers['content-length']) {
      const sizeMB = parseInt(req.headers['content-length']) / (1024 * 1024);
      if (sizeMB > 100) {
        throw new Error('Payload too large');
      }
    }
  }
});
```

## Troubleshooting üîß

### Problem: Connection Refused

**Symptoms:** `ECONNREFUSED` errors

**Solutions:**

```javascript
// 1. Verify target service is running
// 2. Check firewall rules
// 3. Implement retry logic

let retries = 0;
const maxRetries = 3;

app.proxy('/api', 'http://localhost:4000', {
  onError: async (err, req, res) => {
    if (err.code === 'ECONNREFUSED' && retries < maxRetries) {
      retries++;
      console.log(`Retry ${retries}/${maxRetries}`);
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * retries));
      
      // Retry request
      return; // Implement retry logic here
    }
    
    res.status(503).json({ error: 'Service Unavailable' });
    retries = 0;
  }
});
```

### Problem: Timeout Errors

**Symptoms:** Requests timing out

**Solutions:**

```javascript
// 1. Increase timeout for slow endpoints
app.proxy('/api/reports', 'http://localhost:4000', {
  timeout: 60000,  // 60 seconds for reports
});

// 2. Implement caching
const cache = new Map();

app.use('/api', (req, res, next) => {
  const key = `${req.method}:${req.url}`;
  
  if (cache.has(key)) {
    const { data, timestamp } = cache.get(key);
    
    // Cache for 5 minutes
    if (Date.now() - timestamp < 300000) {
      return res.json(data);
    }
  }
  
  const originalJson = res.json.bind(res);
  res.json = (data) => {
    cache.set(key, { data, timestamp: Date.now() });
    return originalJson(data);
  };
  
  next();
});
```

### Problem: Path Not Rewriting Correctly

**Symptoms:** 404 errors on proxied requests

**Solutions:**

```javascript
// ‚úÖ Correct: Use regex with ^
app.proxy('/api/v1', 'http://localhost:4000', {
  pathRewrite: { '^/api/v1': '' },
  logLevel: 'debug'  // Enable logging to see rewrites
});

// Test the rewrite
// Input:  /api/v1/users
// Output: /users ‚úì

// ‚ùå Incorrect: Without ^
app.proxy('/api/v1', 'http://localhost:4000', {
  pathRewrite: { '/api/v1': '' }  // May not work correctly
});
```

### Problem: Headers Not Being Forwarded

**Symptoms:** Backend not receiving expected headers

**Solutions:**

```javascript
app.proxy('/api', 'http://localhost:4000', {
  onProxyReq: (proxyReq, req) => {
    // Forward all headers
    Object.keys(req.headers).forEach(key => {
      proxyReq.setHeader(key, req.headers[key]);
    });
    
    // Add custom headers
    proxyReq.setHeader('X-Forwarded-For', req.ip);
    proxyReq.setHeader('X-Forwarded-Proto', req.protocol);
    proxyReq.setHeader('X-Forwarded-Host', req.headers.host);
  }
});
```

### Problem: CORS Issues with Proxy

**Symptoms:** CORS errors in browser

**Solutions:**

```javascript
import { cors } from 'azurajs/cors';

// Apply CORS before proxy
app.use(cors({
  origin: '*',
  credentials: true
}));

app.proxy('/api', 'http://localhost:4000', {
  onProxyRes: (proxyRes, req, res) => {
    // Add CORS headers to proxy response
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
});
```

### Problem: Body Not Being Proxied

**Symptoms:** POST/PUT requests losing body

**Solutions:**

```javascript
// Make sure body parser is enabled
app.use(express.json());

app.proxy('/api', 'http://localhost:4000', {
  onProxyReq: (proxyReq, req) => {
    if (req.body) {
      const body = JSON.stringify(req.body);
      proxyReq.setHeader('Content-Type', 'application/json');
      proxyReq.setHeader('Content-Length', Buffer.byteLength(body));
      proxyReq.write(body);
    }
  }
});
```

### Problem: Memory Leaks with Long-Running Proxies

**Symptoms:** Memory usage grows over time

**Solutions:**

```javascript
// 1. Implement connection pooling
import http from 'http';

const agent = new http.Agent({
  keepAlive: true,
  maxSockets: 50,
  maxFreeSockets: 10,
  timeout: 60000
});

app.proxy('/api', 'http://localhost:4000', {
  agent,  // Use connection pooling
});

// 2. Clean up event listeners
app.proxy('/api', 'http://localhost:4000', {
  onProxyRes: (proxyRes, req, res) => {
    proxyRes.on('end', () => {
      // Clean up
      proxyRes.removeAllListeners();
    });
  }
});
```

## Performance Optimization ‚ö°

### 1. Connection Pooling

```javascript
import http from 'http';

const agent = new http.Agent({
  keepAlive: true,
  keepAliveMsecs: 1000,
  maxSockets: 100,
  maxFreeSockets: 10
});

app.proxy('/api', 'http://localhost:4000', {
  agent
});
```

### 2. Response Compression

```javascript
import zlib from 'zlib';

app.proxy('/api', 'http://localhost:4000', {
  onProxyRes: (proxyRes, req, res) => {
    const acceptEncoding = req.headers['accept-encoding'] || '';
    
    if (acceptEncoding.includes('gzip')) {
      res.setHeader('Content-Encoding', 'gzip');
      proxyRes.pipe(zlib.createGzip()).pipe(res);
    } else {
      proxyRes.pipe(res);
    }
  }
});
```

### 3. Request Deduplication

```javascript
const pendingRequests = new Map();

app.use('/api', async (req, res, next) => {
  const key = `${req.method}:${req.url}`;
  
  if (pendingRequests.has(key)) {
    // Wait for existing request
    const result = await pendingRequests.get(key);
    return res.json(result);
  }
  
  // Create promise for this request
  const promise = new Promise((resolve, reject) => {
    const originalJson = res.json.bind(res);
    res.json = (data) => {
      resolve(data);
      pendingRequests.delete(key);
      return originalJson(data);
    };
  });
  
  pendingRequests.set(key, promise);
  next();
});
```

## Complete Examples üìö

### Full API Gateway

```javascript
import { AzuraClient } from 'azurajs';
import { cors } from 'azurajs/cors';
import { rateLimit } from 'azurajs/rate-limit';

const app = new AzuraClient();

// Global middleware
app.use(cors());
app.use(rateLimit({ windowMs: 60000, max: 100 }));

// Authentication middleware
const auth = ({ req, res, next }) => {
  const token = req.headers.authorization;
  if (!token) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
};

// Health check
app.get('/health', ({ res }) => {
  res.json({ status: 'healthy' });
});

// Public endpoints
app.proxy('/api/public', 'http://localhost:4001', {
  pathRewrite: { '^/api/public': '' }
});

// Protected endpoints
app.use('/api/users', auth);
app.proxy('/api/users', 'http://localhost:4002', {
  pathRewrite: { '^/api/users': '' }
});

app.use('/api/orders', auth);
app.proxy('/api/orders', 'http://localhost:4003', {
  pathRewrite: { '^/api/orders': '' }
});

await app.listen(3000);
console.log('API Gateway running on port 3000');
```

See complete examples at [examples/servers/proxy](https://github.com/azurajsjs/azurajs/tree/main/examples/servers/proxy):

- **simple.js** - Basic proxy setup
- **microservices.js** - Gateway for multiple services
- **load-balancer.js** - Load balancing implementation
- **circuit-breaker.js** - Circuit breaker pattern

## Reference Table üìä

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `target` | `string` | Required | Target server URL |
| `pathRewrite` | `Record<string, string>` | `{}` | Path rewriting rules |
| `headers` | `Record<string, string>` | `{}` | Custom headers to add |
| `timeout` | `number` | `30000` | Request timeout in ms |
| `followRedirects` | `boolean` | `true` | Follow HTTP redirects |
| `preserveHost` | `boolean` | `false` | Keep original Host header |
| `ws` | `boolean` | `false` | Enable WebSocket proxying |
| `logLevel` | `string` | `'none'` | Log level: none, info, debug |
| `onProxyReq` | `function` | `null` | Modify request before proxy |
| `onProxyRes` | `function` | `null` | Modify response after proxy |
| `onError` | `function` | `null` | Custom error handling |

## Next Steps

- [Router with Prefix](/docs/en/routing#router-with-prefix)
- [Middleware](/docs/en/middleware)
- [Rate Limiting](/docs/en/rate-limiting)
- [CORS Configuration](/docs/en/cors)
