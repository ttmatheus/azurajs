---
title: TypeScript Support
description: Leverage full TypeScript support in AzuraJS
icon: Box
---

# TypeScript Support üî∑

AzuraJS is built with TypeScript and provides first-class type safety throughout your application.

## Full Type Safety üõ°Ô∏è

All AzuraJS APIs are fully typed:

```typescript
import type {
  RequestServer,
  ResponseServer,
} from "azurajs/types";
import type { RequestHandler } from "azurajs/types";
import type { ConfigTypes } from "azurajs/config";
import type { CookieOptions } from "azurajs/cookies";
```

## Request and Response Types üì¶

### RequestServer

```typescript
interface RequestServer extends IncomingMessage {
  body?: any;
  params?: Record<string, string>;
  query?: Record<string, string>;
  cookies?: Record<string, string>;
  originalUrl: string;
  protocol: "http" | "https";
  secure: boolean;
  hostname: string;
  subdomains: string[];
  ips: string[];
  get(name: string): string | undefined;
  header(name: string): string | undefined;
}
```

### ResponseServer

```typescript
interface ResponseServer extends ServerResponse {
  status(code: number): ResponseServer;
  send(body: any): void;
  json(data: any): void;
  set(field: string, value: string | number | string[]): ResponseServer;
  header(field: string, value: string | number | string[]): ResponseServer;
  get(field: string): string | undefined;
  type(contentType: string): ResponseServer;
  contentType(contentType: string): ResponseServer;
}
```

## Typed DTOs üìã

Create interfaces for your Data Transfer Objects:

```typescript
// dtos/CreateUserDto.ts
export interface CreateUserDto {
  name: string;
  email: string;
  password: string;
  age?: number;
  role?: "user" | "admin";
}

export interface UpdateUserDto {
  name?: string;
  email?: string;
  age?: number;
}

export interface UserResponse {
  id: string;
  name: string;
  email: string;
  age?: number;
  role: string;
  createdAt: Date;
  updatedAt: Date;
}

// Use in controller
@Controller("/api/users")
export class UserController {
  @Post()
  createUser(
    @Body() data: CreateUserDto,
    @Res() res: ResponseServer
  ): void {
    // data is fully typed
    const user: UserResponse = {
      id: generateId(),
      name: data.name,
      email: data.email,
      age: data.age,
      role: data.role || "user",
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    res.status(201).json({ user });
  }

  @Patch("/:id")
  updateUser(
    @Param("id") id: string,
    @Body() data: UpdateUserDto
  ): UserResponse {
    // TypeScript knows all fields are optional
    const user = findUserById(id);
    return { ...user, ...data, updatedAt: new Date() };
  }
}
```

## Generics üéØ

Use generics for reusable functions:

```typescript
// Generic paginated response
interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

function paginate<T>(
  items: T[],
  page: number,
  pageSize: number
): PaginatedResponse<T> {
  const start = (page - 1) * pageSize;
  const end = start + pageSize;
  
  return {
    data: items.slice(start, end),
    total: items.length,
    page,
    pageSize,
    totalPages: Math.ceil(items.length / pageSize)
  };
}

@Get("/users")
getUsers(@Query("page") page: string, @Query("pageSize") pageSize: string) {
  const users: User[] = getAllUsers();
  
  // Type inferred: PaginatedResponse<User>
  const response = paginate(users, Number(page), Number(pageSize));
  
  return response;
}
```

## Type Guards üõ°Ô∏è

Create type guards for runtime type verification:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
}

interface Admin extends User {
  permissions: string[];
  isSuperAdmin: boolean;
}

// Type guard
function isAdmin(user: User | Admin): user is Admin {
  return "permissions" in user && "isSuperAdmin" in user;
}

@Get("/dashboard")
getDashboard(@Req() req: RequestServer) {
  const user = req.user as User | Admin;
  
  if (isAdmin(user)) {
    // TypeScript knows user is Admin here
    return {
      dashboard: "admin",
      permissions: user.permissions,
      isSuperAdmin: user.isSuperAdmin
    };
  }
  
  // TypeScript knows user is User here
  return { dashboard: "user" };
}
```

## Zod Integration üî∑

Use Zod for validation and type inference:

```typescript
import { z } from "zod";

// Define schema
const CreateUserSchema = z.object({
  name: z.string().min(2).max(50),
  email: z.string().email(),
  password: z.string().min(8),
  age: z.number().int().positive().optional(),
  role: z.enum(["user", "admin", "moderator"]).default("user")
});

// Infer type from schema
type CreateUserDto = z.infer<typeof CreateUserSchema>;
// Equivalent to:
// interface CreateUserDto {
//   name: string;
//   email: string;
//   password: string;
//   age?: number;
//   role: "user" | "admin" | "moderator";
// }

@Controller("/api/users")
export class UserController {
  @Post()
  createUser(@Body() data: unknown, @Res() res: ResponseServer) {
    // Validate and get typed data
    const validData: CreateUserDto = CreateUserSchema.parse(data);
    
    // validData is fully typed
    const user = {
      id: generateId(),
      ...validData,
      createdAt: new Date()
    };
    
    res.status(201).json({ user });
  }
}
```

## Middleware Types üîå

Complete typing for middleware:

```typescript
import type { RequestServer, ResponseServer } from "azurajs/types";
import type { RequestHandler } from "azurajs/types";

const authMiddleware: RequestHandler = (req, res, next) => {
  const token = req.headers.authorization;
  
  if (!token) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  
  try {
    req.user = verifyToken(token);
    next();
  } catch (error) {
    res.status(401).json({ error: "Invalid token" });
  }
};

// With custom types in request
interface AuthenticatedRequest extends RequestServer {
  user: {
    id: string;
    email: string;
    role: string;
  };
}

const roleMiddleware = (allowedRoles: string[]): RequestHandler => {
  return (req, res, next) => {
    const authReq = req as AuthenticatedRequest;
    
    if (!authReq.user) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    
    if (!allowedRoles.includes(authReq.user.role)) {
      return res.status(403).json({ error: "Access denied" });
    }
    
    next();
  };
};
```

## Configuration Types ‚öôÔ∏è

Typing for application configuration:

```typescript
import type { ConfigTypes } from "azurajs/config";

const config: ConfigTypes = {
  environment: "production",
  server: {
    port: 3000,
    host: "0.0.0.0"
  },
  logging: {
    level: "info",
    format: "json"
  },
  plugins: {
    cors: {
      enabled: true,
      origin: ["https://example.com"],
      credentials: true
    },
    rateLimit: {
      enabled: true,
      windowMs: 60000,
      max: 100
    }
  }
};

const app = new AzuraClient(config);
```

## Enum Types ÔøΩ

Use enums for fixed values:

```typescript
enum UserRole {
  USER = "user",
  ADMIN = "admin",
  MODERATOR = "moderator"
}

enum PostStatus {
  DRAFT = "draft",
  PUBLISHED = "published",
  ARCHIVED = "archived"
}

interface User {
  id: string;
  name: string;
  role: UserRole;
}

interface Post {
  id: string;
  title: string;
  status: PostStatus;
}

@Get("/users/:role")
getUsersByRole(@Param("role") role: string) {
  // Validate enum
  if (!Object.values(UserRole).includes(role as UserRole)) {
    throw new HttpError(400, "Invalid role");
  }
  
  const users = findUsersByRole(role as UserRole);
  return { users };
}
```

## Utility Types üõ†Ô∏è

Use TypeScript utility types:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
  createdAt: Date;
  updatedAt: Date;
}

// Omit sensitive fields
type PublicUser = Omit<User, "password">;

// Make fields optional
type UpdateUserDto = Partial<Pick<User, "name" | "email">>;

// Make fields required
type RequiredUser = Required<User>;

// Readonly
type ReadonlyUser = Readonly<User>;

@Get("/:id")
getUser(@Param("id") id: string): PublicUser {
  const user: User = findUserById(id);
  
  // Remove password before returning
  const { password, ...publicUser } = user;
  return publicUser;
}
```

## Strict Mode üîí

Enable strict TypeScript checking:

```json title="tsconfig.json"
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

## Type Inference ‚ú®

Let TypeScript infer types automatically:

```typescript
// No need to explicitly type these
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
]; // Type: { id: number; name: string }[]

function getUser(id: number) {
  return users.find(u => u.id === id);
} // Return type: { id: number; name: string } | undefined

const user = getUser(1);  // Type inferred as above
```

## Enum Types üé®

Use enums for fixed values:

```typescript
enum UserRole {
  USER = "user",
  ADMIN = "admin",
  MODERATOR = "moderator"
}

enum PostStatus {
  DRAFT = "draft",
  PUBLISHED = "published",
  ARCHIVED = "archived"
}

interface User {
  id: string;
  name: string;
  role: UserRole;
}

interface Post {
  id: string;
  title: string;
  status: PostStatus;
}

@Get("/users/:role")
getUsersByRole(@Param("role") role: string) {
  // Validate enum
  if (!Object.values(UserRole).includes(role as UserRole)) {
    throw new HttpError(400, "Invalid role");
  }
  
  const users = findUsersByRole(role as UserRole);
  return { users };
}
```

## Typed Decorators üè∑Ô∏è

Create your own typed decorators:

```typescript
// Typed validation decorator
function ValidateBody<T>(schema: z.ZodSchema<T>) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
      const body = args.find((arg) => arg && typeof arg === "object");
      
      try {
        const validData = schema.parse(body);
        // Replace body with validated data
        const index = args.indexOf(body);
        args[index] = validData;
      } catch (error) {
        throw new HttpError(400, "Validation failed");
      }
      
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}

// Use decorator
@Controller("/api/users")
export class UserController {
  @Post()
  @ValidateBody(CreateUserSchema)
  createUser(@Body() data: CreateUserDto) {
    // data is already validated and typed
    return { user: data };
  }
}
```

## Type-Safe Repositories üíæ

Create type-safe repositories:

```typescript
interface Repository<T> {
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
  create(data: Omit<T, "id" | "createdAt" | "updatedAt">): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<void>;
}

class UserRepository implements Repository<User> {
  async findById(id: string): Promise<User | null> {
    return await db.query("SELECT * FROM users WHERE id = $1", [id]);
  }

  async findAll(): Promise<User[]> {
    return await db.query("SELECT * FROM users");
  }

  async create(data: Omit<User, "id" | "createdAt" | "updatedAt">): Promise<User> {
    return await db.query(
      "INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING *",
      [data.name, data.email, data.password]
    );
  }

  async update(id: string, data: Partial<User>): Promise<User> {
    return await db.query(
      "UPDATE users SET name = $1, email = $2 WHERE id = $3 RETURNING *",
      [data.name, data.email, id]
    );
  }

  async delete(id: string): Promise<void> {
    await db.query("DELETE FROM users WHERE id = $1", [id]);
  }
}

@Controller("/api/users")
export class UserController {
  private userRepo = new UserRepository();

  @Get("/:id")
  async getUser(@Param("id") id: string) {
    const user = await this.userRepo.findById(id);
    
    if (!user) {
      throw new NotFoundError("User");
    }
    
    return { user };
  }

  @Post()
  async createUser(@Body() data: CreateUserDto) {
    const user = await this.userRepo.create(data);
    return { user };
  }
}
```

## Best Practices ‚ú®

<Callout type="tip">
  **Always use explicit types**: Avoid `any`, use `unknown` if necessary
</Callout>

<Callout type="tip">
  **Use Zod for runtime validation**: Combine runtime validation with type safety
</Callout>

<Callout type="tip">
  **Create DTOs for input and output**: Separate domain types from API types
</Callout>

<Callout type="tip">
  **Use utility types**: Leverage Partial, Pick, Omit, etc
</Callout>

<Callout type="warn">
  **Validate types at runtime**: TypeScript doesn't protect at runtime
</Callout>

## Next Steps üìñ

<Cards>
  <Card title="Validation" href="validation" description="Validate data with schemas" />
  <Card title="Error Handling" href="error-handling" description="Handle errors type-safe" />
  <Card title="Examples" href="examples" description="See complete examples" />
</Cards>
