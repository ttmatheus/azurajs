---
title: Controllers
description: Aprenda sobre o padr√£o controller no AzuraJS
icon: Target
---

# Controllers üéØ

Controllers s√£o o cora√ß√£o das aplica√ß√µes AzuraJS. Eles fornecem uma maneira limpa e orientada a objetos de organizar seus endpoints de API em classes l√≥gicas e manten√≠veis usando decorators TypeScript. Ao agrupar rotas relacionadas, os controllers tornam seu c√≥digo escal√°vel e f√°cil de navegar.

<Callout type="info" title="Por Que Usar Controllers?">
Controllers seguem o padr√£o MVC (Model-View-Controller), promovendo a separa√ß√£o de responsabilidades. Eles mant√™m sua l√≥gica de roteamento organizada, reduzem a duplica√ß√£o de c√≥digo e tornam a estrutura da API imediatamente clara para qualquer pessoa lendo seu c√≥digo.
</Callout>

## O que √© um Controller? üìö

Um controller √© uma classe TypeScript decorada com `@Controller` que agrupa manipuladores de rota (endpoints) relacionados. Cada m√©todo no controller representa uma rota espec√≠fica e √© decorado com decorators de m√©todos HTTP como `@Get`, `@Post`, `@Put` ou `@Delete`.

**Principais Benef√≠cios:**
- **Organiza√ß√£o**: Agrupa endpoints relacionados logicamente
- **Reutiliza√ß√£o**: Compartilha l√≥gica comum entre m√©todos
- **Seguran√ßa de Tipos**: Suporte completo ao TypeScript com decorators
- **Manutenibilidade**: F√°cil de localizar e modificar recursos espec√≠ficos
- **Testabilidade**: Simples de testar m√©todos individuais

```typescript
import { Controller, Get, Post } from "azurajs/decorators";

@Controller("/api/products")
export class ProductController {
  
  @Get()  // Manipula GET /api/products
  getAllProducts() {
    return { products: [] };
  }

  @Post()  // Manipula POST /api/products
  createProduct() {
    return { message: "Produto criado" };
  }
}
```

<Callout type="tip" title="Dica R√°pida">
Pense nos controllers como organizadores de funcionalidades. Se voc√™ tem usu√°rios, produtos e pedidos, crie classes separadas `UserController`, `ProductController` e `OrderController`.
</Callout>

## Decorator Controller üè∑Ô∏è

O decorator `@Controller` define um caminho base para todas as rotas no controller.

### Uso B√°sico

```typescript
@Controller("/api/users")
export class UserController {
  // Rotas ser√£o prefixadas com /api/users
}
```

### Sem Prefixo

```typescript
@Controller()  // Sem prefixo
export class RootController {
  @Get("/health")  // Rota: /health
  healthCheck() {
    return { status: "ok" };
  }
}
```

### Caminhos Aninhados

```typescript
@Controller("/api/v1/admin")
export class AdminController {
  @Get("/users")  // Rota: /api/v1/admin/users
  getUsers() {
    return { users: [] };
  }
}
```

<Callout type="warn" title="Melhor Pr√°tica de Caminhos">
Sempre use barras `/` no in√≠cio dos caminhos de rota para evitar confus√£o. O framework lidar√° corretamente com a jun√ß√£o de caminhos, mas a consist√™ncia facilita a depura√ß√£o.
</Callout>

## Criando Controllers üõ†Ô∏è

### Passo 1: Criar a Classe Controller

```typescript title="src/controllers/UserController.ts"
import { 
  Controller, 
  Get, 
  Post, 
  Put, 
  Delete,
  Body, 
  Param, 
  Res 
} from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  
  @Get()
  getAllUsers(@Res() res: ResponseServer) {
    res.json({ users: [] });
  }

  @Get("/:id")
  getUser(@Param("id") id: string, @Res() res: ResponseServer) {
    res.json({ id, name: `User ${id}` });
  }

  @Post()
  createUser(@Body() data: any, @Res() res: ResponseServer) {
    res.status(201).json({ id: Date.now(), ...data });
  }

  @Put("/:id")
  updateUser(
    @Param("id") id: string,
    @Body() data: any,
    @Res() res: ResponseServer
  ) {
    res.json({ id, ...data });
  }

  @Delete("/:id")
  deleteUser(@Param("id") id: string, @Res() res: ResponseServer) {
    res.json({ message: "Usu√°rio deletado" });
  }
}
```

### Passo 2: Registrar o Controller

```typescript title="src/index.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();

// Registrar um √∫nico controller
applyDecorators(app, [UserController]);

await app.listen();
```

<Callout type="info" title="Importante">
Controllers devem ser registrados usando `applyDecorators()` antes de chamar `app.listen()`. As rotas n√£o estar√£o dispon√≠veis at√© que os decorators sejam aplicados.
</Callout>

## M√∫ltiplos Controllers üì¶

Registre m√∫ltiplos controllers de uma vez:

```typescript title="src/index.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";
import { ProductController } from "./controllers/ProductController";
import { AuthController } from "./controllers/AuthController";

const app = new AzuraClient();

applyDecorators(app, [
  UserController,
  ProductController,
  AuthController,
]);

await app.listen();
```

## Organiza√ß√£o de Controllers üìÅ

Organize controllers por funcionalidade ou recurso:

```
src/
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ UserController.ts
‚îÇ   ‚îú‚îÄ‚îÄ ProductController.ts
‚îÇ   ‚îú‚îÄ‚îÄ OrderController.ts
‚îÇ   ‚îî‚îÄ‚îÄ AuthController.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ UserService.ts
‚îÇ   ‚îî‚îÄ‚îÄ ProductService.ts
‚îî‚îÄ‚îÄ index.ts
```

Crie uma exporta√ß√£o barrel:

```typescript title="src/controllers/index.ts"
export { UserController } from "./UserController";
export { ProductController } from "./ProductController";
export { OrderController } from "./OrderController";
export { AuthController } from "./AuthController";
```

Depois importe todos de uma vez:

```typescript title="src/index.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import * as controllers from "./controllers";

const app = new AzuraClient();
applyDecorators(app, Object.values(controllers));
await app.listen();
```

## Melhores Pr√°ticas de Controllers ‚ú®

<Callout type="tip" title="Arquitetura Profissional">
Seguir estas melhores pr√°ticas tornar√° seus controllers manten√≠veis, test√°veis e prontos para produ√ß√£o. Esses padr√µes s√£o usados em aplica√ß√µes enterprise em todo o mundo.
</Callout>

### 1. Princ√≠pio da Responsabilidade √önica

Cada controller deve lidar com **apenas um recurso ou funcionalidade**. Isso torna seu c√≥digo previs√≠vel e mais f√°cil de manter.

```typescript
// ‚úÖ Bom: Focado em usu√°rios
@Controller("/api/users")
export class UserController {
  @Get() getAllUsers() {}
  @Post() createUser() {}
  @Get("/:id") getUserById() {}
  @Put("/:id") updateUser() {}
  @Delete("/:id") deleteUser() {}
}

// ‚úÖ Bom: Focado em produtos
@Controller("/api/products")
export class ProductController {
  @Get() getAllProducts() {}
  @Post() createProduct() {}
}

// ‚ùå Ruim: Responsabilidades misturadas
@Controller("/api")
export class ApiController {
  @Get("/users") getUsers() {}
  @Get("/products") getProducts() {}
  @Get("/orders") getOrders() {}
}
```

<Callout type="warn" title="Alerta de C√≥digo Ruim">
Se seu controller tem m√©todos manipulando recursos diferentes (usu√°rios E produtos), divida-o em controllers separados imediatamente.
</Callout>

### 2. Use Services para L√≥gica de Neg√≥cio

Controllers devem ser **enxutos e focados em preocupa√ß√µes HTTP**. Delegue toda l√≥gica de neg√≥cio, acesso a dados e opera√ß√µes complexas para classes de servi√ßo.

**Controllers lidam com:** Requisi√ß√£o/resposta, c√≥digos de status, cabe√ßalhos
**Services lidam com:** L√≥gica de neg√≥cio, valida√ß√£o, opera√ß√µes de banco de dados, APIs externas

```typescript
// services/UserService.ts
export class UserService {
  private users: User[] = [];

  async getAllUsers(): Promise<User[]> {
    // L√≥gica de neg√≥cio: filtragem, ordena√ß√£o, pagina√ß√£o
    return this.users.filter(u => u.isActive);
  }

  async getUserById(id: string): Promise<User | null> {
    const user = this.users.find(u => u.id === id);
    if (!user) return null;
    return user;
  }

  async createUser(data: CreateUserDto): Promise<User> {
    // L√≥gica de neg√≥cio: valida√ß√£o, hashing, etc.
    if (this.users.some(u => u.email === data.email)) {
      throw new Error("Email j√° existe");
    }
    
    const user: User = {
      id: crypto.randomUUID(),
      ...data,
      createdAt: new Date(),
      isActive: true
    };
    
    this.users.push(user);
    return user;
  }

  async deleteUser(id: string): Promise<boolean> {
    const index = this.users.findIndex(u => u.id === id);
    if (index === -1) return false;
    this.users.splice(index, 1);
    return true;
  }
}

// controllers/UserController.ts
import { Controller, Get, Post, Delete, Body, Param, Res } from "azurajs/decorators";
import { UserService } from "../services/UserService";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  private userService = new UserService();

  @Get()
  async getAllUsers(@Res() res: ResponseServer) {
    const users = await this.userService.getAllUsers();
    res.json({ success: true, data: users });
  }

  @Get("/:id")
  async getUserById(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = await this.userService.getUserById(id);
    
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        error: "Usu√°rio n√£o encontrado" 
      });
    }
    
    res.json({ success: true, data: user });
  }

  @Post()
  async createUser(@Body() data: any, @Res() res: ResponseServer) {
    try {
      const user = await this.userService.createUser(data);
      res.status(201).json({ success: true, data: user });
    } catch (error: any) {
      res.status(400).json({ success: false, error: error.message });
    }
  }

  @Delete("/:id")
  async deleteUser(@Param("id") id: string, @Res() res: ResponseServer) {
    const deleted = await this.userService.deleteUser(id);
    
    if (!deleted) {
      return res.status(404).json({ 
        success: false, 
        error: "Usu√°rio n√£o encontrado" 
      });
    }
    
    res.json({ success: true, message: "Usu√°rio deletado" });
  }
}
```

<Callout type="tip" title="Dica Profissional">
Esta separa√ß√£o facilita os testes. Voc√™ pode testar a l√≥gica de neg√≥cio em services independentemente das preocupa√ß√µes HTTP nos controllers.
</Callout>

### 3. Formato de Resposta Consistente

Use uma **estrutura de resposta consistente** em todos os endpoints. Isso torna sua API previs√≠vel e f√°cil de consumir.

```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

@Controller("/api/users")
export class UserController {
  @Get()
  getAll(@Res() res: ResponseServer) {
    res.json({
      success: true,
      data: users
    });
  }

  @Get("/:id")
  getOne(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = users.find(u => u.id === id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: "Usu√°rio n√£o encontrado"
      });
    }
    
    res.json({
      success: true,
      data: user
    });
  }
}
```

<Callout type="info" title="Design de API">
Formatos de resposta consistentes reduzem a complexidade do tratamento de erros no lado do cliente. Desenvolvedores frontend ir√£o agradecer!
</Callout>

### 4. Tratamento de Erros

Use blocos try-catch e respostas de erro consistentes:

```typescript
import { Controller, Post, Body, Res } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  @Post()
  async createUser(@Body() data: any, @Res() res: ResponseServer) {
    try {
      // Validar
      if (!data.email) {
        throw new HttpError(400, "Email √© obrigat√≥rio");
      }
      
      // Criar usu√°rio
      const user = await this.userService.createUser(data);
      
      res.status(201).json({
        success: true,
        data: user
      });
    } catch (error) {
      if (error instanceof HttpError) {
        res.status(error.status).json({
          success: false,
          error: error.message
        });
      } else {
        res.status(500).json({
          success: false,
          error: "Erro interno do servidor"
        });
      }
    }
  }
}
```

### 5. Seguran√ßa de Tipos

Use interfaces TypeScript para tipos de requisi√ß√£o/resposta:

```typescript
interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

@Controller("/api/users")
export class UserController {
  @Post()
  async createUser(
    @Body() data: CreateUserDto, 
    @Res() res: ResponseServer
  ) {
    const user: User = await this.userService.createUser(data);
    res.status(201).json({ user });
  }
}
```

## Padr√µes Comuns üé®

<Callout type="info" title="Padr√µes Prontos para Produ√ß√£o">
Estes padr√µes s√£o testados em aplica√ß√µes do mundo real. Use-os para construir APIs profissionais e manten√≠veis.
</Callout>

### Inje√ß√£o de Construtor

Use inje√ß√£o de construtor para **gerenciamento de depend√™ncias** e melhor testabilidade:

```typescript
import { Controller, Get, Post, Body, Res } from "azurajs/decorators";
import { UserService } from "../services/UserService";
import { Logger } from "../utils/Logger";
import { CacheService } from "../services/CacheService";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  constructor(
    private userService: UserService,
    private logger: Logger,
    private cache: CacheService
  ) {}

  @Get()
  async getAll(@Res() res: ResponseServer) {
    this.logger.info("Buscando todos os usu√°rios");
    
    // Verificar cache primeiro
    const cached = await this.cache.get("users:all");
    if (cached) {
      this.logger.info("Cache hit");
      return res.json({ success: true, data: cached, cached: true });
    }
    
    const users = await this.userService.getAllUsers();
    await this.cache.set("users:all", users, 300); // Cache de 5 min
    
    res.json({ success: true, data: users });
  }
}
```

### M√©todos Auxiliares Compartilhados

Crie **m√©todos auxiliares reutiliz√°veis** para reduzir duplica√ß√£o:

```typescript
@Controller("/api/users")
export class UserController {
  private userService = new UserService();

  // M√©todos auxiliares
  private sendSuccess(res: ResponseServer, data: any, status = 200) {
    res.status(status).json({
      success: true,
      data,
      timestamp: new Date().toISOString()
    });
  }

  private sendError(res: ResponseServer, message: string, status = 400) {
    res.status(status).json({
      success: false,
      error: message,
      timestamp: new Date().toISOString()
    });
  }

  private sendNotFound(res: ResponseServer, resource = "Recurso") {
    res.status(404).json({
      success: false,
      error: `${resource} n√£o encontrado`,
      timestamp: new Date().toISOString()
    });
  }

  // Manipuladores de rota
  @Get()
  async getAll(@Res() res: ResponseServer) {
    const users = await this.userService.getAllUsers();
    this.sendSuccess(res, users);
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = await this.userService.getUserById(id);
    if (!user) return this.sendNotFound(res, "Usu√°rio");
    this.sendSuccess(res, user);
  }

  @Post()
  async create(@Body() data: any, @Res() res: ResponseServer) {
    try {
      const user = await this.userService.createUser(data);
      this.sendSuccess(res, user, 201);
    } catch (error: any) {
      this.sendError(res, error.message, 400);
    }
  }
}
```

### Exemplo Complexo do Mundo Real

Aqui est√° um **controller completo** com valida√ß√£o, services, tratamento de erros e logging:

```typescript
import { 
  Controller, 
  Get, 
  Post, 
  Put, 
  Delete,
  Body, 
  Param, 
  Query,
  Res 
} from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";
import { ProductService } from "../services/ProductService";
import { Logger } from "../utils/Logger";
import { validate } from "../utils/validator";
import { CreateProductDto, UpdateProductDto } from "../types/dto";

@Controller("/api/products")
export class ProductController {
  constructor(
    private productService: ProductService,
    private logger: Logger
  ) {}

  @Get()
  async getAll(
    @Query("page") page: string = "1",
    @Query("limit") limit: string = "10",
    @Query("category") category: string,
    @Res() res: ResponseServer
  ) {
    try {
      this.logger.info(`Buscando produtos - p√°gina: ${page}, limite: ${limit}`);
      
      const pageNum = parseInt(page);
      const limitNum = parseInt(limit);
      
      if (isNaN(pageNum) || isNaN(limitNum)) {
        return res.status(400).json({
          success: false,
          error: "Par√¢metros de pagina√ß√£o inv√°lidos"
        });
      }
      
      const result = await this.productService.getProducts({
        page: pageNum,
        limit: limitNum,
        category
      });
      
      res.json({
        success: true,
        data: result.products,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: result.total,
          pages: Math.ceil(result.total / limitNum)
        }
      });
    } catch (error: any) {
      this.logger.error("Erro ao buscar produtos:", error);
      res.status(500).json({
        success: false,
        error: "Falha ao buscar produtos"
      });
    }
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    try {
      const product = await this.productService.getProductById(id);
      
      if (!product) {
        return res.status(404).json({
          success: false,
          error: "Produto n√£o encontrado"
        });
      }
      
      res.json({ success: true, data: product });
    } catch (error: any) {
      this.logger.error(`Erro ao buscar produto ${id}:`, error);
      res.status(500).json({
        success: false,
        error: "Falha ao buscar produto"
      });
    }
  }

  @Post()
  async create(@Body() data: CreateProductDto, @Res() res: ResponseServer) {
    try {
      // Validar entrada
      const errors = validate(data, CreateProductDto);
      if (errors.length > 0) {
        return res.status(400).json({
          success: false,
          error: "Valida√ß√£o falhou",
          details: errors
        });
      }
      
      this.logger.info("Criando produto", data);
      const product = await this.productService.createProduct(data);
      
      res.status(201).json({
        success: true,
        data: product,
        message: "Produto criado com sucesso"
      });
    } catch (error: any) {
      this.logger.error("Erro ao criar produto:", error);
      
      if (error.code === "DUPLICATE_SKU") {
        return res.status(409).json({
          success: false,
          error: "Produto com este SKU j√° existe"
        });
      }
      
      res.status(500).json({
        success: false,
        error: "Falha ao criar produto"
      });
    }
  }

  @Put("/:id")
  async update(
    @Param("id") id: string,
    @Body() data: UpdateProductDto,
    @Res() res: ResponseServer
  ) {
    try {
      const errors = validate(data, UpdateProductDto);
      if (errors.length > 0) {
        return res.status(400).json({
          success: false,
          error: "Valida√ß√£o falhou",
          details: errors
        });
      }
      
      const product = await this.productService.updateProduct(id, data);
      
      if (!product) {
        return res.status(404).json({
          success: false,
          error: "Produto n√£o encontrado"
        });
      }
      
      res.json({
        success: true,
        data: product,
        message: "Produto atualizado com sucesso"
      });
    } catch (error: any) {
      this.logger.error(`Erro ao atualizar produto ${id}:`, error);
      res.status(500).json({
        success: false,
        error: "Falha ao atualizar produto"
      });
    }
  }

  @Delete("/:id")
  async delete(@Param("id") id: string, @Res() res: ResponseServer) {
    try {
      const deleted = await this.productService.deleteProduct(id);
      
      if (!deleted) {
        return res.status(404).json({
          success: false,
          error: "Produto n√£o encontrado"
        });
      }
      
      res.json({
        success: true,
        message: "Produto deletado com sucesso"
      });
    } catch (error: any) {
      this.logger.error(`Erro ao deletar produto ${id}:`, error);
      
      if (error.code === "PRODUCT_IN_USE") {
        return res.status(409).json({
          success: false,
          error: "N√£o √© poss√≠vel deletar produto: ele √© referenciado em pedidos existentes"
        });
      }
      
      res.status(500).json({
        success: false,
        error: "Falha ao deletar produto"
      });
    }
  }
}
```

<Callout type="tip" title="Dicas de Produ√ß√£o">
- Sempre valide dados de entrada
- Registre opera√ß√µes importantes para depura√ß√£o
- Trate casos de erro espec√≠ficos com c√≥digos de status apropriados
- Inclua mensagens de erro √∫teis para consumidores da API
- Use pagina√ß√£o para endpoints de listagem
</Callout>

### Padr√£o de Controller Base

Crie um **controller base** com funcionalidade comum:

```typescript
// BaseController.ts
import type { ResponseServer } from "azurajs/types";

export abstract class BaseController {
  protected sendSuccess<T>(
    res: ResponseServer, 
    data: T, 
    status = 200,
    message?: string
  ) {
    res.status(status).json({
      success: true,
      data,
      message,
      timestamp: new Date().toISOString()
    });
  }

  protected sendError(
    res: ResponseServer, 
    error: string, 
    status = 400,
    details?: any
  ) {
    res.status(status).json({
      success: false,
      error,
      details,
      timestamp: new Date().toISOString()
    });
  }

  protected sendNotFound(res: ResponseServer, resource = "Recurso") {
    this.sendError(res, `${resource} n√£o encontrado`, 404);
  }

  protected sendValidationError(
    res: ResponseServer, 
    errors: any[]
  ) {
    this.sendError(res, "Valida√ß√£o falhou", 400, errors);
  }
}

// UserController.ts - estendendo base
import { Controller, Get, Param, Res } from "azurajs/decorators";
import { BaseController } from "./BaseController";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController extends BaseController {
  @Get()
  async getAll(@Res() res: ResponseServer) {
    const users = [{ id: 1, name: "Jo√£o" }];
    this.sendSuccess(res, users);
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = null; // Simulando n√£o encontrado
    if (!user) return this.sendNotFound(res, "Usu√°rio");
    this.sendSuccess(res, user);
  }
}
```

## Solu√ß√£o de Problemas üîß

<Callout type="warn" title="Problemas Comuns">
Aqui est√£o solu√ß√µes para os problemas mais comuns que desenvolvedores enfrentam com controllers.
</Callout>

### Problema: Rotas N√£o Funcionam

**Problema:** As rotas do seu controller retornam erros 404.

**Solu√ß√µes:**

```typescript
// ‚ùå Esqueceu de registrar controller
const app = new AzuraClient();
await app.listen(); // Rotas n√£o funcionar√£o!

// ‚úÖ Registrar antes de listen
const app = new AzuraClient();
applyDecorators(app, [UserController]);
await app.listen();
```

### Problema: Par√¢metros S√£o Undefined

**Problema:** `@Param()` ou `@Body()` retorna undefined.

**Solu√ß√µes:**

```typescript
// ‚ùå Nome de par√¢metro errado
@Get("/:userId")
getUser(@Param("id") id: string) {} // undefined!

// ‚úÖ Corresponder par√¢metro da rota
@Get("/:userId")
getUser(@Param("userId") id: string) {}

// ‚ùå Esqueceu decorator @Body
@Post()
createUser(data: any) {} // undefined!

// ‚úÖ Usar decorator @Body
@Post()
createUser(@Body() data: any) {}
```

### Problema: Erros de Decorator TypeScript

**Problema:** "Decorators are not valid here" ou erros similares.

**Solu√ß√£o:** Habilite decorators no `tsconfig.json`:

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

### Problema: Controller Compartilhando Estado

**Problema:** Dados vazando entre requisi√ß√µes.

```typescript
// ‚ùå Estado mut√°vel compartilhado
@Controller("/api/users")
export class UserController {
  private currentUser: User; // PERIGOSO!
  
  @Post("/login")
  login(@Body() data: any) {
    this.currentUser = data; // Ir√° vazar para outras requisi√ß√µes!
  }
}

// ‚úÖ Usar dados com escopo de requisi√ß√£o
@Controller("/api/users")
export class UserController {
  @Post("/login")
  login(@Body() data: any, @Res() res: ResponseServer) {
    const user = data; // Escopo da requisi√ß√£o
    res.json({ user });
  }
}
```

<Callout type="warn" title="Aviso de Memory Leak">
Nunca armazene dados espec√≠ficos de requisi√ß√£o em propriedades de classe do controller. Controllers s√£o singletons compartilhados entre todas as requisi√ß√µes!
</Callout>

## Dicas de Produtividade üí°

### 1. Use Barrel Exports

Simplifique importa√ß√µes de controllers:

```typescript
// controllers/index.ts
export { UserController } from "./UserController";
export { ProductController } from "./ProductController";
export { OrderController } from "./OrderController";

// main.ts
import * as controllers from "./controllers";
applyDecorators(app, Object.values(controllers));
```

### 2. Crie Templates de Controller

Use snippets de c√≥digo para scaffolding r√°pido:

```typescript
// Template: azura-controller
import { Controller, Get, Post, Body, Param, Res } from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/RECURSO")
export class RECURSOController {
  @Get()
  async getAll(@Res() res: ResponseServer) {
    res.json({ success: true, data: [] });
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    res.json({ success: true, data: {} });
  }

  @Post()
  async create(@Body() data: any, @Res() res: ResponseServer) {
    res.status(201).json({ success: true, data: {} });
  }
}
```

### 3. Use Constantes de Caminho

Evite erros de digita√ß√£o com caminhos centralizados:

```typescript
// constants/routes.ts
export const ROUTES = {
  USERS: "/api/users",
  PRODUCTS: "/api/products",
  ORDERS: "/api/orders"
} as const;

// controllers/UserController.ts
import { ROUTES } from "../constants/routes";

@Controller(ROUTES.USERS)
export class UserController {}
```

### 4. Aproveite Tipos TypeScript

```typescript
interface User {
  id: string;
  name: string;
  email: string;
}

interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

@Controller("/api/users")
export class UserController {
  @Get()
  async getAll(@Res() res: ResponseServer): Promise<void> {
    const users: User[] = await this.userService.getAll();
    res.json({ success: true, data: users });
  }

  @Post()
  async create(
    @Body() data: CreateUserDto,
    @Res() res: ResponseServer
  ): Promise<void> {
    const user: User = await this.userService.create(data);
    res.status(201).json({ success: true, data: user });
  }
}
```

<Callout type="tip" title="Experi√™ncia do Desenvolvedor">
Bons tipos = melhor autocomplete, menos bugs e desenvolvimento mais r√°pido.
</Callout>

## Pr√≥ximos Passos üìñ

<Cards>
  <Card title="Routing" href="routing" description="Aprenda sobre padr√µes de rota e par√¢metros" />
  <Card title="Decorators" href="decorators" description="Domine todos os decorators dispon√≠veis" />
  <Card title="Middleware" href="middleware" description="Adicione middleware aos controllers" />
  <Card title="Valida√ß√£o" href="validation" description="Valide dados de requisi√ß√£o" />
</Cards>
