---
title: Validation
description: Type-safe validation system inspired by Zod, but better
icon: CircleCheck
---

# Validation âœ…

AzuraJS provides a powerful **Zod-like validation system** with full TypeScript type inference. It's familiar, intuitive, and production-ready.

## Why Azura Validator? ğŸš€

- âœ¨ **Clean Syntax** - Intuitive and easy to use
- ğŸ¯ **Formatted Errors** - `.format()` returns errors organized by field
- âš¡ **Performance** - Faster validation
- ğŸ”§ **Built-in Transformations** - `.trim()`, `.toLowerCase()`, `.toUpperCase()` included
- ğŸ“ **Perfect TypeScript** - Automatic type inference
- ğŸ› ï¸ **Flexible** - Easy to extend with custom validations

## Quick Start ğŸƒ

```typescript
import { v, type Infer } from 'azurajs/validators';

// Define schema
const userSchema = v.object({
  name: v.string().min(3),
  email: v.string().email(),
  age: v.number().int().positive()
});

// Validate data
const user = userSchema.parse(req.body);

// Or safe validation
const result = userSchema.safeParse(req.body);
if (result.success) {
  console.log(result.data);
} else {
  console.log(result.error.format());
}
```

## Available Types ğŸ“š

### String

```typescript
v.string()
  .min(3)                    // Minimum 3 characters
  .max(50)                   // Maximum 50 characters
  .length(10)                // Exactly 10 characters
  .email()                   // Validate email
  .url()                     // Validate URL
  .uuid()                    // Validate UUID
  .regex(/^[A-Z]/)          // Custom pattern
  .trim()                    // Remove whitespace
  .toLowerCase()             // Convert to lowercase
  .toUpperCase()             // Convert to uppercase
  .startsWith('prefix')      // Must start with
  .endsWith('suffix')        // Must end with
  .includes('substring')     // Must contain
  .optional()                // Optional field
  .nullable()                // Accept null
  .default('value')          // Default value
```

### Number

```typescript
v.number()
  .min(0)                    // Minimum
  .max(100)                  // Maximum
  .int()                     // Must be integer
  .positive()                // Must be positive
  .negative()                // Must be negative
  .multipleOf(5)             // Multiple of N
  .optional()
  .default(0)
```

### Boolean

```typescript
v.boolean()
  .optional()
  .default(false)
```

### Date

```typescript
v.date()
  .min(new Date('2020-01-01'))
  .max(new Date())
  .optional()
```

### Array

```typescript
v.array(v.string())
  .min(1)                    // Minimum items
  .max(10)                   // Maximum items
  .length(5)                 // Exactly N items
  .nonempty()                // Cannot be empty
  .optional()
```

### Object

```typescript
v.object({
  name: v.string(),
  age: v.number()
})
  .strict()                  // No extra fields
  .passthrough()             // Pass extra fields
  .partial()                 // All fields optional
  .pick('name', 'age')       // Select fields
  .omit('password')          // Omit fields
```

### Enum

```typescript
v.enum(['admin', 'user', 'guest'])
v.enum([1, 2, 3, 4, 5])
```

### Literal

```typescript
v.literal('exact-value')
v.literal(42)
v.literal(true)
```

### Union

```typescript
v.union(
  v.string(),
  v.number(),
  v.boolean()
)
```

## Practical Examples ğŸ’¡

### User Validation

```typescript
import { v, ValidationError, type Infer } from 'azurajs/validators';

const userSchema = v.object({
  name: v.string().min(3).max(50),
  email: v.string().email(),
  age: v.number().int().min(18).max(120),
  bio: v.string().max(500).optional(),
  active: v.boolean().default(true)
});

app.post('/users', (req, res) => {
  try {
    const userData = userSchema.parse(req.body);
    const user = await createUser(userData);
    res.json(user);
  } catch (error) {
    if (error instanceof ValidationError) {
      return res.status(400).json({
        error: 'Validation failed',
        issues: error.format()
      });
    }
  }
});
```

### Secure Password

```typescript
const passwordSchema = v.string()
  .min(8)
  .refine(
    (val) => /[A-Z]/.test(val),
    'Must contain uppercase letter'
  )
  .refine(
    (val) => /[a-z]/.test(val),
    'Must contain lowercase letter'
  )
  .refine(
    (val) => /[0-9]/.test(val),
    'Must contain number'
  )
  .refine(
    (val) => /[!@#$%^&*]/.test(val),
    'Must contain special character'
  );

const registerSchema = v.object({
  email: v.string().email(),
  password: passwordSchema,
  confirmPassword: v.string()
}).refine(
  (data) => data.password === data.confirmPassword,
  'Passwords do not match'
);
```

### Nested Objects

```typescript
const addressSchema = v.object({
  street: v.string(),
  city: v.string(),
  state: v.string().length(2),
  zipCode: v.string().regex(/^\d{5}(-\d{4})?$/)
});

const userWithAddressSchema = v.object({
  name: v.string(),
  email: v.string().email(),
  mainAddress: addressSchema,
  shippingAddress: addressSchema.optional()
});
```

### Complex Arrays

```typescript
const productSchema = v.object({
  id: v.string().uuid(),
  name: v.string().min(1),
  price: v.number().positive(),
  tags: v.array(v.string()).max(10)
});

const orderSchema = v.object({
  customerId: v.string().uuid(),
  items: v.array(v.object({
    productId: v.string().uuid(),
    quantity: v.number().int().positive(),
    price: v.number().positive()
  })).min(1),
  total: v.number().positive(),
  status: v.enum(['pending', 'paid', 'shipped', 'delivered'])
});
```

### Union Types (Payment)

```typescript
const paymentSchema = v.union(
  v.object({
    type: v.literal('card'),
    cardNumber: v.string().length(16),
    cvv: v.string().length(3),
    expiryDate: v.string().regex(/^\d{2}\/\d{2}$/)
  }),
  v.object({
    type: v.literal('pix'),
    key: v.string().email()
  }),
  v.object({
    type: v.literal('boleto'),
    document: v.string().length(11)
  })
);

app.post('/payment', (req, res) => {
  const payment = paymentSchema.parse(req.body) as any;
  
  // TypeScript knows the types!
  if (payment.type === 'card') {
    // payment.cardNumber is available
  } else if (payment.type === 'pix') {
    // payment.key is available
  }
  
  res.json(payment);
});
```

### Automatic Transformations

```typescript
const searchSchema = v.object({
  query: v.string().trim().toLowerCase().min(1),
  category: v.string().optional(),
  page: v.number().int().positive().default(1),
  limit: v.number().int().positive().max(100).default(20)
});

app.get('/search', (req, res) => {
  const params = searchSchema.parse(req.query);
  
  // params.query is already trimmed and lowercase!
  console.log(params.query); // "hello world"
  console.log(params.page);  // 1 (default)
  
  res.json(params);
});
```

### Conditional Validation

```typescript
const orderSchema = v.object({
  type: v.enum(['pickup', 'delivery']),
  items: v.array(v.object({
    id: v.string(),
    qty: v.number().int().positive()
  })),
  address: v.object({
    street: v.string(),
    city: v.string()
  }).optional()
}).refine(
  (data) => {
    // If delivery, address is required
    if (data.type === 'delivery') {
      return !!data.address;
    }
    return true;
  },
  'Address is required for delivery'
);
```

## Type Inference ğŸ”§

```typescript
const schema = v.object({
  name: v.string(),
  age: v.number(),
  active: v.boolean().optional()
});

// Infer type automatically
type User = Infer<typeof schema>;
// Result: { name: string; age: number; active?: boolean }

// Use the type
function createUser(data: User) {
  // TypeScript knows all fields!
}
```

## Error Formatting ğŸ“

```typescript
const result = userSchema.safeParse(invalidData);

if (!result.success) {
  console.log(result.error.format());
  
  // Returns:
  // {
  //   "name": ["String must be at least 3 characters"],
  //   "email": ["Invalid email address"],
  //   "age": ["Number must be at least 18"]
  // }
}
```

## Validation Middleware ğŸ› ï¸

```typescript
import { BaseValidator, ValidationError } from 'azurajs/validators';

function validate<T>(schema: BaseValidator<T>) {
  return (req: any, res: any, next: any) => {
    const result = schema.safeParse(req.body);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'Validation failed',
        issues: result.error.format()
      });
    }
    
    (req as any).validated = result.data;
    next();
  };
}

// Usage
app.post('/users', validate(userSchema), (req, res) => {
  const user = (req as any).validated; // Already validated!
  res.json(user);
});
```

## Advanced Patterns ğŸ¯

### Reusable Schemas

```typescript
// Base schemas
const idSchema = v.string().uuid();
const timestampsSchema = v.object({
  createdAt: v.date(),
  updatedAt: v.date()
});

// Reuse
const userSchema = v.object({
  id: idSchema,
  name: v.string(),
  ...timestampsSchema
});
```

### Custom Validators

```typescript
function isValidCPF(cpf: string): boolean {
  // Validation logic
  return true;
}

const cpfSchema = v.string()
  .length(11)
  .refine(isValidCPF, 'Invalid CPF');
```

## Comparison with Zod ğŸ“Š

| Feature | Azura | Zod |
|---------|-------|-----|
| Syntax | `v.string().email()` | `z.string().email()` |
| Transformations | âœ… Built-in | âŒ Need `.transform()` |
| Formatted Errors | âœ… `.format()` | âŒ Manual |
| Performance | âš¡ Faster | ğŸ¢ Slower |
| Bundle Size | ğŸ“¦ Smaller | ğŸ“¦ Larger |
| TypeScript | âœ… Perfect | âœ… Good |

## API Reference ğŸ“–

### Main Factory

```typescript
import { v } from 'azurajs/validators';

v.string()     // String validator
v.number()     // Number validator
v.boolean()    // Boolean validator
v.date()       // Date validator
v.array(type)  // Array validator
v.object({})   // Object validator
v.enum([])     // Enum validator
v.literal(val) // Literal validator
v.union(...)   // Union validator
```

## Best Practices ğŸ’

1. **Use TypeScript inference**: `type User = Infer<typeof userSchema>`
2. **Safe parse for user input**: Use `.safeParse()` instead of `.parse()`
3. **Reuse schemas**: Create reusable validation components
4. **Custom error messages**: Provide clear validation feedback
5. **Transform data**: Use `.trim()`, `.toLowerCase()` for automatic transformations

## Migration from Zod ğŸ”„

```typescript
// Zod
import { z } from 'zod';
const schema = z.object({
  name: z.string().min(3)
});

// Azura (just change z to v!)
import { v } from 'azurajs/validators';
const schema = v.object({
  name: v.string().min(3)
});
```

Almost the same API! ğŸ‰
