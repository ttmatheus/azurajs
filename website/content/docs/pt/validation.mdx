---
title: ValidaÃ§Ã£o
description: Sistema completo de validaÃ§Ã£o com API estilo Zod - DTOs, schemas, regras customizadas e melhores prÃ¡ticas
icon: CircleCheck
---

# ValidaÃ§Ã£o âœ…

AzuraJS fornece um poderoso **sistema de validaÃ§Ã£o inspirado no Zod** com inferÃªncia completa de tipos TypeScript, transformaÃ§Ãµes automÃ¡ticas e tratamento de erros pronto para produÃ§Ã£o.

## Por que o Validador Azura? ğŸš€

- âœ¨ **Sintaxe Limpa e Familiar** - Se vocÃª conhece Zod, jÃ¡ conhece o Validador Azura
- ğŸ¯ **Erros Formatados** - `.format()` retorna erros organizados por campo para fÃ¡cil exibiÃ§Ã£o
- âš¡ **Alta Performance** - Motor de validaÃ§Ã£o otimizado
- ğŸ”§ **TransformaÃ§Ãµes Integradas** - `.trim()`, `.toLowerCase()`, `.toUpperCase()` incluÃ­dos
- ğŸ“ **TypeScript Perfeito** - InferÃªncia automÃ¡tica de tipos com `Infer<T>`
- ğŸ› ï¸ **ExtensÃ­vel** - ValidaÃ§Ãµes customizadas fÃ¡ceis com `.refine()`
- ğŸ’ª **Pronto para ProduÃ§Ã£o** - Testado em batalha em aplicaÃ§Ãµes reais

## InÃ­cio RÃ¡pido ğŸƒ

```typescript
import { v, type Infer } from 'azurajs/validators';

// 1. Defina seu schema
const userSchema = v.object({
  name: v.string().min(3).max(50),
  email: v.string().email(),
  age: v.number().int().positive().min(18)
});

// 2. Valide dados (lanÃ§a erro em caso de falha)
const user = userSchema.parse(req.body);

// 3. Ou use validaÃ§Ã£o segura (retorna resultado)
const result = userSchema.safeParse(req.body);
if (result.success) {
  console.log("VÃ¡lido:", result.data);
} else {
  console.log("Erros:", result.error.format());
}

// 4. InferÃªncia de tipos TypeScript
type User = Infer<typeof userSchema>;
// Resultado: { name: string; email: string; age: number }
```

## EstratÃ©gias de ValidaÃ§Ã£o ğŸ¯

### 1. PadrÃ£o DTO (Data Transfer Object)

Crie schemas de validaÃ§Ã£o reutilizÃ¡veis:

```typescript
// user.dto.ts
import { v, type Infer } from 'azurajs/validators';

export const CreateUserDTO = v.object({
  name: v.string().min(3).max(50),
  email: v.string().email(),
  password: v.string().min(8),
  age: v.number().int().min(18).max(120).optional(),
  role: v.enum(['user', 'admin', 'moderator']).default('user')
});

export const UpdateUserDTO = CreateUserDTO.partial();

export const LoginDTO = v.object({
  email: v.string().email(),
  password: v.string()
});

export type CreateUser = Infer<typeof CreateUserDTO>;
export type UpdateUser = Infer<typeof UpdateUserDTO>;
export type Login = Infer<typeof LoginDTO>;
```

### 2. Abordagem Schema-First

Defina schemas antes de implementar rotas:

```typescript
// schemas/product.schema.ts
export const productSchemas = {
  create: v.object({
    name: v.string().min(1).max(200),
    description: v.string().max(1000).optional(),
    price: v.number().positive(),
    stock: v.number().int().min(0),
    category: v.enum(['electronics', 'clothing', 'food', 'other']),
    tags: v.array(v.string()).max(10).default([])
  }),
  
  update: v.object({
    name: v.string().min(1).max(200).optional(),
    description: v.string().max(1000).optional(),
    price: v.number().positive().optional(),
    stock: v.number().int().min(0).optional(),
    category: v.enum(['electronics', 'clothing', 'food', 'other']).optional()
  }),
  
  query: v.object({
    category: v.string().optional(),
    minPrice: v.number().positive().optional(),
    maxPrice: v.number().positive().optional(),
    search: v.string().trim().optional(),
    page: v.number().int().positive().default(1),
    limit: v.number().int().positive().max(100).default(20)
  })
};
```

### 3. ValidaÃ§Ã£o Manual

Para casos simples, valide inline:

```typescript
app.post('/users', (req, res) => {
  const schema = v.object({
    username: v.string().min(3),
    email: v.string().email()
  });
  
  const result = schema.safeParse(req.body);
  if (!result.success) {
    return res.status(400).json({ errors: result.error.format() });
  }
  
  const user = createUser(result.data);
  res.json(user);
});
```

## Exemplos Completos de ValidaÃ§Ã£o ğŸ’¡

### Registro de UsuÃ¡rio com Regras Complexas

```typescript
import { v, ValidationError, type Infer } from 'azurajs/validators';

// ValidaÃ§Ã£o de senha com mÃºltiplas regras
const passwordSchema = v.string()
  .min(8, 'Senha deve ter pelo menos 8 caracteres')
  .refine(
    (val) => /[A-Z]/.test(val),
    'Senha deve conter pelo menos uma letra maiÃºscula'
  )
  .refine(
    (val) => /[a-z]/.test(val),
    'Senha deve conter pelo menos uma letra minÃºscula'
  )
  .refine(
    (val) => /[0-9]/.test(val),
    'Senha deve conter pelo menos um nÃºmero'
  )
  .refine(
    (val) => /[!@#$%^&*(),.?":{}|<>]/.test(val),
    'Senha deve conter pelo menos um caractere especial'
  );

// Schema de registro
const registerSchema = v.object({
  username: v.string()
    .min(3, 'Nome de usuÃ¡rio deve ter pelo menos 3 caracteres')
    .max(20, 'Nome de usuÃ¡rio deve ter no mÃ¡ximo 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Nome de usuÃ¡rio pode conter apenas letras, nÃºmeros e underscores'),
  email: v.string().email('EndereÃ§o de email invÃ¡lido'),
  password: passwordSchema,
  confirmPassword: v.string(),
  terms: v.boolean().refine(val => val === true, 'VocÃª deve aceitar os termos e condiÃ§Ãµes')
}).refine(
  (data) => data.password === data.confirmPassword,
  {
    message: 'As senhas nÃ£o coincidem',
    path: ['confirmPassword'] // Erro serÃ¡ anexado ao campo confirmPassword
  }
);

// Uso na rota
app.post('/auth/register', (req, res) => {
  try {
    const userData = registerSchema.parse(req.body);
    
    // Senha e confirmPassword coincidem, termos aceitos
    const user = await createUser({
      username: userData.username,
      email: userData.email,
      password: userData.password // FaÃ§a hash antes de salvar!
    });
    
    res.status(201).json({ user, message: 'Registro bem-sucedido' });
  } catch (error) {
    if (error instanceof ValidationError) {
      return res.status(400).json({
        error: 'ValidaÃ§Ã£o falhou',
        issues: error.format()
        // Retorna: { confirmPassword: ['As senhas nÃ£o coincidem'], terms: [...] }
      });
    }
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});
```

### Validando Body, Query e Params

```typescript
// Validar todas as partes da requisiÃ§Ã£o
app.put('/api/users/:id', async (req, res) => {
  // Validar params
  const paramsSchema = v.object({
    id: v.string().uuid('Formato de ID de usuÃ¡rio invÃ¡lido')
  });
  
  // Validar query
  const querySchema = v.object({
    notify: v.boolean().optional(),
    reason: v.string().max(200).optional()
  });
  
  // Validar body
  const bodySchema = v.object({
    name: v.string().min(1).max(100).optional(),
    email: v.string().email().optional(),
    bio: v.string().max(500).optional()
  });
  
  try {
    const params = paramsSchema.parse(req.params);
    const query = querySchema.parse(req.query);
    const body = bodySchema.parse(req.body);
    
    const user = await updateUser(params.id, body, { 
      notify: query.notify,
      reason: query.reason 
    });
    
    res.json({ user });
  } catch (error) {
    if (error instanceof ValidationError) {
      return res.status(400).json({
        error: 'ValidaÃ§Ã£o falhou',
        issues: error.format()
      });
    }
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});
```

## Regras de ValidaÃ§Ã£o Customizadas ğŸ¨

### ValidaÃ§Ã£o Customizada Simples

```typescript
// Validar CPF (documento brasileiro)
function isValidCPF(cpf: string): boolean {
  // Remover nÃ£o-dÃ­gitos
  cpf = cpf.replace(/[^\d]/g, '');
  
  if (cpf.length !== 11) return false;
  if (/^(\d)\1{10}$/.test(cpf)) return false; // Todos os dÃ­gitos iguais
  
  // Algoritmo de validaÃ§Ã£o
  let sum = 0;
  for (let i = 0; i < 9; i++) {
    sum += parseInt(cpf.charAt(i)) * (10 - i);
  }
  let remainder = 11 - (sum % 11);
  let digit1 = remainder >= 10 ? 0 : remainder;
  
  if (digit1 !== parseInt(cpf.charAt(9))) return false;
  
  sum = 0;
  for (let i = 0; i < 10; i++) {
    sum += parseInt(cpf.charAt(i)) * (11 - i);
  }
  remainder = 11 - (sum % 11);
  let digit2 = remainder >= 10 ? 0 : remainder;
  
  return digit2 === parseInt(cpf.charAt(10));
}

const cpfSchema = v.string()
  .refine(isValidCPF, 'Formato de CPF invÃ¡lido');

// Uso
const userSchema = v.object({
  name: v.string(),
  cpf: cpfSchema
});
```

### ValidaÃ§Ã£o Customizada AvanÃ§ada com Contexto

```typescript
// Validar data no futuro
const futureDateSchema = v.date().refine(
  (date) => date > new Date(),
  'Data deve estar no futuro'
);

// Validar tamanho de arquivo
const fileSizeSchema = v.number().refine(
  (size) => size <= 5 * 1024 * 1024, // 5MB
  'Tamanho do arquivo deve ser menor que 5MB'
);

// Validar URL com domÃ­nio especÃ­fico
const domainUrlSchema = v.string().url().refine(
  (url) => {
    try {
      const parsed = new URL(url);
      return ['example.com', 'test.com'].includes(parsed.hostname);
    } catch {
      return false;
    }
  },
  'URL deve ser de domÃ­nios permitidos (example.com, test.com)'
);
```

## Mensagens de Erro Customizadas ğŸ“

### Mensagens em NÃ­vel de Campo

```typescript
const userSchema = v.object({
  name: v.string()
    .min(3, 'Nome muito curto! Deve ter pelo menos 3 caracteres')
    .max(50, 'Uau! Nome muito longo. MÃ¡ximo 50 caracteres'),
  
  email: v.string()
    .email('Por favor, insira um endereÃ§o de email vÃ¡lido'),
  
  age: v.number()
    .int('Idade deve ser um nÃºmero inteiro')
    .min(18, 'VocÃª deve ter pelo menos 18 anos')
    .max(120, 'Por favor, insira uma idade vÃ¡lida')
});
```

### Mensagens de Erro DinÃ¢micas

```typescript
function createMinLengthValidator(min: number, fieldName: string) {
  return v.string().min(min, `${fieldName} deve ter pelo menos ${min} caracteres`);
}

const schema = v.object({
  username: createMinLengthValidator(3, 'Nome de usuÃ¡rio'),
  bio: createMinLengthValidator(10, 'Bio')
});
```

## Grupos de ValidaÃ§Ã£o (Create vs Update) ğŸ”„

### Usando `.partial()` para Updates

```typescript
const createUserSchema = v.object({
  name: v.string().min(3),
  email: v.string().email(),
  password: v.string().min(8),
  role: v.enum(['user', 'admin'])
});

// Todos os campos se tornam opcionais para updates
const updateUserSchema = createUserSchema.partial();

// Ou tornar campos especÃ­ficos opcionais
const updateUserSchemaCustom = createUserSchema.pick('name', 'email').partial();
```

### Schemas Separados para Diferentes OperaÃ§Ãµes

```typescript
const userSchemas = {
  create: v.object({
    name: v.string().min(3),
    email: v.string().email(),
    password: v.string().min(8),
    role: v.enum(['user', 'admin']).default('user')
  }),
  
  update: v.object({
    name: v.string().min(3).optional(),
    email: v.string().email().optional(),
    bio: v.string().max(500).optional()
    // Nota: sem password ou role nos updates
  }),
  
  changePassword: v.object({
    currentPassword: v.string(),
    newPassword: v.string().min(8),
    confirmPassword: v.string()
  }).refine(
    (data) => data.newPassword === data.confirmPassword,
    'As senhas nÃ£o coincidem'
  )
};

// Uso
app.post('/users', validateBody(userSchemas.create), createUserHandler);
app.patch('/users/:id', validateBody(userSchemas.update), updateUserHandler);
app.post('/users/password', validateBody(userSchemas.changePassword), changePasswordHandler);
```

## TransformaÃ§Ã£o e SanitizaÃ§Ã£o ğŸ§¹

### TransformaÃ§Ãµes AutomÃ¡ticas

```typescript
const searchSchema = v.object({
  // Automaticamente trim e lowercase
  query: v.string()
    .trim()
    .toLowerCase()
    .min(1, 'Query de busca nÃ£o pode ser vazia'),
  
  // Transformar para uppercase
  category: v.string()
    .toUpperCase()
    .optional(),
  
  // Coagir para nÃºmero com padrÃ£o
  page: v.number().int().positive().default(1),
  limit: v.number().int().positive().max(100).default(20),
  
  // Parse boolean de string
  includeInactive: v.boolean().default(false)
});

// Input: { query: "  Hello World  ", page: "2" }
// Output: { query: "hello world", page: 2, limit: 20, includeInactive: false }
```

### TransformaÃ§Ãµes Customizadas

```typescript
const phoneSchema = v.string()
  .regex(/^[\d\s\-\(\)]+$/, 'Formato de telefone invÃ¡lido')
  .transform((val) => val.replace(/[\s\-\(\)]/g, '')); // Remover formataÃ§Ã£o

const emailSchema = v.string()
  .email()
  .transform((val) => val.toLowerCase().trim()); // Normalizar email

const userSchema = v.object({
  email: emailSchema,
  phone: phoneSchema
});

// Input: { email: "  User@EXAMPLE.COM  ", phone: "(555) 123-4567" }
// Output: { email: "user@example.com", phone: "5551234567" }
```

## ConsideraÃ§Ãµes de Performance âš¡

### 1. Reutilize Schemas

```typescript
// âŒ Ruim - cria novo schema a cada requisiÃ§Ã£o
app.post('/users', (req, res) => {
  const schema = v.object({ name: v.string() });
  const data = schema.parse(req.body);
});

// âœ… Bom - reutiliza schema
const userSchema = v.object({ name: v.string() });

app.post('/users', (req, res) => {
  const data = userSchema.parse(req.body);
});
```

### 2. Use `.safeParse()` para Falhas Esperadas

```typescript
// âŒ Ruim - usando try/catch para controle de fluxo
app.post('/users', (req, res) => {
  try {
    const data = userSchema.parse(req.body);
  } catch (error) {
    // ExceÃ§Ãµes sÃ£o caras
  }
});

// âœ… Bom - safe parse retorna resultado
app.post('/users', (req, res) => {
  const result = userSchema.safeParse(req.body);
  if (!result.success) {
    return res.status(400).json({ errors: result.error.format() });
  }
});
```

### 3. ValidaÃ§Ã£o Lazy para Objetos Grandes

```typescript
// Valide apenas o que vocÃª precisa
const partialSchema = fullSchema.pick('name', 'email');

// Ou use .passthrough() para permitir campos extras
const flexibleSchema = userSchema.passthrough();
```

## Melhores PrÃ¡ticas ğŸ’

### 1. **InferÃªncia de Tipos ao InvÃ©s de Tipos Manuais**

```typescript
// âŒ Ruim - tipagem manual
interface User {
  name: string;
  email: string;
  age: number;
}
const userSchema = v.object({ /* ... */ });

// âœ… Bom - inferir do schema
const userSchema = v.object({
  name: v.string(),
  email: v.string().email(),
  age: v.number()
});
type User = Infer<typeof userSchema>;
```

### 2. **Centralize a LÃ³gica de ValidaÃ§Ã£o**

```typescript
// validation/index.ts
export const schemas = {
  user: {
    create: CreateUserDTO,
    update: UpdateUserDTO
  },
  product: {
    create: CreateProductDTO,
    update: UpdateProductDTO
  }
};

// controllers/user.controller.ts
import { schemas } from '../validation';

app.post('/users', validateBody(schemas.user.create), handler);
```

### 3. **ForneÃ§a Mensagens de Erro Claras**

```typescript
// âŒ Ruim - mensagens genÃ©ricas
v.string().min(3)

// âœ… Bom - mensagens especÃ­ficas e Ãºteis
v.string().min(3, 'Nome de usuÃ¡rio deve ter pelo menos 3 caracteres')
```

### 4. **Use Enums para Valores Fixos**

```typescript
// âŒ Ruim - string sem restriÃ§Ãµes
status: v.string()

// âœ… Bom - enum com valores vÃ¡lidos
status: v.enum(['pending', 'active', 'suspended', 'deleted'])
```

### 5. **Valide Cedo**

```typescript
// âŒ Ruim - validar apÃ³s processamento
app.post('/users', async (req, res) => {
  const user = await createUser(req.body); // Pode falhar no DB
  const validated = userSchema.parse(user); // Tarde demais!
});

// âœ… Bom - validar primeiro
app.post('/users', async (req, res) => {
  const validated = userSchema.parse(req.body);
  const user = await createUser(validated); // Dados seguros
});
```

## Middleware de ValidaÃ§Ã£o ğŸ› ï¸

Crie middleware de validaÃ§Ã£o reutilizÃ¡vel:

```typescript
import { BaseValidator, ValidationError } from 'azurajs/validators';
import type { RequestHandler } from 'azurajs/types';

export function validateBody<T>(schema: BaseValidator<T>): RequestHandler {
  return (req, res, next) => {
    const result = schema.safeParse(req.body);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'ValidaÃ§Ã£o falhou',
        issues: result.error.format()
      });
    }
    
    // Anexar dados validados Ã  requisiÃ§Ã£o
    (req as any).validated = result.data;
    next();
  };
}

export function validateQuery<T>(schema: BaseValidator<T>): RequestHandler {
  return (req, res, next) => {
    const result = schema.safeParse(req.query);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'ParÃ¢metros de query invÃ¡lidos',
        issues: result.error.format()
      });
    }
    
    (req as any).validatedQuery = result.data;
    next();
  };
}

export function validateParams<T>(schema: BaseValidator<T>): RequestHandler {
  return (req, res, next) => {
    const result = schema.safeParse(req.params);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'ParÃ¢metros de URL invÃ¡lidos',
        issues: result.error.format()
      });
    }
    
    (req as any).validatedParams = result.data;
    next();
  };
}

// Uso
app.post(
  '/users',
  validateBody(CreateUserDTO),
  (req, res) => {
    const userData = (req as any).validated;
    // userData estÃ¡ tipado e validado!
    const user = createUser(userData);
    res.json(user);
  }
);
```

## SoluÃ§Ã£o de Problemas Comuns ğŸ”§

### Problema: InferÃªncia de Tipos NÃ£o Funciona

**SoluÃ§Ã£o**: Certifique-se de usar o helper de tipo `Infer`:

```typescript
import { type Infer } from 'azurajs/validators';

const schema = v.object({ name: v.string() });
type Data = Infer<typeof schema>; // âœ… Correto
```

### Problema: ValidaÃ§Ã£o Muito Restritiva

**SoluÃ§Ã£o**: Use `.passthrough()` ou torne campos opcionais:

```typescript
// Permitir campos extras
const flexibleSchema = userSchema.passthrough();

// Ou tornar campos especÃ­ficos opcionais
const schema = v.object({
  required: v.string(),
  optional: v.string().optional()
});
```

### Problema: Mensagens de Erro NÃ£o Aparecem

**SoluÃ§Ã£o**: Use `.format()` para obter erros estruturados:

```typescript
const result = schema.safeParse(data);
if (!result.success) {
  console.log(result.error.format()); // âœ… Erros estruturados por campo
  // NÃ£o: result.error.errors // âŒ Array de erros brutos
}
```

### Problema: Problemas de Performance

**SoluÃ§Ã£o**: Reutilize schemas e use `.safeParse()`:

```typescript
// âœ… Definir uma vez, reutilizar muitas vezes
const userSchema = v.object({ /* ... */ });

app.post('/users', (req, res) => {
  const result = userSchema.safeParse(req.body);
});
```


## ReferÃªncia Completa da API ğŸ“–

### Tipos Primitivos

```typescript
v.string()    // Validador de string
v.number()    // Validador de nÃºmero  
v.boolean()   // Validador de boolean
v.date()      // Validador de data
v.null()      // Validador de null
v.undefined() // Validador de undefined
v.any()       // Qualquer tipo (bypass de validaÃ§Ã£o)
```

### Tipos Complexos

```typescript
v.array(schema)           // Array do tipo
v.object({ })             // Objeto com formato
v.enum([...])             // Valores enum
v.literal(value)          // Valor exato
v.union(schema1, schema2) // Um de mÃºltiplos tipos
v.tuple([s1, s2])         // Array de tamanho fixo
v.record(schema)          // Objeto com chaves dinÃ¢micas
v.map(keySchema, valSchema) // Tipo Map
```

### MÃ©todos de String

```typescript
.min(n)           // Comprimento mÃ­nimo
.max(n)           // Comprimento mÃ¡ximo
.length(n)        // Comprimento exato
.email()          // Email vÃ¡lido
.url()            // URL vÃ¡lida
.uuid()           // UUID vÃ¡lido
.regex(pattern)   // Coincidir padrÃ£o
.trim()           // Remover espaÃ§os em branco
.toLowerCase()    // Converter para minÃºsculas
.toUpperCase()    // Converter para maiÃºsculas
.startsWith(str)  // Deve comeÃ§ar com
.endsWith(str)    // Deve terminar com
.includes(str)    // Deve conter
```

### MÃ©todos de Number

```typescript
.min(n)          // Valor mÃ­nimo
.max(n)          // Valor mÃ¡ximo
.int()           // Deve ser inteiro
.positive()      // Deve ser > 0
.negative()      // Deve ser < 0
.multipleOf(n)   // Deve ser mÃºltiplo de n
```

### MÃ©todos Comuns (Todos os Tipos)

```typescript
.optional()      // Tornar opcional
.nullable()      // Permitir null
.default(value)  // Valor padrÃ£o
.refine(fn, msg) // ValidaÃ§Ã£o customizada
.transform(fn)   // Transformar valor
```

## Tipos DisponÃ­veis ğŸ“š

### String

```typescript
v.string()
  .min(3)                    // MÃ­nimo 3 caracteres
  .max(50)                   // MÃ¡ximo 50 caracteres
  .length(10)                // Exatamente 10 caracteres
  .email()                   // Validar email
  .url()                     // Validar URL
  .uuid()                    // Validar UUID
  .regex(/^[A-Z]/)          // PadrÃ£o customizado
  .trim()                    // Remover espaÃ§os em branco
  .toLowerCase()             // Converter para minÃºsculas
  .toUpperCase()             // Converter para maiÃºsculas
  .startsWith('prefix')      // Deve comeÃ§ar com
  .endsWith('suffix')        // Deve terminar com
  .includes('substring')     // Deve conter
  .optional()                // Campo opcional
  .nullable()                // Aceitar null
  .default('value')          // Valor padrÃ£o
```

### Number

```typescript
v.number()
  .min(0)                    // MÃ­nimo
  .max(100)                  // MÃ¡ximo
  .int()                     // Deve ser inteiro
  .positive()                // Deve ser positivo
  .negative()                // Deve ser negativo
  .multipleOf(5)             // MÃºltiplo de N
  .optional()
  .default(0)
```

### Boolean

```typescript
v.boolean()
  .optional()
  .default(false)
```

### Date

```typescript
v.date()
  .min(new Date('2020-01-01'))
  .max(new Date())
  .optional()
```

### Array

```typescript
v.array(v.string())
  .min(1)                    // MÃ­nimo de itens
  .max(10)                   // MÃ¡ximo de itens
  .length(5)                 // Exatamente N itens
  .nonempty()                // NÃ£o pode ser vazio
  .optional()
```

### Object

```typescript
v.object({
  name: v.string(),
  age: v.number()
})
  .strict()                  // Sem campos extras
  .passthrough()             // Passar campos extras
  .partial()                 // Todos os campos opcionais
  .pick('name', 'age')       // Selecionar campos
  .omit('password')          // Omitir campos
```

### Enum

```typescript
v.enum(['admin', 'user', 'guest'])
v.enum([1, 2, 3, 4, 5])
```

### Literal

```typescript
v.literal('valor-exato')
v.literal(42)
v.literal(true)
```

### Union

```typescript
v.union(
  v.string(),
  v.number(),
  v.boolean()
)
```

## Exemplos PrÃ¡ticos ğŸ’¡

### ValidaÃ§Ã£o de UsuÃ¡rio

```typescript
import { v, ValidationError, type Infer } from 'azurajs/validators';

const userSchema = v.object({
  name: v.string().min(3).max(50),
  email: v.string().email(),
  age: v.number().int().min(18).max(120),
  bio: v.string().max(500).optional(),
  active: v.boolean().default(true)
});

app.post('/users', (req, res) => {
  try {
    const userData = userSchema.parse(req.body);
    const user = await createUser(userData);
    res.json(user);
  } catch (error) {
    if (error instanceof ValidationError) {
      return res.status(400).json({
        error: 'ValidaÃ§Ã£o falhou',
        issues: error.format()
      });
    }
  }
});
```

### Senha Segura

```typescript
const passwordSchema = v.string()
  .min(8)
  .refine(
    (val) => /[A-Z]/.test(val),
    'Deve conter letra maiÃºscula'
  )
  .refine(
    (val) => /[a-z]/.test(val),
    'Deve conter letra minÃºscula'
  )
  .refine(
    (val) => /[0-9]/.test(val),
    'Deve conter nÃºmero'
  )
  .refine(
    (val) => /[!@#$%^&*]/.test(val),
    'Deve conter caractere especial'
  );

const registerSchema = v.object({
  email: v.string().email(),
  password: passwordSchema,
  confirmPassword: v.string()
}).refine(
  (data) => data.password === data.confirmPassword,
  'As senhas nÃ£o coincidem'
);
```

### Objetos Aninhados

```typescript
const addressSchema = v.object({
  street: v.string(),
  city: v.string(),
  state: v.string().length(2),
  zipCode: v.string().regex(/^\d{5}(-\d{4})?$/)
});

const userWithAddressSchema = v.object({
  name: v.string(),
  email: v.string().email(),
  mainAddress: addressSchema,
  shippingAddress: addressSchema.optional()
});
```

### Arrays Complexos

```typescript
const productSchema = v.object({
  id: v.string().uuid(),
  name: v.string().min(1),
  price: v.number().positive(),
  tags: v.array(v.string()).max(10)
});

const orderSchema = v.object({
  customerId: v.string().uuid(),
  items: v.array(v.object({
    productId: v.string().uuid(),
    quantity: v.number().int().positive(),
    price: v.number().positive()
  })).min(1),
  total: v.number().positive(),
  status: v.enum(['pending', 'paid', 'shipped', 'delivered'])
});
```

### Union Types (Pagamento)

```typescript
const paymentSchema = v.union(
  v.object({
    type: v.literal('card'),
    cardNumber: v.string().length(16),
    cvv: v.string().length(3),
    expiryDate: v.string().regex(/^\d{2}\/\d{2}$/)
  }),
  v.object({
    type: v.literal('pix'),
    key: v.string().email()
  }),
  v.object({
    type: v.literal('boleto'),
    document: v.string().length(11)
  })
);

app.post('/payment', (req, res) => {
  const payment = paymentSchema.parse(req.body) as any;
  
  // TypeScript conhece os tipos!
  if (payment.type === 'card') {
    // payment.cardNumber estÃ¡ disponÃ­vel
  } else if (payment.type === 'pix') {
    // payment.key estÃ¡ disponÃ­vel
  }
  
  res.json(payment);
});
```

### TransformaÃ§Ãµes AutomÃ¡ticas

```typescript
const searchSchema = v.object({
  query: v.string().trim().toLowerCase().min(1),
  category: v.string().optional(),
  page: v.number().int().positive().default(1),
  limit: v.number().int().positive().max(100).default(20)
});

app.get('/search', (req, res) => {
  const params = searchSchema.parse(req.query);
  
  // params.query jÃ¡ estÃ¡ trimado e em minÃºsculas!
  console.log(params.query); // "hello world"
  console.log(params.page);  // 1 (padrÃ£o)
  
  res.json(params);
});
```

### ValidaÃ§Ã£o Condicional

```typescript
const orderSchema = v.object({
  type: v.enum(['pickup', 'delivery']),
  items: v.array(v.object({
    id: v.string(),
    qty: v.number().int().positive()
  })),
  address: v.object({
    street: v.string(),
    city: v.string()
  }).optional()
}).refine(
  (data) => {
    // Se delivery, endereÃ§o Ã© obrigatÃ³rio
    if (data.type === 'delivery') {
      return !!data.address;
    }
    return true;
  },
  'EndereÃ§o Ã© obrigatÃ³rio para entrega'
);
```

## InferÃªncia de Tipos ğŸ”§

```typescript
const schema = v.object({
  name: v.string(),
  age: v.number(),
  active: v.boolean().optional()
});

// Inferir tipo automaticamente
type User = Infer<typeof schema>;
// Resultado: { name: string; age: number; active?: boolean }

// Usar o tipo
function createUser(data: User) {
  // TypeScript conhece todos os campos!
}
```

## FormataÃ§Ã£o de Erros ğŸ“

```typescript
const result = userSchema.safeParse(invalidData);

if (!result.success) {
  console.log(result.error.format());
  
  // Retorna:
  // {
  //   "name": ["String deve ter pelo menos 3 caracteres"],
  //   "email": ["EndereÃ§o de email invÃ¡lido"],
  //   "age": ["NÃºmero deve ser pelo menos 18"]
  // }
}
```

## PadrÃµes AvanÃ§ados ğŸ¯

### Schemas ReutilizÃ¡veis

```typescript
// Schemas base
const idSchema = v.string().uuid();
const timestampsSchema = v.object({
  createdAt: v.date(),
  updatedAt: v.date()
});

// Reutilizar
const userSchema = v.object({
  id: idSchema,
  name: v.string(),
  ...timestampsSchema
});
```

### Validadores Customizados

```typescript
function isValidCPF(cpf: string): boolean {
  // LÃ³gica de validaÃ§Ã£o
  return true;
}

const cpfSchema = v.string()
  .length(11)
  .refine(isValidCPF, 'CPF invÃ¡lido');
```

## ComparaÃ§Ã£o com Zod ğŸ“Š

| Recurso | Azura | Zod |
|---------|-------|-----|
| Sintaxe | `v.string().email()` | `z.string().email()` |
| TransformaÃ§Ãµes | âœ… Integradas | âŒ Precisa de `.transform()` |
| Erros Formatados | âœ… `.format()` | âŒ Manual |
| Performance | âš¡ Mais rÃ¡pido | ğŸ¢ Mais lento |
| Tamanho do Bundle | ğŸ“¦ Menor | ğŸ“¦ Maior |
| TypeScript | âœ… Perfeito | âœ… Bom |

## ReferÃªncia da API ğŸ“–

### Factory Principal

```typescript
import { v } from 'azurajs/validators';

v.string()     // Validador de string
v.number()     // Validador de nÃºmero
v.boolean()    // Validador de boolean
v.date()       // Validador de data
v.array(type)  // Validador de array
v.object({})   // Validador de objeto
v.enum([])     // Validador de enum
v.literal(val) // Validador de literal
v.union(...)   // Validador de union
```

## Lista de Melhores PrÃ¡ticas ğŸ’

1. **Use inferÃªncia TypeScript**: `type User = Infer<typeof userSchema>`
2. **Safe parse para input de usuÃ¡rio**: Use `.safeParse()` ao invÃ©s de `.parse()`
3. **Reutilize schemas**: Crie componentes de validaÃ§Ã£o reutilizÃ¡veis
4. **Mensagens de erro customizadas**: ForneÃ§a feedback claro de validaÃ§Ã£o
5. **Transforme dados**: Use `.trim()`, `.toLowerCase()` para transformaÃ§Ãµes automÃ¡ticas

## MigraÃ§Ã£o do Zod ğŸ”„

```typescript
// Zod
import { z } from 'zod';
const schema = z.object({
  name: z.string().min(3)
});

// Azura (sÃ³ mude z para v!)
import { v } from 'azurajs/validators';
const schema = v.object({
  name: v.string().min(3)
});
```

Quase a mesma API! ğŸ‰

## PrÃ³ximos Passos ğŸ“–

- [**Middleware**](middleware) - Use validaÃ§Ã£o em middleware
- [**Tratamento de Erros**](error-handling) - Trate erros de validaÃ§Ã£o
- [**Suporte TypeScript**](typescript-support) - PadrÃµes avanÃ§ados de TypeScript

---

**Dica Pro**: Sempre valide entrada de usuÃ¡rio na fronteira da sua aplicaÃ§Ã£o. NÃ£o confie em nada do cliente!
