---
title: Controllers
description: Learn about the controller pattern in AzuraJS
icon: Target
---

# Controllers üéØ

Controllers are the heart of AzuraJS applications. They provide a clean, object-oriented way to organize your API endpoints into logical, maintainable classes using TypeScript decorators. By grouping related routes together, controllers make your codebase scalable and easy to navigate.

<Callout type="info" title="Why Use Controllers?">
Controllers follow the MVC (Model-View-Controller) pattern, promoting separation of concerns. They keep your routing logic organized, reduce code duplication, and make your API structure immediately clear to anyone reading your code.
</Callout>

## What is a Controller? üìö

A controller is a TypeScript class decorated with `@Controller` that groups related route handlers (endpoints) together. Each method in the controller represents a specific route and is decorated with HTTP method decorators like `@Get`, `@Post`, `@Put`, or `@Delete`.

**Key Benefits:**
- **Organization**: Group related endpoints logically
- **Reusability**: Share common logic across methods
- **Type Safety**: Full TypeScript support with decorators
- **Maintainability**: Easy to locate and modify specific features
- **Testability**: Simple to unit test individual methods

```typescript
import { Controller, Get, Post } from "azurajs/decorators";

@Controller("/api/products")
export class ProductController {
  
  @Get()  // Handles GET /api/products
  getAllProducts() {
    return { products: [] };
  }

  @Post()  // Handles POST /api/products
  createProduct() {
    return { message: "Product created" };
  }
}
```

<Callout type="tip" title="Quick Tip">
Think of controllers as feature organizers. If you have users, products, and orders, create separate `UserController`, `ProductController`, and `OrderController` classes.
</Callout>

## Controller Decorator üè∑Ô∏è

The `@Controller` decorator defines a base path for all routes in the controller.

### Basic Usage

```typescript
@Controller("/api/users")
export class UserController {
  // Routes will be prefixed with /api/users
}
```

### Without Prefix

```typescript
@Controller()  // No prefix
export class RootController {
  @Get("/health")  // Route: /health
  healthCheck() {
    return { status: "ok" };
  }
}
```

### Nested Paths

```typescript
@Controller("/api/v1/admin")
export class AdminController {
  @Get("/users")  // Route: /api/v1/admin/users
  getUsers() {
    return { users: [] };
  }
}
```

<Callout type="warn" title="Path Best Practice">
Always use leading slashes `/` in route paths to avoid confusion. The framework will handle path joining correctly, but consistency makes debugging easier.
</Callout>

## Creating Controllers üõ†Ô∏è

### Step 1: Create the Controller Class

```typescript title="src/controllers/UserController.ts"
import { 
  Controller, 
  Get, 
  Post, 
  Put, 
  Delete,
  Body, 
  Param, 
  Res 
} from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  
  @Get()
  getAllUsers(@Res() res: ResponseServer) {
    res.json({ users: [] });
  }

  @Get("/:id")
  getUser(@Param("id") id: string, @Res() res: ResponseServer) {
    res.json({ id, name: `User ${id}` });
  }

  @Post()
  createUser(@Body() data: any, @Res() res: ResponseServer) {
    res.status(201).json({ id: Date.now(), ...data });
  }

  @Put("/:id")
  updateUser(
    @Param("id") id: string,
    @Body() data: any,
    @Res() res: ResponseServer
  ) {
    res.json({ id, ...data });
  }

  @Delete("/:id")
  deleteUser(@Param("id") id: string, @Res() res: ResponseServer) {
    res.json({ message: "User deleted" });
  }
}
```

### Step 2: Register the Controller

```typescript title="src/index.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();

// Register single controller
applyDecorators(app, [UserController]);

await app.listen();
```

<Callout type="info" title="Important">
Controllers must be registered using `applyDecorators()` before calling `app.listen()`. Routes are not available until decorators are applied.
</Callout>

## Multiple Controllers üì¶

Register multiple controllers at once:

```typescript title="src/index.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";
import { ProductController } from "./controllers/ProductController";
import { AuthController } from "./controllers/AuthController";

const app = new AzuraClient();

applyDecorators(app, [
  UserController,
  ProductController,
  AuthController,
]);

await app.listen();
```

## Controller Organization üìÅ

Organize controllers by feature or resource:

```
src/
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ UserController.ts
‚îÇ   ‚îú‚îÄ‚îÄ ProductController.ts
‚îÇ   ‚îú‚îÄ‚îÄ OrderController.ts
‚îÇ   ‚îî‚îÄ‚îÄ AuthController.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ UserService.ts
‚îÇ   ‚îî‚îÄ‚îÄ ProductService.ts
‚îî‚îÄ‚îÄ index.ts
```

Create a barrel export:

```typescript title="src/controllers/index.ts"
export { UserController } from "./UserController";
export { ProductController } from "./ProductController";
export { OrderController } from "./OrderController";
export { AuthController } from "./AuthController";
```

Then import all at once:

```typescript title="src/index.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import * as controllers from "./controllers";

const app = new AzuraClient();
applyDecorators(app, Object.values(controllers));
await app.listen();
```

## Controller Best Practices ‚ú®

<Callout type="tip" title="Professional Architecture">
Following these best practices will make your controllers maintainable, testable, and production-ready. These patterns are used in enterprise applications worldwide.
</Callout>

### 1. Single Responsibility Principle

Each controller should handle **one resource or feature only**. This makes your code predictable and easier to maintain.

```typescript
// ‚úÖ Good: Focused on users
@Controller("/api/users")
export class UserController {
  @Get() getAllUsers() {}
  @Post() createUser() {}
  @Get("/:id") getUserById() {}
  @Put("/:id") updateUser() {}
  @Delete("/:id") deleteUser() {}
}

// ‚úÖ Good: Focused on products
@Controller("/api/products")
export class ProductController {
  @Get() getAllProducts() {}
  @Post() createProduct() {}
}

// ‚ùå Bad: Mixed responsibilities
@Controller("/api")
export class ApiController {
  @Get("/users") getUsers() {}
  @Get("/products") getProducts() {}
  @Get("/orders") getOrders() {}
}
```

<Callout type="warn" title="Code Smell Alert">
If your controller has methods handling different resources (users AND products), split it into separate controllers immediately.
</Callout>

### 2. Use Services for Business Logic

Controllers should be **thin and focused on HTTP concerns**. Delegate all business logic, data access, and complex operations to service classes.

**Controllers handle:** Request/response, status codes, headers
**Services handle:** Business logic, validation, database operations, external APIs

```typescript
// services/UserService.ts
export class UserService {
  private users: User[] = [];

  async getAllUsers(): Promise<User[]> {
    // Business logic: filtering, sorting, pagination
    return this.users.filter(u => u.isActive);
  }

  async getUserById(id: string): Promise<User | null> {
    const user = this.users.find(u => u.id === id);
    if (!user) return null;
    return user;
  }

  async createUser(data: CreateUserDto): Promise<User> {
    // Business logic: validation, hashing, etc.
    if (this.users.some(u => u.email === data.email)) {
      throw new Error("Email already exists");
    }
    
    const user: User = {
      id: crypto.randomUUID(),
      ...data,
      createdAt: new Date(),
      isActive: true
    };
    
    this.users.push(user);
    return user;
  }

  async deleteUser(id: string): Promise<boolean> {
    const index = this.users.findIndex(u => u.id === id);
    if (index === -1) return false;
    this.users.splice(index, 1);
    return true;
  }
}

// controllers/UserController.ts
import { Controller, Get, Post, Delete, Body, Param, Res } from "azurajs/decorators";
import { UserService } from "../services/UserService";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  private userService = new UserService();

  @Get()
  async getAllUsers(@Res() res: ResponseServer) {
    const users = await this.userService.getAllUsers();
    res.json({ success: true, data: users });
  }

  @Get("/:id")
  async getUserById(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = await this.userService.getUserById(id);
    
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        error: "User not found" 
      });
    }
    
    res.json({ success: true, data: user });
  }

  @Post()
  async createUser(@Body() data: any, @Res() res: ResponseServer) {
    try {
      const user = await this.userService.createUser(data);
      res.status(201).json({ success: true, data: user });
    } catch (error: any) {
      res.status(400).json({ success: false, error: error.message });
    }
  }

  @Delete("/:id")
  async deleteUser(@Param("id") id: string, @Res() res: ResponseServer) {
    const deleted = await this.userService.deleteUser(id);
    
    if (!deleted) {
      return res.status(404).json({ 
        success: false, 
        error: "User not found" 
      });
    }
    
    res.json({ success: true, message: "User deleted" });
  }
}
```

<Callout type="tip" title="Pro Tip">
This separation makes testing easier. You can test business logic in services independently from HTTP concerns in controllers.
</Callout>

### 3. Consistent Response Format

Use a **consistent response structure** across all endpoints. This makes your API predictable and easy to consume.

```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

@Controller("/api/users")
export class UserController {
  @Get()
  getAll(@Res() res: ResponseServer) {
    res.json({
      success: true,
      data: users
    });
  }

  @Get("/:id")
  getOne(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = users.find(u => u.id === id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: "User not found"
      });
    }
    
    res.json({
      success: true,
      data: user
    });
  }
}
```

<Callout type="info" title="API Design">
Consistent response formats reduce client-side error handling complexity. Frontend developers will thank you!
</Callout>

### 4. Error Handling

Use try-catch blocks and consistent error responses:

```typescript
import { Controller, Post, Body, Res } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  @Post()
  async createUser(@Body() data: any, @Res() res: ResponseServer) {
    try {
      // Validate
      if (!data.email) {
        throw new HttpError(400, "Email is required");
      }
      
      // Create user
      const user = await this.userService.createUser(data);
      
      res.status(201).json({
        success: true,
        data: user
      });
    } catch (error) {
      if (error instanceof HttpError) {
        res.status(error.status).json({
          success: false,
          error: error.message
        });
      } else {
        res.status(500).json({
          success: false,
          error: "Internal server error"
        });
      }
    }
  }
}
```

### 5. Type Safety

Use TypeScript interfaces for request/response types:

```typescript
interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

@Controller("/api/users")
export class UserController {
  @Post()
  async createUser(
    @Body() data: CreateUserDto, 
    @Res() res: ResponseServer
  ) {
    const user: User = await this.userService.createUser(data);
    res.status(201).json({ user });
  }
}
```

## Common Patterns üé®

<Callout type="info" title="Production-Ready Patterns">
These patterns are battle-tested in real-world applications. Use them to build professional, maintainable APIs.
</Callout>

### Constructor Injection

Use constructor injection for **dependency management** and better testability:

```typescript
import { Controller, Get, Post, Body, Res } from "azurajs/decorators";
import { UserService } from "../services/UserService";
import { Logger } from "../utils/Logger";
import { CacheService } from "../services/CacheService";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController {
  constructor(
    private userService: UserService,
    private logger: Logger,
    private cache: CacheService
  ) {}

  @Get()
  async getAll(@Res() res: ResponseServer) {
    this.logger.info("Fetching all users");
    
    // Check cache first
    const cached = await this.cache.get("users:all");
    if (cached) {
      this.logger.info("Cache hit");
      return res.json({ success: true, data: cached, cached: true });
    }
    
    const users = await this.userService.getAllUsers();
    await this.cache.set("users:all", users, 300); // 5 min cache
    
    res.json({ success: true, data: users });
  }
}
```

### Shared Helper Methods

Create **reusable helper methods** to reduce duplication:

```typescript
@Controller("/api/users")
export class UserController {
  private userService = new UserService();

  // Helper methods
  private sendSuccess(res: ResponseServer, data: any, status = 200) {
    res.status(status).json({
      success: true,
      data,
      timestamp: new Date().toISOString()
    });
  }

  private sendError(res: ResponseServer, message: string, status = 400) {
    res.status(status).json({
      success: false,
      error: message,
      timestamp: new Date().toISOString()
    });
  }

  private sendNotFound(res: ResponseServer, resource = "Resource") {
    res.status(404).json({
      success: false,
      error: `${resource} not found`,
      timestamp: new Date().toISOString()
    });
  }

  // Route handlers
  @Get()
  async getAll(@Res() res: ResponseServer) {
    const users = await this.userService.getAllUsers();
    this.sendSuccess(res, users);
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = await this.userService.getUserById(id);
    if (!user) return this.sendNotFound(res, "User");
    this.sendSuccess(res, user);
  }

  @Post()
  async create(@Body() data: any, @Res() res: ResponseServer) {
    try {
      const user = await this.userService.createUser(data);
      this.sendSuccess(res, user, 201);
    } catch (error: any) {
      this.sendError(res, error.message, 400);
    }
  }
}
```

### Complex Real-World Example

Here's a **complete controller** with validation, services, error handling, and logging:

```typescript
import { 
  Controller, 
  Get, 
  Post, 
  Put, 
  Delete,
  Body, 
  Param, 
  Query,
  Res 
} from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";
import { ProductService } from "../services/ProductService";
import { Logger } from "../utils/Logger";
import { validate } from "../utils/validator";
import { CreateProductDto, UpdateProductDto } from "../types/dto";

@Controller("/api/products")
export class ProductController {
  constructor(
    private productService: ProductService,
    private logger: Logger
  ) {}

  @Get()
  async getAll(
    @Query("page") page: string = "1",
    @Query("limit") limit: string = "10",
    @Query("category") category: string,
    @Res() res: ResponseServer
  ) {
    try {
      this.logger.info(`Fetching products - page: ${page}, limit: ${limit}`);
      
      const pageNum = parseInt(page);
      const limitNum = parseInt(limit);
      
      if (isNaN(pageNum) || isNaN(limitNum)) {
        return res.status(400).json({
          success: false,
          error: "Invalid pagination parameters"
        });
      }
      
      const result = await this.productService.getProducts({
        page: pageNum,
        limit: limitNum,
        category
      });
      
      res.json({
        success: true,
        data: result.products,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: result.total,
          pages: Math.ceil(result.total / limitNum)
        }
      });
    } catch (error: any) {
      this.logger.error("Error fetching products:", error);
      res.status(500).json({
        success: false,
        error: "Failed to fetch products"
      });
    }
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    try {
      const product = await this.productService.getProductById(id);
      
      if (!product) {
        return res.status(404).json({
          success: false,
          error: "Product not found"
        });
      }
      
      res.json({ success: true, data: product });
    } catch (error: any) {
      this.logger.error(`Error fetching product ${id}:`, error);
      res.status(500).json({
        success: false,
        error: "Failed to fetch product"
      });
    }
  }

  @Post()
  async create(@Body() data: CreateProductDto, @Res() res: ResponseServer) {
    try {
      // Validate input
      const errors = validate(data, CreateProductDto);
      if (errors.length > 0) {
        return res.status(400).json({
          success: false,
          error: "Validation failed",
          details: errors
        });
      }
      
      this.logger.info("Creating product", data);
      const product = await this.productService.createProduct(data);
      
      res.status(201).json({
        success: true,
        data: product,
        message: "Product created successfully"
      });
    } catch (error: any) {
      this.logger.error("Error creating product:", error);
      
      if (error.code === "DUPLICATE_SKU") {
        return res.status(409).json({
          success: false,
          error: "Product with this SKU already exists"
        });
      }
      
      res.status(500).json({
        success: false,
        error: "Failed to create product"
      });
    }
  }

  @Put("/:id")
  async update(
    @Param("id") id: string,
    @Body() data: UpdateProductDto,
    @Res() res: ResponseServer
  ) {
    try {
      const errors = validate(data, UpdateProductDto);
      if (errors.length > 0) {
        return res.status(400).json({
          success: false,
          error: "Validation failed",
          details: errors
        });
      }
      
      const product = await this.productService.updateProduct(id, data);
      
      if (!product) {
        return res.status(404).json({
          success: false,
          error: "Product not found"
        });
      }
      
      res.json({
        success: true,
        data: product,
        message: "Product updated successfully"
      });
    } catch (error: any) {
      this.logger.error(`Error updating product ${id}:`, error);
      res.status(500).json({
        success: false,
        error: "Failed to update product"
      });
    }
  }

  @Delete("/:id")
  async delete(@Param("id") id: string, @Res() res: ResponseServer) {
    try {
      const deleted = await this.productService.deleteProduct(id);
      
      if (!deleted) {
        return res.status(404).json({
          success: false,
          error: "Product not found"
        });
      }
      
      res.json({
        success: true,
        message: "Product deleted successfully"
      });
    } catch (error: any) {
      this.logger.error(`Error deleting product ${id}:`, error);
      
      if (error.code === "PRODUCT_IN_USE") {
        return res.status(409).json({
          success: false,
          error: "Cannot delete product: it is referenced in existing orders"
        });
      }
      
      res.status(500).json({
        success: false,
        error: "Failed to delete product"
      });
    }
  }
}
```

<Callout type="tip" title="Production Tips">
- Always validate input data
- Log important operations for debugging
- Handle specific error cases with appropriate status codes
- Include helpful error messages for API consumers
- Use pagination for list endpoints
</Callout>

### Base Controller Pattern

Create a **base controller** with common functionality:

```typescript
// BaseController.ts
import type { ResponseServer } from "azurajs/types";

export abstract class BaseController {
  protected sendSuccess<T>(
    res: ResponseServer, 
    data: T, 
    status = 200,
    message?: string
  ) {
    res.status(status).json({
      success: true,
      data,
      message,
      timestamp: new Date().toISOString()
    });
  }

  protected sendError(
    res: ResponseServer, 
    error: string, 
    status = 400,
    details?: any
  ) {
    res.status(status).json({
      success: false,
      error,
      details,
      timestamp: new Date().toISOString()
    });
  }

  protected sendNotFound(res: ResponseServer, resource = "Resource") {
    this.sendError(res, `${resource} not found`, 404);
  }

  protected sendValidationError(
    res: ResponseServer, 
    errors: any[]
  ) {
    this.sendError(res, "Validation failed", 400, errors);
  }
}

// UserController.ts - extending base
import { Controller, Get, Param, Res } from "azurajs/decorators";
import { BaseController } from "./BaseController";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/users")
export class UserController extends BaseController {
  @Get()
  async getAll(@Res() res: ResponseServer) {
    const users = [{ id: 1, name: "John" }];
    this.sendSuccess(res, users);
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    const user = null; // Simulating not found
    if (!user) return this.sendNotFound(res, "User");
    this.sendSuccess(res, user);
  }
}
```

## Troubleshooting üîß

<Callout type="warn" title="Common Issues">
Here are solutions to the most common problems developers face with controllers.
</Callout>

### Issue: Routes Not Working

**Problem:** Your controller routes return 404 errors.

**Solutions:**

```typescript
// ‚ùå Forgot to register controller
const app = new AzuraClient();
await app.listen(); // Routes won't work!

// ‚úÖ Register before listen
const app = new AzuraClient();
applyDecorators(app, [UserController]);
await app.listen();
```

### Issue: Parameters Are Undefined

**Problem:** `@Param()` or `@Body()` returns undefined.

**Solutions:**

```typescript
// ‚ùå Wrong parameter name
@Get("/:userId")
getUser(@Param("id") id: string) {} // undefined!

// ‚úÖ Match route parameter
@Get("/:userId")
getUser(@Param("userId") id: string) {}

// ‚ùå Forgot @Body decorator
@Post()
createUser(data: any) {} // undefined!

// ‚úÖ Use @Body decorator
@Post()
createUser(@Body() data: any) {}
```

### Issue: TypeScript Decorator Errors

**Problem:** "Decorators are not valid here" or similar errors.

**Solution:** Enable decorators in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

### Issue: Controller Sharing State

**Problem:** Data leaking between requests.

```typescript
// ‚ùå Shared mutable state
@Controller("/api/users")
export class UserController {
  private currentUser: User; // DANGEROUS!
  
  @Post("/login")
  login(@Body() data: any) {
    this.currentUser = data; // Will leak to other requests!
  }
}

// ‚úÖ Use request-scoped data
@Controller("/api/users")
export class UserController {
  @Post("/login")
  login(@Body() data: any, @Res() res: ResponseServer) {
    const user = data; // Request-scoped
    res.json({ user });
  }
}
```

<Callout type="warn" title="Memory Leak Warning">
Never store request-specific data in controller class properties. Controllers are singletons shared across all requests!
</Callout>

## Productivity Tips üí°

### 1. Use Barrel Exports

Simplify controller imports:

```typescript
// controllers/index.ts
export { UserController } from "./UserController";
export { ProductController } from "./ProductController";
export { OrderController } from "./OrderController";

// main.ts
import * as controllers from "./controllers";
applyDecorators(app, Object.values(controllers));
```

### 2. Create Controller Templates

Use code snippets for fast scaffolding:

```typescript
// Template: azura-controller
import { Controller, Get, Post, Body, Param, Res } from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";

@Controller("/api/RESOURCE")
export class RESOURCEController {
  @Get()
  async getAll(@Res() res: ResponseServer) {
    res.json({ success: true, data: [] });
  }

  @Get("/:id")
  async getById(@Param("id") id: string, @Res() res: ResponseServer) {
    res.json({ success: true, data: {} });
  }

  @Post()
  async create(@Body() data: any, @Res() res: ResponseServer) {
    res.status(201).json({ success: true, data: {} });
  }
}
```

### 3. Use Path Constants

Avoid typos with centralized paths:

```typescript
// constants/routes.ts
export const ROUTES = {
  USERS: "/api/users",
  PRODUCTS: "/api/products",
  ORDERS: "/api/orders"
} as const;

// controllers/UserController.ts
import { ROUTES } from "../constants/routes";

@Controller(ROUTES.USERS)
export class UserController {}
```

### 4. Leverage TypeScript Types

```typescript
interface User {
  id: string;
  name: string;
  email: string;
}

interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

@Controller("/api/users")
export class UserController {
  @Get()
  async getAll(@Res() res: ResponseServer): Promise<void> {
    const users: User[] = await this.userService.getAll();
    res.json({ success: true, data: users });
  }

  @Post()
  async create(
    @Body() data: CreateUserDto,
    @Res() res: ResponseServer
  ): Promise<void> {
    const user: User = await this.userService.create(data);
    res.status(201).json({ success: true, data: user });
  }
}
```

<Callout type="tip" title="Developer Experience">
Good types = better autocomplete, fewer bugs, and faster development.
</Callout>

## Next Steps üìñ

<Cards>
  <Card title="Routing" href="routing" description="Learn about route patterns and parameters" />
  <Card title="Decorators" href="decorators" description="Master all available decorators" />
  <Card title="Middleware" href="middleware" description="Add middleware to controllers" />
  <Card title="Validation" href="validation" description="Validate request data" />
</Cards>
