---
title: Error Handling (Tratamento de Erros)
description: Guia completo para tratar erros elegantemente e construir APIs robustas no AzuraJS
icon: TriangleAlert
---

# Error Handling (Tratamento de Erros) üö®

O tratamento robusto de erros √© a base de aplica√ß√µes prontas para produ√ß√£o. AzuraJS fornece ferramentas e padr√µes poderosos para lidar com erros de forma consistente, registr√°-los adequadamente e fornecer feedback significativo aos clientes.

## Filosofia de Tratamento de Erros üéØ

### Por que Tratamento Adequado de Erros √© Importante

1. **Experi√™ncia do Usu√°rio**: Mensagens de erro claras e √∫teis guiam os usu√°rios para corrigir problemas
2. **Seguran√ßa**: Nunca exponha detalhes internos, stack traces ou dados sens√≠veis
3. **Depura√ß√£o**: Logging abrangente ajuda a rastrear problemas em produ√ß√£o
4. **Monitoramento**: Erros estruturados permitem monitoramento efetivo da aplica√ß√£o
5. **Confiabilidade**: Degrada√ß√£o graciosa mant√©m sua aplica√ß√£o funcionando

### Princ√≠pios de Tratamento de Erros

<Callout type="tip">
**Falhe R√°pido, Falhe com Eleg√¢ncia**: Detecte erros cedo, mas trate-os elegantemente para prevenir falhas em cascata.
</Callout>

<Callout type="warn">
**Seguran√ßa em Primeiro Lugar**: Nunca exponha informa√ß√µes sens√≠veis como queries de banco de dados, API keys ou caminhos de arquivos em mensagens de erro enviadas aos clientes.
</Callout>

<Callout type="info">
**Formato Consistente**: Use uma estrutura de resposta de erro padr√£o em toda sua API para facilitar o tratamento no lado do cliente.
</Callout>

## Tipos de Erros em Aplica√ß√µes Web üóÇÔ∏è

### 1. Erros de Cliente (4xx)
Causados por entrada ou requisi√ß√µes inv√°lidas do cliente.

| C√≥digo | Tipo | Descri√ß√£o | Exemplo |
|--------|------|-----------|---------|
| 400 | Bad Request | Sintaxe ou dados inv√°lidos | Campo obrigat√≥rio faltando |
| 401 | Unauthorized | Autentica√ß√£o necess√°ria | Token n√£o fornecido |
| 403 | Forbidden | Autenticado mas sem permiss√£o | Usu√°rio comum acessando admin |
| 404 | Not Found | Recurso n√£o existe | ID de usu√°rio n√£o no banco |
| 409 | Conflict | Requisi√ß√£o conflita com estado atual | Email j√° registrado |
| 422 | Unprocessable Entity | Sintaxe v√°lida mas erros sem√¢nticos | Idade n√£o pode ser negativa |
| 429 | Too Many Requests | Limite de taxa excedido | Mais de 100 req/min |

### 2. Erros de Servidor (5xx)
Causados por problemas no lado do servidor.

| C√≥digo | Tipo | Descri√ß√£o | Exemplo |
|--------|------|-----------|---------|
| 500 | Internal Server Error | Erro inesperado do servidor | Exce√ß√£o n√£o tratada |
| 502 | Bad Gateway | Resposta inv√°lida de upstream | Timeout de API externa |
| 503 | Service Unavailable | Servidor temporariamente fora | Conex√£o com BD perdida |
| 504 | Gateway Timeout | Upstream n√£o respondeu a tempo | Servi√ßo externo lento |

## Classe HttpError üí•

Use `HttpError` para lan√ßar erros HTTP com c√≥digos de status:

### TypeScript

```typescript
import { Get, Param } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";

@Get("/:id")
getUser(@Param("id") id: string) {
  const user = findUserById(id);
  
  if (!user) {
    throw new HttpError(404, "Usu√°rio n√£o encontrado");
  }
  
  return { user };
}
```

### JavaScript

```javascript
const { HttpError } = require("azurajs/http-error");

app.get("/:id", ({ req, res }) => {
  const { id } = req.params;
  const user = findUserById(id);
  
  if (!user) {
    throw new HttpError(404, "Usu√°rio n√£o encontrado");
  }
  
  res.json({ user });
});
```

### C√≥digos de Status Comuns

```typescript
// 400 Bad Request
throw new HttpError(400, "Dados inv√°lidos");

// 401 Unauthorized
throw new HttpError(401, "N√£o autorizado");

// 403 Forbidden
throw new HttpError(403, "Acesso negado");

// 404 Not Found
throw new HttpError(404, "Recurso n√£o encontrado");

// 409 Conflict
throw new HttpError(409, "Usu√°rio j√° existe");

// 422 Unprocessable Entity
throw new HttpError(422, "Valida√ß√£o falhou");

// 500 Internal Server Error
throw new HttpError(500, "Erro interno do servidor");
```

## Middleware de Tratamento de Erros ‚öôÔ∏è

Crie um middleware global para capturar todos os erros:

```typescript
function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  console.error("Error:", error);
  
  // HttpError
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message,
      statusCode: error.statusCode
    });
  }
  
  // Erro de valida√ß√£o (Zod)
  if (error.name === "ZodError") {
    return res.status(400).json({
      error: "Valida√ß√£o falhou",
      details: error.errors
    });
  }
  
  // Erro gen√©rico
  res.status(500).json({
    error: "Erro interno do servidor",
    message: process.env.NODE_ENV === "development" ? error.message : undefined
  });
}

// Registrar por √∫ltimo
app.use(errorHandler);
```

## Try-Catch em Async Handlers üîÑ

Sempre envolva c√≥digo ass√≠ncrono em try-catch:

```typescript
@Get("/posts")
async getPosts(@Res() res: ResponseServer) {
  try {
    const posts = await fetchPostsFromDB();
    res.json({ posts });
  } catch (error) {
    console.error("Error fetching posts:", error);
    throw new HttpError(500, "Erro ao buscar posts");
  }
}
```

## Wrapper de Async Handler üéÅ

Crie um wrapper para evitar repeti√ß√£o de try-catch:

```typescript
function asyncHandler(fn: Function) {
  return async (req: RequestServer, res: ResponseServer, next: () => void) => {
    try {
      await fn(req, res, next);
    } catch (error) {
      next(error);
    }
  };
}

// Usar como middleware
app.get("/users", asyncHandler(async ({ req, res }) => {
  const users = await getUsersFromDB();
  res.json({ users });
}));
```

## Classes de Erro Customizadas üé®

Crie classes de erro espec√≠ficas para seu dom√≠nio:

```typescript
class ValidationError extends HttpError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(422, message);
    this.name = "ValidationError";
  }
}

class AuthenticationError extends HttpError {
  constructor(message = "N√£o autenticado") {
    super(401, message);
    this.name = "AuthenticationError";
  }
}

class AuthorizationError extends HttpError {
  constructor(message = "Acesso negado") {
    super(403, message);
    this.name = "AuthorizationError";
  }
}

class NotFoundError extends HttpError {
  constructor(resource: string) {
    super(404, `${resource} n√£o encontrado`);
    this.name = "NotFoundError";
  }
}

class ConflictError extends HttpError {
  constructor(message: string) {
    super(409, message);
    this.name = "ConflictError";
  }
}

// Usar nos controllers
@Get("/:id")
getUser(@Param("id") id: string) {
  const user = findUserById(id);
  
  if (!user) {
    throw new NotFoundError("Usu√°rio");
  }
  
  return { user };
}

@Post()
createUser(@Body() data: any) {
  const exists = userExists(data.email);
  
  if (exists) {
    throw new ConflictError("Email j√° est√° em uso");
  }
  
  return createUser(data);
}
```

## Tratamento de Erros de Valida√ß√£o ‚úÖ

Integre com Zod para valida√ß√£o type-safe:

```typescript
import { z } from "zod";

const CreateUserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().int().positive()
});

@Post("/users")
createUser(@Body() data: unknown, @Res() res: ResponseServer) {
  try {
    const validData = CreateUserSchema.parse(data);
    const user = saveUser(validData);
    res.status(201).json({ user });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: "Valida√ß√£o falhou",
        details: error.errors.map(e => ({
          field: e.path.join("."),
          message: e.message
        }))
      });
    }
    throw error;
  }
}
```

## Logging de Erros üìù

Log erros para an√°lise posterior:

```typescript
import { Logger } from "azurajs/logger";

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Log detalhes do erro
  Logger.error("Request error", {
    error: error.message,
    stack: error.stack,
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.headers["user-agent"],
    timestamp: new Date().toISOString()
  });
  
  // Responder cliente
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message
    });
  }
  
  res.status(500).json({
    error: "Erro interno do servidor"
  });
}

app.use(errorHandler);
```

## Rastreamento de Erros üîç

Integre com servi√ßos de rastreamento como Sentry:

```typescript
import * as Sentry from "@sentry/node";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0
});

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Enviar para Sentry
  Sentry.captureException(error, {
    extra: {
      method: req.method,
      url: req.url,
      ip: req.ip
    }
  });
  
  // Responder cliente
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message
    });
  }
  
  res.status(500).json({
    error: "Erro interno do servidor"
  });
}

app.use(errorHandler);
```

## Erros em Middleware üîå

Passe erros para o pr√≥ximo middleware usando `next()`:

```typescript
function authMiddleware(
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      throw new AuthenticationError("Token n√£o fornecido");
    }
    
    const decoded = verifyJWT(token);
    req.user = decoded;
    next();
  } catch (error) {
    next(error);  // Passar erro para error handler
  }
}

app.use(authMiddleware);
app.use(errorHandler);
```

## Erros de Banco de Dados üíæ

Trate erros espec√≠ficos de banco de dados:

```typescript
class DatabaseError extends HttpError {
  constructor(message: string, public originalError?: any) {
    super(500, message);
    this.name = "DatabaseError";
  }
}

@Get("/users")
async getUsers(@Res() res: ResponseServer) {
  try {
    const users = await db.query("SELECT * FROM users");
    res.json({ users });
  } catch (error: any) {
    // Erro de conex√£o
    if (error.code === "ECONNREFUSED") {
      throw new DatabaseError("Banco de dados indispon√≠vel", error);
    }
    
    // Erro de sintaxe SQL
    if (error.code === "42P01") {
      throw new DatabaseError("Tabela n√£o existe", error);
    }
    
    // Erro gen√©rico
    throw new DatabaseError("Erro ao consultar banco de dados", error);
  }
}
```

## Formato Consistente de Resposta de Erro üìã

Use um formato padr√£o para todas as respostas de erro:

```typescript
interface ErrorResponse {
  error: {
    message: string;
    code: string;
    statusCode: number;
    details?: any;
    timestamp: string;
    path: string;
  };
}

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  
  const response: ErrorResponse = {
    error: {
      message: error.message || "Erro interno do servidor",
      code: error.name || "INTERNAL_ERROR",
      statusCode,
      timestamp: new Date().toISOString(),
      path: req.url
    }
  };
  
  // Adicionar detalhes em desenvolvimento
  if (process.env.NODE_ENV === "development") {
    response.error.details = {
      stack: error.stack,
      ...error
    };
  }
  
  res.status(statusCode).json(response);
}
```

## Tratamento de Erros de Rede üåê

Trate erros ao fazer requisi√ß√µes externas:

```typescript
@Get("/external-data")
async getExternalData(@Res() res: ResponseServer) {
  try {
    const response = await fetch("https://api.example.com/data");
    
    if (!response.ok) {
      throw new HttpError(
        502,
        `API externa retornou ${response.status}`
      );
    }
    
    const data = await response.json();
    res.json({ data });
  } catch (error: any) {
    if (error.code === "ENOTFOUND") {
      throw new HttpError(503, "Servi√ßo externo indispon√≠vel");
    }
    
    if (error.code === "ETIMEDOUT") {
      throw new HttpError(504, "Timeout ao conectar ao servi√ßo externo");
    }
    
    throw error;
  }
}
```

## Circuit Breaker Pattern üîå

Implemente circuit breaker para falhas em cascata:

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailTime = 0;
  private state: "CLOSED" | "OPEN" | "HALF_OPEN" = "CLOSED";
  
  constructor(
    private threshold = 5,
    private timeout = 60000
  ) {}
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === "OPEN") {
      if (Date.now() - this.lastFailTime > this.timeout) {
        this.state = "HALF_OPEN";
      } else {
        throw new HttpError(503, "Servi√ßo temporariamente indispon√≠vel");
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess() {
    this.failures = 0;
    this.state = "CLOSED";
  }
  
  private onFailure() {
    this.failures++;
    this.lastFailTime = Date.now();
    
    if (this.failures >= this.threshold) {
      this.state = "OPEN";
    }
  }
}

const dbCircuitBreaker = new CircuitBreaker(5, 60000);

@Get("/users")
async getUsers(@Res() res: ResponseServer) {
  try {
    const users = await dbCircuitBreaker.execute(async () => {
      return await db.query("SELECT * FROM users");
    });
    
    res.json({ users });
  } catch (error) {
    if (error instanceof HttpError && error.statusCode === 503) {
      return res.status(503).json({
        error: "Servi√ßo temporariamente indispon√≠vel. Tente novamente em alguns minutos."
      });
    }
    throw error;
  }
}
```

## Formato de Resposta de Erro Pronto para Produ√ß√£o üìã

### Estrutura de Erro Padronizada

```typescript
interface ApiErrorResponse {
  success: false;
  error: {
    code: string;           // C√≥digo de erro leg√≠vel por m√°quina
    message: string;        // Mensagem leg√≠vel por humanos
    statusCode: number;     // C√≥digo de status HTTP
    timestamp: string;      // Timestamp ISO 8601
    path: string;           // Caminho da requisi√ß√£o
    requestId?: string;     // Para rastreamento entre servi√ßos
    details?: any;          // Contexto adicional (apenas dev)
  };
}

interface ApiSuccessResponse<T> {
  success: true;
  data: T;
  metadata?: {
    page?: number;
    limit?: number;
    total?: number;
  };
}

type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;
```

### Implementa√ß√£o

```typescript
function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  const requestId = req.headers["x-request-id"] as string || generateId();
  
  const errorResponse: ApiErrorResponse = {
    success: false,
    error: {
      code: error.name || "INTERNAL_ERROR",
      message: error.message || "Ocorreu um erro inesperado",
      statusCode,
      timestamp: new Date().toISOString(),
      path: req.url,
      requestId
    }
  };
  
  // Adicionar detalhes em desenvolvimento
  if (process.env.NODE_ENV === "development") {
    errorResponse.error.details = {
      stack: error.stack,
      ...error
    };
  }
  
  // Log do erro
  Logger.error("Erro na requisi√ß√£o", {
    ...errorResponse.error,
    ip: req.ip,
    userAgent: req.headers["user-agent"]
  });
  
  res.status(statusCode).json(errorResponse);
}
```

## Estrat√©gias de Recupera√ß√£o de Erros üîÑ

### L√≥gica de Retry com Exponential Backoff

```typescript
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 1000
): Promise<T> {
  let lastError: any;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      // N√£o retentar erros de cliente
      if (error instanceof HttpError && error.statusCode < 500) {
        throw error;
      }
      
      // N√£o retentar na √∫ltima tentativa
      if (attempt === maxRetries - 1) {
        break;
      }
      
      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, delay));
      
      Logger.info(`Retentando requisi√ß√£o (tentativa ${attempt + 2}/${maxRetries})`);
    }
  }
  
  throw lastError;
}

// Uso
@Get("/external-data")
async getExternalData(@Res() res: ResponseServer) {
  try {
    const data = await retryWithBackoff(async () => {
      const response = await fetch("https://api.example.com/data");
      if (!response.ok) throw new Error("Erro na API externa");
      return response.json();
    });
    
    res.json({ data });
  } catch (error) {
    throw new HttpError(503, "Servi√ßo externo indispon√≠vel");
  }
}
```

### Degrada√ß√£o Graciosa

```typescript
@Get("/dashboard")
async getDashboard(@Res() res: ResponseServer) {
  const dashboard: any = {
    status: "ok"
  };
  
  // Tentar buscar estat√≠sticas do usu√°rio
  try {
    dashboard.stats = await getUserStats();
  } catch (error) {
    Logger.warn("Falha ao carregar estat√≠sticas", error);
    dashboard.stats = null;  // Degradar graciosamente
    dashboard.warnings = ["Estat√≠sticas temporariamente indispon√≠veis"];
  }
  
  // Tentar buscar notifica√ß√µes
  try {
    dashboard.notifications = await getNotifications();
  } catch (error) {
    Logger.warn("Falha ao carregar notifica√ß√µes", error);
    dashboard.notifications = [];  // Array vazio como fallback
  }
  
  // Retornar dados parciais ao inv√©s de falha completa
  res.json(dashboard);
}
```

## Integra√ß√£o de Monitoramento de Erros üì°

### Integra√ß√£o com Sentry (N√≠vel de Produ√ß√£o)

```typescript
import * as Sentry from "@sentry/node";
import { ProfilingIntegration } from "@sentry/profiling-node";

// Inicializar Sentry
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  profilesSampleRate: 1.0,
  integrations: [
    new ProfilingIntegration(),
  ],
  beforeSend(event, hint) {
    // N√£o enviar erros 4xx para o Sentry
    const error = hint.originalException;
    if (error instanceof HttpError && error.statusCode < 500) {
      return null;
    }
    return event;
  }
});

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Adicionar contexto ao Sentry
  Sentry.setContext("request", {
    method: req.method,
    url: req.url,
    headers: req.headers,
    ip: req.ip
  });
  
  // Adicionar contexto de usu√°rio se dispon√≠vel
  if ((req as any).user) {
    Sentry.setUser({
      id: (req as any).user.id,
      email: (req as any).user.email
    });
  }
  
  // Capturar exce√ß√£o
  if (!(error instanceof HttpError) || error.statusCode >= 500) {
    Sentry.captureException(error);
  }
  
  // Enviar resposta
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  res.status(statusCode).json({
    error: {
      message: error.message,
      code: error.name,
      statusCode
    }
  });
}
```

### Rastreamento Customizado de Erros

```typescript
interface ErrorLog {
  timestamp: Date;
  error: string;
  stack?: string;
  statusCode: number;
  path: string;
  method: string;
  ip: string;
  userId?: string;
}

class ErrorTracker {
  private errors: ErrorLog[] = [];
  private readonly maxSize = 1000;
  
  track(error: any, req: RequestServer) {
    const log: ErrorLog = {
      timestamp: new Date(),
      error: error.message,
      stack: error.stack,
      statusCode: error instanceof HttpError ? error.statusCode : 500,
      path: req.url,
      method: req.method,
      ip: req.ip || "unknown",
      userId: (req as any).user?.id
    };
    
    this.errors.push(log);
    
    // Manter apenas erros recentes
    if (this.errors.length > this.maxSize) {
      this.errors.shift();
    }
    
    // Alertar sobre erros repetidos
    this.checkForPatterns(log);
  }
  
  private checkForPatterns(log: ErrorLog) {
    const recentErrors = this.errors.filter(e => 
      Date.now() - e.timestamp.getTime() < 60000 // √öltimo minuto
    );
    
    // Alertar se mesmo erro ocorre 10+ vezes em 1 minuto
    const sameErrors = recentErrors.filter(e => 
      e.error === log.error && e.path === log.path
    );
    
    if (sameErrors.length >= 10) {
      Logger.critical("Pico de erros detectado", {
        error: log.error,
        path: log.path,
        count: sameErrors.length
      });
      
      // Enviar alerta para equipe de opera√ß√µes
      this.sendAlert(log, sameErrors.length);
    }
  }
  
  private sendAlert(log: ErrorLog, count: number) {
    // Implementar alertas (Slack, email, PagerDuty, etc.)
  }
  
  getRecentErrors(limit = 100): ErrorLog[] {
    return this.errors.slice(-limit);
  }
}

const errorTracker = new ErrorTracker();

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  errorTracker.track(error, req);
  
  // ... resto do tratamento de erros
}
```

## Exemplo Completo üéØ

```typescript
// errors/CustomErrors.ts
export class ValidationError extends HttpError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(422, message);
    this.name = "ValidationError";
  }
}

export class NotFoundError extends HttpError {
  constructor(resource: string) {
    super(404, `${resource} n√£o encontrado`);
    this.name = "NotFoundError";
  }
}

export class ConflictError extends HttpError {
  constructor(message: string) {
    super(409, message);
    this.name = "ConflictError";
  }
}

// middleware/errorHandler.ts
import { Logger } from "azurajs/logger";
import * as Sentry from "@sentry/node";

export function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Log erro
  Logger.error("Request error", {
    error: error.message,
    stack: error.stack,
    method: req.method,
    url: req.url,
    ip: req.ip
  });
  
  // Enviar para Sentry em produ√ß√£o
  if (process.env.NODE_ENV === "production") {
    Sentry.captureException(error);
  }
  
  // Responder cliente
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  
  const response = {
    error: {
      message: error.message,
      code: error.name,
      statusCode,
      timestamp: new Date().toISOString()
    }
  };
  
  // Detalhes em desenvolvimento
  if (process.env.NODE_ENV === "development") {
    response.error.details = error.stack;
  }
  
  res.status(statusCode).json(response);
}

// controllers/UserController.ts
import { NotFoundError, ConflictError } from "../errors/CustomErrors";

@Controller("/api/users")
export class UserController {
  @Get("/:id")
  async getUser(@Param("id") id: string) {
    const user = await findUserById(id);
    
    if (!user) {
      throw new NotFoundError("Usu√°rio");
    }
    
    return { user };
  }

  @Post()
  async createUser(@Body() data: CreateUserDto) {
    const exists = await userExists(data.email);
    
    if (exists) {
      throw new ConflictError("Email j√° est√° em uso");
    }
    
    try {
      const user = await saveUser(data);
      return { user };
    } catch (error) {
      throw new HttpError(500, "Erro ao criar usu√°rio");
    }
  }
}

// server.ts
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { errorHandler } from "./middleware/errorHandler";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();

// Registrar controllers
applyDecorators(app, [UserController]);

// Error handler (por √∫ltimo!)
app.use(errorHandler);

await app.listen(3000);
```

## Melhores Pr√°ticas ‚ú®

<Callout type="tip">
  **Sempre use try-catch em c√≥digo ass√≠ncrono**: Evite crashes n√£o tratados
</Callout>

<Callout type="tip">
  **Crie classes de erro customizadas**: Facilita identifica√ß√£o e tratamento
</Callout>

<Callout type="tip">
  **Log todos os erros**: Essencial para debugging e monitoramento
</Callout>

<Callout type="warn">
  **Nunca exponha stack traces em produ√ß√£o**: Pode vazar informa√ß√µes sens√≠veis
</Callout>

<Callout type="warn">
  **Registre error handler por √∫ltimo**: Deve capturar erros de todos os middlewares anteriores
</Callout>

## Pr√≥ximos Passos üìñ

<Cards>
  <Card title="Middleware" href="middleware" description="Crie middleware customizado" />
  <Card title="TypeScript" href="typescript-support" description="Type-safe error handling" />
  <Card title="Examples" href="examples" description="Veja exemplos completos" />
</Cards>
