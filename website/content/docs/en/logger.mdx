---
title: Logger
description: Advanced logging system with colors, icons, and timestamps
icon: Terminal
---

# Logger üìù

AzuraJS includes a powerful logging system with support for colors, icons, timestamps, and full customization.

## Quick Start üöÄ

```typescript
import { log } from 'azurajs/logger';

log.info('Server started on port 3000');
log.success('Task completed successfully');
log.warn('Memory usage is high');
log.error('Connection failed');
```

## Log Levels üìä

### Available Levels

```typescript
log.debug('Debugging information');    // üêõ Gray
log.info('Informational message');     // ‚ÑπÔ∏è  Cyan
log.success('Success message');        // ‚úÖ Bright Green
log.warn('Warning message');           // ‚ö†Ô∏è  Yellow
log.error('Error message');            // ‚ùå Red
log.fatal('Fatal error');              // üíÄ Bright Red
log.trace('Trace message');            // üîç Magenta
log.log('General log');                // üìù White
```

## Configuration ‚öôÔ∏è

### Global Configuration

Configure logger globally for all subsequent calls:

```typescript
import { configureLogger } from 'azurajs/logger';

configureLogger({
  showTimestamp: true,
  timestampFormat: 'datetime',
  showIcon: true,
  prefix: 'MyApp',
  uppercase: true,
  bold: true
});

// Now all logs use this configuration
log.info('Server started');  // [MyApp:INFO] ‚ÑπÔ∏è 1/11/2026, 2:30:45 PM Server started
```

### Per-Call Configuration

Override global configuration for specific calls:

```typescript
log.info('Custom message', {
  showTimestamp: false,
  bold: true,
  colors: {
    info: '#00ff00'  // Custom green color
  }
});
```

## Configuration Options üé®

### Complete Configuration

```typescript
interface LoggerConfig {
  // Custom color mapping (hex, rgb, or predefined)
  colors?: Record<string, string>;
  
  // Custom icon mapping
  icons?: Record<string, string>;
  
  // Show timestamps
  showTimestamp?: boolean;
  
  // Show icons
  showIcon?: boolean;
  
  // Timestamp format: 'time', 'datetime', or 'iso'
  timestampFormat?: 'time' | 'datetime' | 'iso';
  
  // Custom prefix (default: 'Azura')
  prefix?: string;
  
  // Display level in uppercase
  uppercase?: boolean;
  
  // Apply bold styling
  bold?: boolean;
  
  // Apply dim/faded styling
  dim?: boolean;
  
  // Background color
  backgroundColor?: string;
}
```

## Custom Colors üé®

### Hex Colors

```typescript
log.info('Message', {
  colors: {
    info: '#ff5733'  // Custom orange
  }
});
```

### RGB Colors

```typescript
log.info('Message', {
  colors: {
    info: 'rgb(255, 87, 51)'
  }
});
```

### Predefined Colors

```typescript
log.info('Message', {
  colors: {
    info: 'brightBlue'  // Use predefined color
  }
});
```

Available colors:
- `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white`, `gray`
- `brightRed`, `brightGreen`, `brightYellow`, `brightBlue`, `brightMagenta`, `brightCyan`, `brightWhite`

## Custom Icons üé≠

```typescript
log.info('Message', {
  icons: {
    info: 'üöÄ'  // Custom rocket icon
  }
});

// Disable icons
log.info('Message', {
  showIcon: false
});
```

## Timestamps ‚è∞

### Time Only (HH:MM:SS)

```typescript
configureLogger({
  showTimestamp: true,
  timestampFormat: 'time'
});

log.info('Message');  // 14:23:45 ‚ÑπÔ∏è [Azura:INFO] Message
```

### Full DateTime

```typescript
configureLogger({
  showTimestamp: true,
  timestampFormat: 'datetime'
});

log.info('Message');  // 1/11/2026, 2:23:45 PM ‚ÑπÔ∏è [Azura:INFO] Message
```

### ISO 8601

```typescript
configureLogger({
  showTimestamp: true,
  timestampFormat: 'iso'
});

log.info('Message');  // 2026-01-11T14:23:45.123Z ‚ÑπÔ∏è [Azura:INFO] Message
```

## Styling Options üíÖ

### Bold Text

```typescript
log.info('Important message', { bold: true });
```

### Dim Text

```typescript
log.trace('Less important', { dim: true });
```

### Background Color

```typescript
log.error('Critical error', {
  backgroundColor: 'bgRed'
});
```

### Combined Styling

```typescript
log.success('Done!', {
  bold: true,
  colors: { success: '#00ff00' },
  backgroundColor: 'bgBlack'
});
```

## Advanced Usage üéØ

### Custom Prefix

```typescript
configureLogger({
  prefix: 'MyAPI'
});

log.info('Request received');  // [MyAPI:INFO] ‚ÑπÔ∏è Request received
```

### Different Prefixes Per Service

```typescript
const dbLogger = (msg: string) => log.info(msg, { prefix: 'Database' });
const apiLogger = (msg: string) => log.info(msg, { prefix: 'API' });

dbLogger('Connection established');  // [Database:INFO] ‚ÑπÔ∏è Connection established
apiLogger('Server started');         // [API:INFO] ‚ÑπÔ∏è Server started
```

### Using Raw Logger Function

```typescript
import { logger } from 'azurajs/logger';

logger('info', 'Custom log', {
  showTimestamp: true,
  colors: { info: '#00ff00' }
});
```

## Color Utilities üñåÔ∏è

Access color functions directly:

```typescript
import { colors } from 'azurajs/logger';

// Convert hex to ANSI
const greenAnsi = colors.hex('#00ff00');
console.log(`${greenAnsi}Green text${colors.reset}`);

// Convert RGB to ANSI
const blueAnsi = colors.rgb(0, 0, 255);
console.log(`${blueAnsi}Blue text${colors.reset}`);

// Use predefined colors
console.log(`${colors.ansi.brightRed}Red text${colors.reset}`);

// Background colors
console.log(`${colors.bg.bgYellow}Yellow background${colors.reset}`);

// Styling
console.log(`${colors.bold}Bold text${colors.reset}`);
console.log(`${colors.dim}Dim text${colors.reset}`);
```

## Practical Examples üí°

### HTTP Request Logging

```typescript
app.use((req, res, next) => {
  log.info(`${req.method} ${req.path}`, {
    showTimestamp: true,
    timestampFormat: 'time'
  });
  next();
});
```

### Error Tracking

```typescript
try {
  await riskyOperation();
  log.success('Operation completed');
} catch (error) {
  log.error(`Operation failed: ${error.message}`, {
    showTimestamp: true,
    bold: true
  });
}
```

### Development vs Production

```typescript
const isDev = process.env.NODE_ENV === 'development';

configureLogger({
  showTimestamp: !isDev,
  showIcon: isDev,
  colors: isDev ? undefined : {
    info: 'white',
    error: 'red'
  }
});
```

### Structured Logging

```typescript
function logRequest(req: any) {
  log.info('Request', {
    prefix: 'API',
    showTimestamp: true
  });
  log.debug(JSON.stringify({
    method: req.method,
    path: req.path,
    ip: req.ip
  }, null, 2));
}
```

## Best Practices üíé

1. **Configure globally once** at application start
2. **Use appropriate log levels** - don't use `error` for warnings
3. **Include timestamps in production** for debugging
4. **Disable colors in CI/CD** environments
5. **Use prefixes** to identify log sources
6. **Keep messages concise** but informative
7. **Disable debug logs** in production

## Migration Guide üîÑ

### From console.log

```typescript
// Before
console.log('Server started');
console.error('Error occurred');

// After
log.info('Server started');
log.error('Error occurred');
```

### From Winston/Pino

```typescript
// Before (Winston)
logger.info('Message', { timestamp: true });

// After (Azura)
log.info('Message', { showTimestamp: true });
```

## API Reference üìñ

### Main Functions

- `log.debug(msg, options?)` - Debug message
- `log.info(msg, options?)` - Informational message
- `log.success(msg, options?)` - Success message
- `log.warn(msg, options?)` - Warning message
- `log.error(msg, options?)` - Error message
- `log.fatal(msg, options?)` - Fatal error message
- `log.trace(msg, options?)` - Trace message
- `log.log(msg, options?)` - General log

### Configuration

- `configureLogger(config)` - Set global configuration
- `logger(level, msg, options?)` - Raw logger function
- `colors.*` - Color utilities

## Structured Logging üìã

Structured logging makes logs machine-readable and easier to query:

```typescript
import { log } from 'azurajs/logger';

// Basic structured log
log.info('User login', {
  userId: '12345',
  email: 'user@example.com',
  ip: '192.168.1.1',
  userAgent: 'Mozilla/5.0...'
});

// HTTP Request logging
function logRequest(req: Request) {
  log.info('HTTP Request', {
    method: req.method,
    path: req.url,
    ip: req.ip,
    userAgent: req.headers['user-agent'],
    timestamp: new Date().toISOString()
  });
}

// Error with context
try {
  await processPayment(orderId);
} catch (error) {
  log.error('Payment processing failed', {
    orderId,
    userId,
    amount,
    error: error.message,
    stack: error.stack
  });
}

// Performance metrics
log.info('Database query completed', {
  query: 'SELECT * FROM users',
  duration: '45ms',
  rowCount: 150,
  cached: false
});
```

### JSON Logging for Production

```typescript
class JSONLogger {
  log(level: string, message: string, context?: Record<string, any>) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message,
      ...context,
      environment: process.env.NODE_ENV,
      service: 'my-api',
      version: '1.0.0'
    };
    
    console.log(JSON.stringify(logEntry));
  }
  
  info(message: string, context?: Record<string, any>) {
    this.log('info', message, context);
  }
  
  error(message: string, error: Error, context?: Record<string, any>) {
    this.log('error', message, {
      ...context,
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      }
    });
  }
}

const logger = new JSONLogger();

// Usage
logger.info('Server started', { port: 3000 });
// Output: {"timestamp":"2026-01-13T10:30:00.000Z","level":"INFO","message":"Server started","port":3000,"environment":"production","service":"my-api","version":"1.0.0"}
```

## Request/Response Logging üîÑ

### Middleware for Request Logging

```typescript
import { log } from 'azurajs/logger';
import { performance } from 'perf_hooks';

function requestLogger(req: RequestServer, res: ResponseServer, next: () => void) {
  const start = performance.now();
  const requestId = crypto.randomUUID();
  
  // Log incoming request
  log.info(`‚Üí ${req.method} ${req.url}`, {
    requestId,
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.headers['user-agent']
  });
  
  // Log response
  res.on('finish', () => {
    const duration = performance.now() - start;
    const statusColor = res.statusCode < 400 ? 'success' : 'error';
    
    log[statusColor](`‚Üê ${req.method} ${req.url} ${res.statusCode}`, {
      requestId,
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration.toFixed(2)}ms`,
      contentLength: res.getHeader('content-length')
    });
  });
  
  next();
}

app.use(requestLogger);
```

### Detailed Request Body Logging (Development)

```typescript
function detailedRequestLogger(req: RequestServer, res: ResponseServer, next: () => void) {
  if (process.env.NODE_ENV === 'development') {
    log.debug('Request Details', {
      method: req.method,
      url: req.url,
      headers: req.headers,
      query: req.query,
      body: req.body,
      cookies: req.cookies
    });
  }
  next();
}
```

## Custom Loggers üé®

### Service-Specific Loggers

```typescript
class ServiceLogger {
  constructor(private serviceName: string) {}
  
  log(level: string, message: string, context?: Record<string, any>) {
    log[level](`[${this.serviceName}] ${message}`, {
      service: this.serviceName,
      ...context
    });
  }
  
  info(message: string, context?: Record<string, any>) {
    this.log('info', message, context);
  }
  
  error(message: string, context?: Record<string, any>) {
    this.log('error', message, context);
  }
}

// Usage
const dbLogger = new ServiceLogger('Database');
const cacheLogger = new ServiceLogger('Cache');
const authLogger = new ServiceLogger('Auth');

dbLogger.info('Connection established', { host: 'localhost', port: 5432 });
cacheLogger.info('Cache hit', { key: 'user:123', ttl: 3600 });
authLogger.error('Login failed', { userId: '123', reason: 'Invalid password' });

// Output:
// [Database] Connection established
// [Cache] Cache hit
// [Auth] Login failed
```

### Logger Factory Pattern

```typescript
class LoggerFactory {
  private static loggers = new Map<string, Logger>();
  
  static getLogger(name: string): Logger {
    if (!this.loggers.has(name)) {
      this.loggers.set(name, new Logger(name));
    }
    return this.loggers.get(name)!;
  }
}

class Logger {
  constructor(private name: string) {}
  
  info(message: string) {
    log.info(`[${this.name}] ${message}`);
  }
  
  error(message: string, error?: Error) {
    log.error(`[${this.name}] ${message}`, {
      error: error?.message,
      stack: error?.stack
    });
  }
}

// Usage
const userLogger = LoggerFactory.getLogger('UserService');
const orderLogger = LoggerFactory.getLogger('OrderService');

userLogger.info('User created');
orderLogger.info('Order placed');
```

## Production Logging Strategies üè≠

### Log Levels by Environment

```typescript
const LOG_LEVELS = {
  development: 'debug',
  staging: 'info',
  production: 'warn'
};

const currentLogLevel = LOG_LEVELS[process.env.NODE_ENV || 'development'];

configureLogger({
  level: currentLogLevel
});
```

### Filtering Sensitive Data

```typescript
const SENSITIVE_FIELDS = ['password', 'token', 'apiKey', 'secret', 'creditCard'];

function sanitizeLog(data: any): any {
  if (typeof data !== 'object' || data === null) {
    return data;
  }
  
  const sanitized = Array.isArray(data) ? [] : {};
  
  for (const [key, value] of Object.entries(data)) {
    if (SENSITIVE_FIELDS.some(field => key.toLowerCase().includes(field.toLowerCase()))) {
      sanitized[key] = '***REDACTED***';
    } else if (typeof value === 'object') {
      sanitized[key] = sanitizeLog(value);
    } else {
      sanitized[key] = value;
    }
  }
  
  return sanitized;
}

// Usage
const userData = {
  username: 'john',
  password: 'secret123',
  email: 'john@example.com',
  apiKey: 'sk_live_xxxxx'
};

log.info('User data', sanitizeLog(userData));
// Output: { username: 'john', password: '***REDACTED***', email: 'john@example.com', apiKey: '***REDACTED***' }
```

### Performance Sampling

Log only a sample of requests in high-traffic environments:

```typescript
function samplingLogger(sampleRate: number = 0.1) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    const shouldLog = Math.random() < sampleRate;
    
    if (shouldLog || res.statusCode >= 400) {  // Always log errors
      log.info(`${req.method} ${req.url} ${res.statusCode}`);
    }
    
    next();
  };
}

// Log 10% of requests, but always log errors
app.use(samplingLogger(0.1));
```

## Log Rotation üîÑ

### File-Based Log Rotation

```bash
npm install rotating-file-stream
```

```typescript
import rfs from 'rotating-file-stream';
import { createWriteStream } from 'fs';
import { join } from 'path';

// Create rotating stream
const accessLogStream = rfs.createStream('access.log', {
  interval: '1d',    // Rotate daily
  maxFiles: 30,      // Keep 30 days
  path: join(__dirname, 'logs'),
  compress: 'gzip'   // Compress old logs
});

const errorLogStream = rfs.createStream('error.log', {
  interval: '1d',
  maxFiles: 90,      // Keep errors longer
  path: join(__dirname, 'logs'),
  compress: 'gzip'
});

// Write logs to files
class FileLogger {
  info(message: string, context?: any) {
    const logEntry = JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'INFO',
      message,
      ...context
    }) + '\n';
    
    accessLogStream.write(logEntry);
  }
  
  error(message: string, error?: Error, context?: any) {
    const logEntry = JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'ERROR',
      message,
      error: {
        message: error?.message,
        stack: error?.stack
      },
      ...context
    }) + '\n';
    
    errorLogStream.write(logEntry);
  }
}

const fileLogger = new FileLogger();
```

### Log Cleanup Strategy

```typescript
import { unlink, readdir, stat } from 'fs/promises';
import { join } from 'path';

async function cleanOldLogs(directory: string, maxAgeDays: number) {
  const files = await readdir(directory);
  const now = Date.now();
  const maxAge = maxAgeDays * 24 * 60 * 60 * 1000;
  
  for (const file of files) {
    const filePath = join(directory, file);
    const stats = await stat(filePath);
    const age = now - stats.mtime.getTime();
    
    if (age > maxAge) {
      await unlink(filePath);
      log.info(`Deleted old log file: ${file}`);
    }
  }
}

// Run daily
setInterval(() => {
  cleanOldLogs('./logs', 30);  // Delete logs older than 30 days
}, 24 * 60 * 60 * 1000);
```

## Integration with Winston/Pino üîå

### Winston Integration

```bash
npm install winston
```

```typescript
import winston from 'winston';

const winstonLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    // Write all logs to console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    // Write all logs to file
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    })
  ]
});

// Wrap Winston with AzuraJS logger interface
class WinstonWrapper {
  info(message: string, context?: any) {
    winstonLogger.info(message, context);
  }
  
  error(message: string, error?: Error) {
    winstonLogger.error(message, { error: error?.message, stack: error?.stack });
  }
  
  warn(message: string) {
    winstonLogger.warn(message);
  }
  
  debug(message: string) {
    winstonLogger.debug(message);
  }
}

export const logger = new WinstonWrapper();
```

### Pino Integration

```bash
npm install pino pino-pretty
```

```typescript
import pino from 'pino';

const pinoLogger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV !== 'production' ? {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'SYS:standard',
      ignore: 'pid,hostname'
    }
  } : undefined,
  formatters: {
    level: (label) => {
      return { level: label.toUpperCase() };
    }
  }
});

// Usage
pinoLogger.info('Server started');
pinoLogger.error({ err: error }, 'Request failed');
pinoLogger.debug({ userId: '123' }, 'User authenticated');
```

## Monitoring & Alerts üîî

### Error Aggregation

```typescript
class ErrorAggregator {
  private errors = new Map<string, {count: number, lastSeen: Date, samples: Error[]}>();
  
  track(error: Error) {
    const key = `${error.name}:${error.message}`;
    const existing = this.errors.get(key);
    
    if (existing) {
      existing.count++;
      existing.lastSeen = new Date();
      if (existing.samples.length < 5) {
        existing.samples.push(error);
      }
    } else {
      this.errors.set(key, {
        count: 1,
        lastSeen: new Date(),
        samples: [error]
      });
    }
    
    // Alert if error occurs too frequently
    if (existing && existing.count > 10) {
      this.sendAlert(key, existing);
    }
  }
  
  private sendAlert(errorKey: string, data: any) {
    log.fatal(`üö® High error rate detected: ${errorKey}`, {
      count: data.count,
      lastSeen: data.lastSeen,
      sample: data.samples[0].stack
    });
    
    // Send to monitoring service (e.g., Sentry, DataDog)
  }
  
  getReport() {
    return Array.from(this.errors.entries()).map(([key, data]) => ({
      error: key,
      count: data.count,
      lastSeen: data.lastSeen
    }));
  }
}

const errorAggregator = new ErrorAggregator();

// Usage in error handler
app.use((error: Error, req, res, next) => {
  errorAggregator.track(error);
  log.error(error.message, { stack: error.stack });
  res.status(500).json({ error: 'Internal server error' });
});
```

### Metrics Logging

```typescript
class MetricsLogger {
  private metrics = {
    requests: 0,
    errors: 0,
    avgResponseTime: 0,
    responseTimes: [] as number[]
  };
  
  logRequest(duration: number, statusCode: number) {
    this.metrics.requests++;
    this.metrics.responseTimes.push(duration);
    
    if (statusCode >= 400) {
      this.metrics.errors++;
    }
    
    // Calculate average
    this.metrics.avgResponseTime = 
      this.metrics.responseTimes.reduce((a, b) => a + b, 0) / 
      this.metrics.responseTimes.length;
    
    // Keep only last 1000 entries
    if (this.metrics.responseTimes.length > 1000) {
      this.metrics.responseTimes.shift();
    }
  }
  
  logMetrics() {
    log.info('Performance Metrics', {
      totalRequests: this.metrics.requests,
      errors: this.metrics.errors,
      errorRate: `${(this.metrics.errors / this.metrics.requests * 100).toFixed(2)}%`,
      avgResponseTime: `${this.metrics.avgResponseTime.toFixed(2)}ms`,
      p95ResponseTime: this.calculatePercentile(95)
    });
  }
  
  private calculatePercentile(percentile: number): string {
    const sorted = [...this.metrics.responseTimes].sort((a, b) => a - b);
    const index = Math.ceil(sorted.length * (percentile / 100)) - 1;
    return `${sorted[index]?.toFixed(2) || 0}ms`;
  }
}

const metricsLogger = new MetricsLogger();

// Log metrics every minute
setInterval(() => {
  metricsLogger.logMetrics();
}, 60000);
```

## Performance Considerations ‚ö°

### Async Logging

```typescript
class AsyncLogger {
  private queue: Array<() => void> = [];
  private processing = false;
  
  log(message: string) {
    this.queue.push(() => {
      console.log(message);  // or write to file
    });
    
    if (!this.processing) {
      this.processQueue();
    }
  }
  
  private async processQueue() {
    this.processing = true;
    
    while (this.queue.length > 0) {
      const logFn = this.queue.shift();
      logFn?.();
      
      // Yield to event loop
      await new Promise(resolve => setImmediate(resolve));
    }
    
    this.processing = false;
  }
}
```

### Conditional Logging

```typescript
const isDevelopment = process.env.NODE_ENV === 'development';

// Only log debug in development
if (isDevelopment) {
  log.debug('Detailed debug information');
}

// Lazy evaluation
log.debug(() => {
  // This expensive operation only runs if debug logging is enabled
  return `Debug data: ${JSON.stringify(expensiveOperation())}`;
});
```

### Batched Logging

```typescript
class BatchLogger {
  private batch: any[] = [];
  private batchSize = 100;
  private flushInterval = 5000;
  
  constructor() {
    setInterval(() => this.flush(), this.flushInterval);
  }
  
  log(entry: any) {
    this.batch.push(entry);
    
    if (this.batch.length >= this.batchSize) {
      this.flush();
    }
  }
  
  private flush() {
    if (this.batch.length === 0) return;
    
    // Write all logs at once
    console.log(JSON.stringify(this.batch));
    
    // Or send to logging service
    // await sendToLoggingService(this.batch);
    
    this.batch = [];
  }
}

const batchLogger = new BatchLogger();
```

## Best Practices üíé

### 1. Use Appropriate Log Levels

```typescript
// ‚ùå Bad
log.error('User logged in');  // This is not an error!

// ‚úÖ Good
log.info('User logged in');
log.debug('Session created');
log.warn('High memory usage detected');
log.error('Database connection failed');
log.fatal('Application cannot start');
```

### 2. Include Context

```typescript
// ‚ùå Bad
log.error('Request failed');

// ‚úÖ Good
log.error('Request failed', {
  endpoint: '/api/users',
  method: 'POST',
  statusCode: 500,
  error: error.message,
  userId: req.user?.id
});
```

### 3. Don't Log Sensitive Data

```typescript
// ‚ùå Bad
log.info('User authenticated', { 
  password: user.password,  // Never log passwords!
  creditCard: user.creditCard  // Never log credit cards!
});

// ‚úÖ Good
log.info('User authenticated', {
  userId: user.id,
  username: user.username,
  loginMethod: 'password'
});
```

### 4. Use Structured Logging in Production

```typescript
// ‚úÖ Production
if (process.env.NODE_ENV === 'production') {
  const logEntry = {
    timestamp: new Date().toISOString(),
    level: 'INFO',
    message: 'Request processed',
    requestId: req.id,
    duration: '45ms'
  };
  console.log(JSON.stringify(logEntry));
}

// ‚úÖ Development
if (process.env.NODE_ENV === 'development') {
  log.info('Request processed', {
    requestId: req.id,
    duration: '45ms'
  });
}
```

### 5. Log at Strategic Points

```typescript
// ‚úÖ Good logging points
class UserService {
  async createUser(data: UserData) {
    log.debug('Creating user', { email: data.email });
    
    try {
      const user = await db.user.create(data);
      log.info('User created successfully', { userId: user.id });
      return user;
    } catch (error) {
      log.error('User creation failed', {
        email: data.email,
        error: error.message
      });
      throw error;
    }
  }
}
```

### 6. Monitor Log Volume

```typescript
let logCount = 0;
const LOG_THRESHOLD = 10000;

function monitoredLog(message: string) {
  logCount++;
  
  if (logCount > LOG_THRESHOLD) {
    log.warn(`High log volume detected: ${logCount} logs`);
    // Maybe reduce log level or investigate
  }
  
  log.info(message);
}

// Reset counter hourly
setInterval(() => {
  logCount = 0;
}, 3600000);
```

### 7. Use Request IDs for Tracing

```typescript
import { randomUUID } from 'crypto';

app.use((req, res, next) => {
  req.id = randomUUID();
  
  // Log all operations with request ID
  req.log = {
    info: (msg: string, context?: any) => {
      log.info(msg, { requestId: req.id, ...context });
    },
    error: (msg: string, error?: Error) => {
      log.error(msg, { requestId: req.id, error: error?.message });
    }
  };
  
  next();
});

// Usage in handlers
app.get('/api/users', (req, res) => {
  req.log.info('Fetching users');
  // ...
});
```

## Troubleshooting üîç

### Logs Not Appearing

**Problem:** Logs not showing in console

**Solutions:**

1. Check log level:
```typescript
configureLogger({ level: 'debug' });  // Show all logs
```

2. Ensure logging is enabled:
```typescript
logging: {
  enabled: true  // Must be true
}
```

3. Check environment:
```typescript
console.log('NODE_ENV:', process.env.NODE_ENV);
// Production may have logging disabled
```

### Too Many Logs

**Problem:** Console flooded with logs

**Solutions:**

1. Increase log level:
```typescript
configureLogger({ level: 'warn' });  // Only warnings and errors
```

2. Use sampling:
```typescript
if (Math.random() < 0.1) {  // Log only 10%
  log.debug('Debug information');
}
```

3. Disable debug logs in production:
```typescript
logging: {
  level: process.env.NODE_ENV === 'production' ? 'error' : 'debug'
}
```

### Log Files Growing Too Large

**Problem:** Log files consuming too much disk space

**Solutions:**

1. Implement log rotation (see Log Rotation section)
2. Compress old logs
3. Set up automated cleanup
4. Use external logging service (CloudWatch, DataDog)

### Performance Impact

**Problem:** Logging slowing down application

**Solutions:**

1. Use async logging (see Performance Considerations)
2. Reduce log frequency
3. Sample high-volume logs
4. Use structured logging with external service

## Examples üìö

### Complete Production Logger

```typescript
import { log, configureLogger } from 'azurajs/logger';
import winston from 'winston';

class ProductionLogger {
  private winston: winston.Logger;
  
  constructor() {
    // Configure Winston for file logging
    this.winston = winston.createLogger({
      level: 'info',
      format: winston.format.json(),
      transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
      ]
    });
    
    // Configure AzuraJS logger
    configureLogger({
      showTimestamp: true,
      timestampFormat: 'iso',
      level: 'error'  // Only errors in production
    });
  }
  
  info(message: string, context?: any) {
    this.winston.info(message, context);
    if (process.env.VERBOSE === 'true') {
      log.info(message, context);
    }
  }
  
  error(message: string, error: Error, context?: any) {
    this.winston.error(message, {
      error: error.message,
      stack: error.stack,
      ...context
    });
    log.error(message, context);
  }
  
  warn(message: string, context?: any) {
    this.winston.warn(message, context);
    log.warn(message, context);
  }
}

export const logger = new ProductionLogger();
```

## Next Steps üìñ

<Cards>
  <Card title="Configuration" href="/docs/en/configuration" description="Configure your application" />
  <Card title="Error Handling" href="/docs/en/error-handling" description="Handle errors effectively" />
  <Card title="Performance" href="/docs/en/performance" description="Optimize your application" />
  <Card title="Monitoring" href="/docs/en/monitoring" description="Monitor your application" />
</Cards>
