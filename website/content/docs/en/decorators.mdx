---
title: Decorators
description: Complete guide to all AzuraJS decorators
icon: Tag
---

# Decorators üè∑Ô∏è

AzuraJS provides a rich set of TypeScript decorators for building elegant and type-safe APIs.

## Complete Decorator Reference üìã

### Class Decorators

| Decorator | Purpose | Example |
|-----------|---------|----------|
| `@Controller(prefix?)` | Define a controller class with optional base path | `@Controller("/api/users")` |

### Method Decorators (HTTP Routes)

| Decorator | HTTP Method | Purpose | Example |
|-----------|-------------|---------|----------|
| `@Get(path?)` | GET | Retrieve resources | `@Get("/:id")` |
| `@Post(path?)` | POST | Create resources | `@Post("/create")` |
| `@Put(path?)` | PUT | Update (full) | `@Put("/:id")` |
| `@Patch(path?)` | PATCH | Update (partial) | `@Patch("/:id")` |
| `@Delete(path?)` | DELETE | Remove resources | `@Delete("/:id")` |
| `@Head(path?)` | HEAD | Check existence | `@Head("/:id")` |
| `@Options(path?)` | OPTIONS | CORS preflight | `@Options()` |

### Parameter Decorators

| Decorator | Extracts | Type | Example |
|-----------|----------|------|----------|
| `@Req()` | Full request object | `RequestServer` | `@Req() req: RequestServer` |
| `@Res()` | Full response object | `ResponseServer` | `@Res() res: ResponseServer` |
| `@Body(key?)` | Request body | `any` | `@Body() data: CreateDto` |
| `@Param(key?)` | Route parameters | `string` | `@Param("id") id: string` |
| `@Query(key?)` | Query string params | `string` | `@Query("page") page: string` |
| `@Headers(key?)` | HTTP headers | `string` | `@Headers("auth") token: string` |
| `@Ip()` | Client IP address | `string` | `@Ip() ip: string` |
| `@UserAgent()` | User-Agent header | `string` | `@UserAgent() ua: string` |
| `@Next()` | Next function | `Function` | `@Next() next: () => void` |

<Callout type="info">
  All parameter decorators can be combined in a single method to extract different parts of the request.
</Callout>

## Class Decorators üéØ

### @Controller

Defines a controller class with an optional base path.

```typescript
@Controller(prefix?: string)
```

**Examples:**

```typescript
import { Controller } from "azurajs/decorators";

// With prefix
@Controller("/api/users")
export class UserController {}

// Without prefix
@Controller()
export class RootController {}

// Nested path
@Controller("/api/v1/admin/users")
export class AdminUserController {}
```

## Method Decorators üõ£Ô∏è

Method decorators define HTTP routes for controller methods.

### @Get

Define a GET route.

```typescript
@Get(path?: string)
```

**Examples:**

```typescript
import { Controller, Get } from "azurajs/decorators";

@Controller("/api/users")
export class UserController {
  @Get()  // GET /api/users
  getAll() {}

  @Get("/:id")  // GET /api/users/:id
  getOne() {}

  @Get("/search")  // GET /api/users/search
  search() {}
}
```

### @Post

Define a POST route.

```typescript
@Post(path?: string)
```

**Example:**

```typescript
import { Post, Body } from "azurajs/decorators";

@Post()  // POST /api/users
createUser(@Body() data: any) {
  return { id: Date.now(), ...data };
}
```

### @Put

Define a PUT route for full updates.

```typescript
@Put(path?: string)
```

**Example:**

```typescript
import { Put, Param, Body } from "azurajs/decorators";

@Put("/:id")  // PUT /api/users/:id
updateUser(@Param("id") id: string, @Body() data: any) {
  return { id, ...data };
}
```

### @Patch

Define a PATCH route for partial updates.

```typescript
@Patch(path?: string)
```

**Example:**

```typescript
@Patch("/:id")  // PATCH /api/users/:id
patchUser(@Param("id") id: string, @Body() data: Partial<User>) {
  return { id, ...data };
}
```

### @Delete

Define a DELETE route.

```typescript
@Delete(path?: string)
```

**Example:**

```typescript
@Delete("/:id")  // DELETE /api/users/:id
deleteUser(@Param("id") id: string) {
  return { message: "User deleted" };
}
```

### @Head

Define a HEAD route (for checking resource existence).

```typescript
@Head(path?: string)
```

**Example:**

```typescript
@Head("/:id")  // HEAD /api/users/:id
checkExists(@Param("id") id: string, @Res() res: ResponseServer) {
  const exists = users.some(u => u.id === id);
  res.status(exists ? 200 : 404).end();
}
```

### @Options

Define an OPTIONS route (typically for CORS preflight).

```typescript
@Options(path?: string)
```

**Example:**

```typescript
@Options()  // OPTIONS /api/users
handleOptions(@Res() res: ResponseServer) {
  res.set("Allow", "GET, POST, PUT, DELETE").end();
}
```

## Parameter Decorators üîñ

Parameter decorators inject data into controller method parameters.

### @Req

Inject the full request object.

```typescript
@Req() req: RequestServer
```

**Example:**

```typescript
@Get("/info")
getInfo(@Req() req: RequestServer) {
  return {
    method: req.method,
    url: req.url,
    headers: req.headers
  };
}
```

### @Res

Inject the response object for manual control.

```typescript
@Res() res: ResponseServer
```

**Example:**

```typescript
@Get("/download")
download(@Res() res: ResponseServer) {
  res.setHeader("Content-Type", "application/octet-stream");
  res.setHeader("Content-Disposition", "attachment; filename=file.zip");
  res.send(fileBuffer);
}
```

### @Body

Extract the request body (automatically parsed for JSON and form data).

```typescript
@Body() body: any
```

**Examples:**

```typescript
// Entire body
@Post()
create(@Body() data: CreateUserDto) {
  return { id: Date.now(), ...data };
}

// Access body properties directly
@Post()
create(@Body() { name, email }: { name: string; email: string }) {
  return { name, email };
}
```

### @Param

Extract route parameters from the URL path.

```typescript
@Param(name?: string) param: string
```

**Examples:**

```typescript
// Single parameter
@Get("/:id")
getUser(@Param("id") id: string) {
  return { id };
}

// Multiple parameters
@Get("/:userId/posts/:postId")
getPost(
  @Param("userId") userId: string,
  @Param("postId") postId: string
) {
  return { userId, postId };
}

// All parameters
@Get("/:userId/posts/:postId")
getPost(@Param() params: Record<string, string>) {
  return params;  // { userId: "1", postId: "2" }
}
```

### @Query

Extract query string parameters.

```typescript
@Query(name?: string) query: string
```

**Examples:**

```typescript
// Single query parameter
@Get("/search")
search(@Query("q") searchTerm: string) {
  return { results: [], query: searchTerm };
}

// Multiple query parameters
@Get("/filter")
filter(
  @Query("status") status: string,
  @Query("limit") limit: string
) {
  return { status, limit };
}

// All query parameters
@Get("/search")
search(@Query() query: Record<string, string>) {
  // GET /api/users/search?q=john&limit=10
  return query;  // { q: "john", limit: "10" }
}
```

### @Headers

Extract request headers.

```typescript
@Headers(name?: string) header: string | undefined
```

**Examples:**

```typescript
// Single header
@Get("/protected")
getData(@Headers("authorization") auth: string) {
  if (!auth) {
    throw new HttpError(401, "Unauthorized");
  }
  return { data: "secret" };
}

// Multiple headers
@Get("/info")
getInfo(
  @Headers("user-agent") ua: string,
  @Headers("accept-language") lang: string
) {
  return { userAgent: ua, language: lang };
}

// All headers
@Get("/headers")
getAllHeaders(@Headers() headers: Record<string, string>) {
  return { headers };
}
```

### @Ip

Extract the client IP address.

```typescript
@Ip() ip: string
```

**Example:**

```typescript
@Post("/login")
login(@Body() credentials: any, @Ip() ip: string) {
  console.log(`Login attempt from ${ip}`);
  // Authenticate user
  return { success: true };
}
```

### @UserAgent

Extract the User-Agent header.

```typescript
@UserAgent() userAgent: string
```

**Example:**

```typescript
@Get("/stats")
trackVisit(@UserAgent() ua: string, @Ip() ip: string) {
  console.log(`Visit from ${ip} using ${ua}`);
  return { message: "Visit tracked" };
}
```

### @Next

Inject the next function for middleware chains.

```typescript
@Next() next: (err?: unknown) => void
```

**Example:**

```typescript
@Get("/async")
async handleAsync(
  @Req() req: RequestServer,
  @Res() res: ResponseServer,
  @Next() next: () => void
) {
  try {
    const data = await fetchData();
    res.json({ data });
  } catch (error) {
    next(error);
  }
}
```

## Combining Decorators üîó

You can combine multiple parameter decorators in one method:

```typescript
@Controller("/api/posts")
export class PostController {
  @Get("/:id/comments")
  getComments(
    @Param("id") postId: string,
    @Query("limit") limit: string,
    @Query("offset") offset: string,
    @Headers("authorization") auth: string,
    @Ip() ip: string,
    @Res() res: ResponseServer
  ) {
    // Verify auth
    if (!auth) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    // Log request
    console.log(`${ip} requested comments for post ${postId}`);

    // Return comments
    const comments = getCommentsFromDB(postId, Number(limit), Number(offset));
    res.json({ comments });
  }

  @Post("/:id/comments")
  createComment(
    @Param("id") postId: string,
    @Body() data: CreateCommentDto,
    @Ip() ip: string,
    @UserAgent() ua: string,
    @Res() res: ResponseServer
  ) {
    const comment = {
      id: Date.now(),
      postId,
      ...data,
      metadata: { ip, userAgent: ua }
    };

    res.status(201).json({ comment });
  }
}
```

## Decorator Execution Order ‚ö°

Decorators are executed in this order:

1. **Class Decorator** (`@Controller`) - Registers the controller
2. **Method Decorators** (`@Get`, `@Post`, etc.) - Registers routes
3. **Parameter Decorators** (`@Body`, `@Param`, etc.) - Executed at runtime when the route is called

## Type Safety with Decorators üîí

Use TypeScript interfaces for better type safety:

```typescript
interface CreatePostDto {
  title: string;
  content: string;
  tags: string[];
}

interface UpdatePostDto {
  title?: string;
  content?: string;
  tags?: string[];
}

@Controller("/api/posts")
export class PostController {
  @Post()
  create(@Body() data: CreatePostDto, @Res() res: ResponseServer) {
    // data is fully typed
    const post = {
      id: Date.now(),
      title: data.title,
      content: data.content,
      tags: data.tags
    };
    res.status(201).json({ post });
  }

  @Patch("/:id")
  update(
    @Param("id") id: string,
    @Body() data: UpdatePostDto,
    @Res() res: ResponseServer
  ) {
    // TypeScript knows all fields are optional
    res.json({ id, ...data });
  }
}
```

## Advanced Use Cases üöÄ

### Authentication & Authorization

```typescript
import { Controller, Get, Post, Headers, Body, Res } from "azurajs/decorators";

interface User {
  id: string;
  email: string;
  role: string;
}

@Controller("/api/admin")
export class AdminController {
  // Helper method to verify admin token
  private verifyAdmin(token: string): User {
    if (!token) {
      throw new HttpError(401, "No authorization token");
    }
    
    const user = verifyToken(token);
    
    if (user.role !== 'admin') {
      throw new HttpError(403, "Admin access required");
    }
    
    return user;
  }

  @Get("/users")
  listUsers(@Headers("authorization") auth: string) {
    const user = this.verifyAdmin(auth);
    return { users: getAllUsers() };
  }

  @Delete("/users/:id")
  deleteUser(
    @Param("id") id: string,
    @Headers("authorization") auth: string
  ) {
    const user = this.verifyAdmin(auth);
    deleteUserById(id);
    return { message: "User deleted" };
  }
}
```

### Request Validation Pattern

```typescript
import { Controller, Post, Body, Res } from "azurajs/decorators";

interface CreateUserDto {
  email: string;
  password: string;
  name: string;
  age?: number;
}

function validateEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function validatePassword(password: string): boolean {
  return password.length >= 8;
}

@Controller("/api/users")
export class UserController {
  @Post("/register")
  register(@Body() data: CreateUserDto, @Res() res: ResponseServer) {
    // Validate email
    if (!validateEmail(data.email)) {
      return res.status(400).json({ 
        error: "Invalid email format" 
      });
    }
    
    // Validate password
    if (!validatePassword(data.password)) {
      return res.status(400).json({ 
        error: "Password must be at least 8 characters" 
      });
    }
    
    // Validate age if provided
    if (data.age && (data.age < 13 || data.age > 120)) {
      return res.status(400).json({ 
        error: "Invalid age" 
      });
    }
    
    // Create user
    const user = createUser(data);
    return res.status(201).json({ user });
  }
}
```

### File Upload with Metadata

```typescript
import { Controller, Post, Req, Headers, Ip, UserAgent, Res } from "azurajs/decorators";

@Controller("/api/files")
export class FileController {
  @Post("/upload")
  async uploadFile(
    @Req() req: RequestServer,
    @Headers("content-type") contentType: string,
    @Ip() ip: string,
    @UserAgent() userAgent: string,
    @Res() res: ResponseServer
  ) {
    // Validate content type
    if (!contentType?.includes('multipart/form-data')) {
      return res.status(400).json({ 
        error: "Must use multipart/form-data" 
      });
    }
    
    try {
      const files = await parseMultipartForm(req);
      
      // Save files with metadata
      const savedFiles = files.map(file => ({
        id: generateId(),
        name: file.name,
        size: file.size,
        type: file.type,
        uploadedAt: new Date().toISOString(),
        uploadedFrom: ip,
        userAgent: userAgent
      }));
      
      return res.status(201).json({ 
        files: savedFiles 
      });
    } catch (error) {
      return res.status(500).json({ 
        error: "Upload failed" 
      });
    }
  }
}
```

### Rate Limiting Pattern

```typescript
import { Controller, Post, Ip, Res } from "azurajs/decorators";

const requestCounts = new Map<string, number[]>();

function checkRateLimit(ip: string, maxRequests: number, windowMs: number): boolean {
  const now = Date.now();
  const requests = requestCounts.get(ip) || [];
  
  // Filter requests within time window
  const recentRequests = requests.filter(time => now - time < windowMs);
  
  if (recentRequests.length >= maxRequests) {
    return false; // Rate limit exceeded
  }
  
  // Add current request
  recentRequests.push(now);
  requestCounts.set(ip, recentRequests);
  
  return true; // Allowed
}

@Controller("/api/auth")
export class AuthController {
  @Post("/login")
  login(
    @Body() credentials: { email: string; password: string },
    @Ip() ip: string,
    @Res() res: ResponseServer
  ) {
    // Allow max 5 login attempts per 15 minutes
    if (!checkRateLimit(ip, 5, 15 * 60 * 1000)) {
      return res.status(429).json({
        error: "Too many login attempts. Try again later."
      });
    }
    
    // Authenticate user
    const user = authenticateUser(credentials);
    
    if (!user) {
      return res.status(401).json({ 
        error: "Invalid credentials" 
      });
    }
    
    return res.json({ 
      token: generateToken(user) 
    });
  }
}
```

### Conditional Response Pattern

```typescript
import { Controller, Get, Query, Headers, Res } from "azurajs/decorators";

@Controller("/api/data")
export class DataController {
  @Get("/export")
  exportData(
    @Query("format") format: string,
    @Headers("accept") accept: string,
    @Res() res: ResponseServer
  ) {
    const data = getExportData();
    
    // Determine format from query or Accept header
    const outputFormat = format || 
      (accept?.includes('application/json') ? 'json' : 'csv');
    
    switch (outputFormat) {
      case 'json':
        return res
          .setHeader('Content-Type', 'application/json')
          .json(data);
      
      case 'csv':
        const csv = convertToCSV(data);
        return res
          .setHeader('Content-Type', 'text/csv')
          .setHeader('Content-Disposition', 'attachment; filename=export.csv')
          .send(csv);
      
      case 'xml':
        const xml = convertToXML(data);
        return res
          .setHeader('Content-Type', 'application/xml')
          .send(xml);
      
      default:
        return res.status(400).json({ 
          error: `Unsupported format: ${outputFormat}` 
        });
    }
  }
}
```

### Nested Resource Pattern

```typescript
import { Controller, Get, Post, Delete, Param, Body, Query } from "azurajs/decorators";

// Comments for a specific post
@Controller("/api/posts/:postId/comments")
export class PostCommentController {
  @Get()
  getComments(
    @Param("postId") postId: string,
    @Query("page") page?: string,
    @Query("limit") limit?: string
  ) {
    const pageNum = Number(page) || 1;
    const limitNum = Number(limit) || 20;
    
    const comments = getCommentsForPost(postId, pageNum, limitNum);
    return { 
      postId, 
      comments,
      page: pageNum,
      limit: limitNum
    };
  }

  @Post()
  createComment(
    @Param("postId") postId: string,
    @Body() data: { text: string; authorId: string }
  ) {
    const comment = createComment({
      postId,
      text: data.text,
      authorId: data.authorId
    });
    
    return { comment };
  }

  @Delete("/:commentId")
  deleteComment(
    @Param("postId") postId: string,
    @Param("commentId") commentId: string
  ) {
    deleteComment(postId, commentId);
    return { message: "Comment deleted" };
  }
}
```

## Custom Decorators üé®

### Creating a Custom Decorator

You can create custom decorators for reusable logic:

```typescript
import { Headers, Res } from "azurajs/decorators";
import type { ResponseServer } from "azurajs";

// Custom decorator to extract and verify JWT
function Auth() {
  return function (target: any, propertyKey: string, parameterIndex: number) {
    // Store metadata for processing
    const existingAuth = Reflect.getMetadata('auth_params', target, propertyKey) || [];
    existingAuth.push(parameterIndex);
    Reflect.defineMetadata('auth_params', existingAuth, target, propertyKey);
  };
}

// Usage would look like:
@Controller("/api/protected")
export class ProtectedController {
  @Get("/data")
  getData(
    @Headers("authorization") auth: string,
    @Res() res: ResponseServer
  ) {
    // Manual auth verification
    if (!auth) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    
    const token = auth.replace('Bearer ', '');
    const user = verifyJWT(token);
    
    if (!user) {
      return res.status(401).json({ error: "Invalid token" });
    }
    
    return { data: "protected data", user };
  }
}
```

### Practical Custom Decorator Pattern

For reusable authentication logic:

```typescript
import { Controller, Get, Headers, Res } from "azurajs/decorators";

// Helper function (not a decorator, but reusable)
function requireAuth(token: string, res: ResponseServer): User | null {
  if (!token) {
    res.status(401).json({ error: "No authorization token" });
    return null;
  }
  
  const user = verifyToken(token);
  
  if (!user) {
    res.status(401).json({ error: "Invalid token" });
    return null;
  }
  
  return user;
}

@Controller("/api/profile")
export class ProfileController {
  @Get("/me")
  getProfile(
    @Headers("authorization") auth: string,
    @Res() res: ResponseServer
  ) {
    const user = requireAuth(auth, res);
    if (!user) return; // Response already sent
    
    return { profile: getUserProfile(user.id) };
  }
  
  @Get("/settings")
  getSettings(
    @Headers("authorization") auth: string,
    @Res() res: ResponseServer
  ) {
    const user = requireAuth(auth, res);
    if (!user) return;
    
    return { settings: getUserSettings(user.id) };
  }
}
```

## Decorators vs Functional API ‚öñÔ∏è

### When to Use Decorators

‚úÖ **Best for:**
- TypeScript projects
- Large applications with many routes
- Teams familiar with OOP patterns
- Projects requiring strong type safety
- Complex applications with middleware chains

```typescript
// Decorator approach - Clean and organized
@Controller("/api/users")
export class UserController {
  @Get()
  list() { return { users: [] }; }
  
  @Get("/:id")
  show(@Param("id") id: string) { return { id }; }
  
  @Post()
  create(@Body() data: any) { return { data }; }
}
```

### When to Use Functional API

‚úÖ **Best for:**
- JavaScript projects
- Small applications or prototypes
- Microservices
- Teams familiar with Express.js
- Quick scripts and utilities

```javascript
// Functional approach - Simple and direct
const app = new AzuraClient();

app.get("/api/users", ({ req, res }) => {
  res.json({ users: [] });
});

app.get("/api/users/:id", ({ req, res }) => {
  res.json({ id: req.params.id });
});

app.post("/api/users", ({ req, res }) => {
  res.json({ data: req.body });
});
```

### Feature Comparison

| Feature | Decorators | Functional |
|---------|------------|------------|
| TypeScript required | ‚úÖ Yes | ‚ùå No |
| Type safety | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| Learning curve | Medium | Low |
| Code organization | Excellent | Good |
| Boilerplate | Low | Very low |
| Flexibility | High | Very high |
| Testing | Easy | Very easy |
| Maintenance | Excellent | Good |

### Mixing Both Approaches

You can combine both in the same application:

```typescript
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();

// Use decorators for main API
applyDecorators(app, [UserController]);

// Use functional API for simple routes
app.get("/health", ({ req, res }) => {
  res.json({ status: "ok" });
});

app.get("/version", ({ req, res }) => {
  res.json({ version: "1.0.0" });
});

app.listen(3000);
```

## Performance Considerations ‚ö°

### 1. Decorator Overhead

Decorators add minimal runtime overhead:

```typescript
// ‚úÖ Good: Decorators are processed once at startup
@Controller("/api/users")
export class UserController {
  @Get("/:id")
  getUser(@Param("id") id: string) {
    return { id };
  }
}

// No performance difference at request time
```

### 2. Parameter Extraction Optimization

```typescript
// ‚úÖ Optimal: Extract only what you need
@Get("/:id")
getUser(@Param("id") id: string) {
  return getUserById(id);
}

// ‚ùå Less optimal: Extracting everything
@Get("/:id")
getUser(
  @Req() req: RequestServer,
  @Res() res: ResponseServer,
  @Param() params: any,
  @Query() query: any,
  @Headers() headers: any
) {
  // Only using params.id
  return getUserById(params.id);
}
```

### 3. Response Handling

```typescript
// ‚úÖ Fast: Direct return (automatic JSON)
@Get("/users")
getUsers() {
  return { users: [] };
}

// ‚úÖ Also fast: Manual response
@Get("/users")
getUsers(@Res() res: ResponseServer) {
  return res.json({ users: [] });
}

// ‚ùå Avoid: Unnecessary async when not needed
@Get("/users")
async getUsers() {  // Don't use async if no await
  return { users: [] };
}
```

### 4. Class Instance Reuse

```typescript
// ‚úÖ Good: Controller instances are reused
@Controller("/api/users")
export class UserController {
  // Instance properties are shared across requests
  private cache = new Map();
  
  @Get("/:id")
  getUser(@Param("id") id: string) {
    // Check cache
    if (this.cache.has(id)) {
      return this.cache.get(id);
    }
    
    const user = getUserFromDB(id);
    this.cache.set(id, user);
    return user;
  }
}
```

### 5. Avoid Heavy Decorators

```typescript
// ‚ùå Avoid: Heavy computation in decorators
function SlowDecorator() {
  // This runs at startup, so it's okay
  const config = loadHeavyConfig();
  return function(target: any) {
    // But don't do heavy work here on every request
  };
}

// ‚úÖ Good: Keep decorators lightweight
function FastDecorator() {
  return function(target: any) {
    // Minimal logic
  };
}
```

## Best Practices ‚ú®

### 1. Use DTOs for Type Safety

```typescript
// Define clear interfaces
interface CreateUserDto {
  email: string;
  password: string;
  name: string;
}

interface UpdateUserDto {
  email?: string;
  name?: string;
}

@Controller("/api/users")
export class UserController {
  @Post()
  create(@Body() data: CreateUserDto) {
    // TypeScript ensures data has required fields
    return createUser(data);
  }
  
  @Patch("/:id")
  update(
    @Param("id") id: string,
    @Body() data: UpdateUserDto
  ) {
    // TypeScript knows fields are optional
    return updateUser(id, data);
  }
}
```

### 2. Organize Controllers by Resource

```typescript
// ‚úÖ Good: One controller per resource
@Controller("/api/users")
export class UserController {}

@Controller("/api/posts")
export class PostController {}

@Controller("/api/comments")
export class CommentController {}

// ‚ùå Avoid: Mixing multiple resources
@Controller("/api")
export class ApiController {
  @Get("/users")
  @Get("/posts")
  @Get("/comments")
  // Too many concerns in one controller
}
```

### 3. Keep Methods Focused

```typescript
// ‚úÖ Good: Each method does one thing
@Controller("/api/users")
export class UserController {
  @Get("/:id")
  getUser(@Param("id") id: string) {
    return getUserById(id);
  }
  
  @Get("/:id/posts")
  getUserPosts(@Param("id") id: string) {
    return getPostsByUser(id);
  }
}

// ‚ùå Avoid: Methods doing too much
@Get("/:id")
getUser(
  @Param("id") id: string,
  @Query("include") include: string
) {
  const user = getUserById(id);
  
  if (include === 'posts') {
    user.posts = getPostsByUser(id);
  }
  if (include === 'comments') {
    user.comments = getCommentsByUser(id);
  }
  // Too much logic in one method
  
  return user;
}
```

### 4. Use Explicit Types

```typescript
// ‚úÖ Good: Explicit types
@Get("/:id")
getUser(@Param("id") id: string): User {
  return getUserById(id);
}

// ‚ùå Avoid: Implicit any
@Get("/:id")
getUser(@Param("id") id) {  // id is 'any'
  return getUserById(id);
}
```

### 5. Handle Errors Properly

```typescript
import { Controller, Get, Param, Res } from "azurajs/decorators";

@Controller("/api/users")
export class UserController {
  @Get("/:id")
  getUser(
    @Param("id") id: string,
    @Res() res: ResponseServer
  ) {
    try {
      const user = getUserById(id);
      
      if (!user) {
        return res.status(404).json({ 
          error: "User not found" 
        });
      }
      
      return res.json({ user });
    } catch (error) {
      console.error('Error fetching user:', error);
      return res.status(500).json({ 
        error: "Internal server error" 
      });
    }
  }
}
```

## Common Troubleshooting üîß

### Decorators Not Working

**Problem**: Decorators not being recognized

```typescript
// ‚ùå Problem: Not applying decorators
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();
// Routes not registered!

// ‚úÖ Solution: Apply decorators
import { applyDecorators } from "azurajs/decorators";

const app = new AzuraClient();
applyDecorators(app, [UserController]);
```

### Parameter Not Extracted

**Problem**: Parameter decorators returning undefined

```typescript
// ‚ùå Problem: Wrong parameter name
@Get("/users/:userId")
getUser(@Param("id") id: string) {  // Looking for 'id' but route has 'userId'
  console.log(id); // undefined
}

// ‚úÖ Solution: Match parameter names
@Get("/users/:userId")
getUser(@Param("userId") userId: string) {
  console.log(userId); // Works!
}
```

### TypeScript Compiler Errors

**Problem**: Decorator errors in TypeScript

```json
// tsconfig.json - Required settings
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "target": "ES2017",
    "module": "commonjs"
  }
}
```

### Body Not Parsed

**Problem**: `@Body()` returns undefined

```typescript
// ‚ùå Problem: Missing body parser or wrong Content-Type
@Post("/users")
createUser(@Body() data: any) {
  console.log(data); // undefined
}

// ‚úÖ Solution: Ensure client sends correct Content-Type
// Client side:
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'  // Important!
  },
  body: JSON.stringify({ name: 'John' })
});
```

### Response Sent Twice

**Problem**: Cannot set headers after they are sent

```typescript
// ‚ùå Problem: Returning value AND sending response
@Get("/users")
getUsers(@Res() res: ResponseServer) {
  res.json({ users: [] });
  return { users: [] };  // Don't do this!
}

// ‚úÖ Solution: Choose one approach
@Get("/users")
getUsers(@Res() res: ResponseServer) {
  return res.json({ users: [] });
  // OR just: res.json({ users: [] }); with no return
}

// ‚úÖ Or let AzuraJS handle response
@Get("/users")
getUsers() {
  return { users: [] };  // Automatic JSON response
}
```

### Controller Not Found

**Problem**: 404 for all routes in controller

```typescript
// ‚ùå Problem: Forgot to export or import
export class UserController {}  // Not exported with @Controller

// ‚úÖ Solution: Use @Controller decorator
@Controller("/api/users")
export class UserController {}

// And import/apply it
import { UserController } from "./controllers/UserController";
applyDecorators(app, [UserController]);
```

## Next Steps üìñ

<Cards>
  <Card title="Routing" href="routing" description="Learn about advanced routing patterns" />
  <Card title="Validation" href="validation" description="Validate decorator parameters" />
  <Card title="Middleware" href="middleware" description="Use middleware with decorators" />
  <Card title="Examples" href="examples" description="See real-world examples" />
</Cards>
