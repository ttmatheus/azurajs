---
title: Cluster Mode
description: Escale sua aplica√ß√£o atrav√©s de m√∫ltiplos n√∫cleos de CPU automaticamente
icon: Monitor
---

# Cluster Mode üñ•Ô∏è

AzuraJS fornece suporte integrado ao modo cluster para escalar automaticamente sua aplica√ß√£o atrav√©s de todos os n√∫cleos de CPU dispon√≠veis, sem nenhuma configura√ß√£o manual.

## Ativar Cluster Mode ‚ö°

Simplesmente ative o cluster mode no seu arquivo de configura√ß√£o e AzuraJS cuida de tudo automaticamente:

```typescript title="azura.config.ts"
import type { ConfigTypes } from "azurajs/config";

const config: ConfigTypes = {
  server: {
    port: 3000,
    cluster: true,  // Ativar cluster mode
  },
};

export default config;
```

S√≥ isso! Quando `cluster: true` est√° definido, AzuraJS automaticamente:
- ‚úÖ Detecta o n√∫mero de n√∫cleos de CPU dispon√≠veis
- ‚úÖ Cria um processo worker por n√∫cleo de CPU
- ‚úÖ Distribui conex√µes entre os workers usando round-robin
- ‚úÖ Reinicia automaticamente workers que crasharam
- ‚úÖ Gerencia o desligamento gracioso de todos os workers
- ‚úÖ Gerencia comunica√ß√£o entre processos

## Como Funciona üîß

Nenhum c√≥digo de cluster manual √© necess√°rio. O c√≥digo da sua aplica√ß√£o permanece simples:

```typescript title="index.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { HomeController } from "./controllers/HomeController";

const app = new AzuraClient();

applyDecorators(app, [HomeController]);

await app.listen();
```

AzuraJS gerencia internamente toda a l√≥gica de cluster baseado na sua configura√ß√£o. O framework ir√°:

1. Criar um processo prim√°rio que gerencia os workers
2. Criar processos workers (um por n√∫cleo de CPU)
3. Cada worker executa sua aplica√ß√£o independentemente
4. O balanceamento de carga √© gerenciado pelo sistema operacional
5. Crashes de workers s√£o detectados e novos workers s√£o criados automaticamente

**Voc√™ n√£o precisa escrever nenhum c√≥digo de cluster** - AzuraJS gerencia tudo nos bastidores.

## Quando Usar Cluster Mode üìä

**Use cluster mode quando:**
- ‚úÖ Executar em ambientes de produ√ß√£o
- ‚úÖ Lidar com alto tr√°fego e requisi√ß√µes concorrentes
- ‚úÖ Servidor multi-core dispon√≠vel (2+ cores)
- ‚úÖ Precisa de melhor performance e confiabilidade
- ‚úÖ Quer recupera√ß√£o autom√°tica de processos

**N√£o use cluster mode quando:**
- ‚ùå Desenvolvendo localmente (processo √∫nico √© mais f√°cil de debugar)
- ‚ùå Executando em sistemas single-core (sem benef√≠cio)
- ‚ùå Usando orquestra√ß√£o de containers (Kubernetes, Docker Swarm)
- ‚ùå Precisa debugar problemas espec√≠ficos
- ‚ùå Executando tarefas agendadas ou cron jobs

## Configura√ß√£o Baseada em Ambiente üåç

Ative cluster mode apenas em produ√ß√£o:

```typescript title="azura.config.ts"
const isProduction = process.env.NODE_ENV === "production";

const config: ConfigTypes = {
  environment: isProduction ? "production" : "development",
  server: {
    port: 3000,
    cluster: isProduction,  // Cluster apenas em produ√ß√£o
  },
};

export default config;
```

## Exemplo de Configura√ß√£o Completa ‚öôÔ∏è

```typescript title="azura.config.ts"
import type { ConfigTypes } from "azurajs/config";

const config: ConfigTypes = {
  environment: "production",
  server: {
    port: process.env.PORT || 3000,
    cluster: true,              // Ativar cluster mode
    ipHost: false,
  },
  logging: {
    enabled: true,
    showDetails: true,          // Mostra IDs dos processos workers nos logs
  },
  plugins: {
    cors: {
      enabled: true,
      origins: ["*"],
      methods: ["GET", "POST", "PUT", "DELETE"],
    },
  },
};

export default config;
```

## Considera√ß√µes sobre Estado Compartilhado üíæ

Workers executam em processos separados e n√£o compartilham mem√≥ria. Use armazenamento externo para estado compartilhado:

### ‚ùå N√£o Funciona entre Workers

```typescript
// Cache em mem√≥ria n√£o ser√° compartilhado entre workers
const cache = new Map();

@Get("/data")
getData() {
  if (cache.has("key")) {
    return cache.get("key");
  }
  // Este cache √© por-worker, n√£o compartilhado!
}
```

### ‚úÖ Use Armazenamento Externo

```typescript
// Redis para cache compartilhado entre todos os workers
import Redis from "ioredis";
const redis = new Redis();

@Get("/data")
async getData() {
  const cached = await redis.get("key");
  if (cached) {
    return JSON.parse(cached);
  }
  
  const data = await fetchData();
  await redis.set("key", JSON.stringify(data));
  return data;
}
```

**Solu√ß√µes recomendadas para estado compartilhado:**
- Redis para cache e sess√µes
- PostgreSQL/MySQL para dados persistentes
- MongoDB para armazenamento de documentos
- Filas de mensagens externas (RabbitMQ, Kafka)

## Benef√≠cios de Performance üìà

Melhorias de performance esperadas com cluster mode:

| N√∫cleos CPU | Aumento de Throughput |
|-------------|----------------------|
| 2 cores     | ~1.8x               |
| 4 cores     | ~3.5x               |
| 8 cores     | ~6-7x               |
| 16 cores    | ~12-14x             |

Ganhos reais dependem de:
- Opera√ß√µes vinculadas a I/O vs CPU
- Sistema operacional
- Arquitetura da aplica√ß√£o
- Condi√ß√µes de rede

## Docker e Kubernetes üê≥

Quando usar orquestra√ß√£o de containers, desative cluster mode e deixe o orquestrador lidar com o escalonamento:

```typescript title="azura.config.ts"
const config: ConfigTypes = {
  server: {
    cluster: false,  // Deixe o orquestrador lidar com o escalonamento
  },
};
```

Escale containers ao inv√©s:

```yaml title="docker-compose.yml"
services:
  api:
    image: myapp
    deploy:
      replicas: 4  # Executar 4 containers
```

```yaml title="kubernetes-deployment.yml"
apiVersion: apps/v1
kind: Deployment
metadata:
  name: azurajs-app
spec:
  replicas: 4  # Executar 4 pods
  template:
    spec:
      containers:
      - name: app
        image: myapp
```

## Monitoramento e Logs üëÄ

Com `logging.showDetails: true`, os logs do AzuraJS mostram informa√ß√µes dos workers:

```
[Worker 1] Servidor ouvindo na porta 3000 (PID: 12345)
[Worker 2] Servidor ouvindo na porta 3000 (PID: 12346)
[Worker 3] Servidor ouvindo na porta 3000 (PID: 12347)
[Worker 4] Servidor ouvindo na porta 3000 (PID: 12348)
```

Quando um worker crasha e reinicia automaticamente:

```
[Primary] Worker 2 (PID: 12346) crashou
[Primary] Iniciando novo worker...
[Worker 5] Servidor ouvindo na porta 3000 (PID: 12350)
```

## Melhores Pr√°ticas ‚ú®

<Callout type="tip">
  **Ative apenas em produ√ß√£o** - Desenvolvimento √© mais f√°cil com um √∫nico processo
</Callout>

<Callout type="tip">
  **Use armazenamento externo** - Redis, bancos de dados, ou filas de mensagens para estado compartilhado
</Callout>

<Callout type="warn">
  **Teste completamente** - Comportamento pode diferir entre modo √∫nico e cluster
</Callout>

<Callout type="info">
  **Monitore seus workers** - Acompanhe a sa√∫de dos workers e padr√µes de rein√≠cio em produ√ß√£o
</Callout>

## Resolu√ß√£o de Problemas üîç

### Workers Continuam Crashando

Verifique os logs da sua aplica√ß√£o para identificar o erro. Problemas comuns:
- Exce√ß√µes n√£o capturadas
- Vazamentos de mem√≥ria
- Problemas de conex√£o com banco de dados
- Falta de tratamento de erros

### Comportamento Inconsistente entre Requisi√ß√µes

Isso geralmente significa que voc√™ est√° usando estado em mem√≥ria que n√£o √© compartilhado. Solu√ß√£o:
- Mova o estado para Redis ou banco de dados
- Garanta que todos os dados sejam armazenados externamente
- Use arquitetura stateless

### Erro de Porta J√° em Uso

Se voc√™ ver este erro, pode estar executando m√∫ltiplas inst√¢ncias. Verifique:
- Nenhum outro processo na mesma porta
- Apenas uma inst√¢ncia do AzuraJS executando
- Arquivo de configura√ß√£o est√° correto

## Pr√≥ximos Passos üìñ

<Cards>
  <Card title="Configura√ß√£o" href="/docs/pt/configuration" description="Aprenda todas as op√ß√µes de configura√ß√£o" />
  <Card title="Performance" href="/docs/pt/performance" description="Otimize sua aplica√ß√£o ainda mais" />
  <Card title="Tratamento de Erros" href="/docs/pt/error-handling" description="Trate erros graciosamente" />
</Cards>

```typescript
import { AzuraClient } from "azurajs";
import cluster from "cluster";
import { cpus } from "os";

const numCPUs = cpus().length;

if (cluster.isPrimary) {
  console.log(`Primary process ${process.pid} is running`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on("exit", (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    // Restart worker
    cluster.fork();
  });
} else {
  // Workers compartilham a porta TCP
  const app = new AzuraClient();
  
  // Registrar controllers
  applyDecorators(app, [UserController, PostController]);
  
  await app.listen(3000);
  console.log(`Worker ${process.pid} started`);
}
```

## Configura√ß√£o Completa üîß

### Cluster com Configura√ß√£o Avan√ßada

```typescript
import cluster from "cluster";
import { cpus } from "os";
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";

const numCPUs = cpus().length;
const PORT = process.env.PORT || 3000;

if (cluster.isPrimary) {
  console.log(`üöÄ Primary ${process.pid} is running`);
  console.log(`üìä CPU cores: ${numCPUs}`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    const worker = cluster.fork();
    console.log(`üî∑ Worker ${worker.process.pid} started`);
  }
  
  // Monitorar workers
  cluster.on("online", (worker) => {
    console.log(`‚úÖ Worker ${worker.process.pid} is online`);
  });
  
  cluster.on("exit", (worker, code, signal) => {
    console.log(`‚ùå Worker ${worker.process.pid} died (${signal || code})`);
    
    // Reiniciar worker
    const newWorker = cluster.fork();
    console.log(`üîÑ New worker ${newWorker.process.pid} started`);
  });
  
  // Graceful shutdown
  process.on("SIGTERM", () => {
    console.log("SIGTERM received, shutting down workers...");
    
    for (const id in cluster.workers) {
      cluster.workers[id]?.kill();
    }
  });
  
} else {
  // Worker process
  const app = new AzuraClient({
    environment: "production",
    server: {
      port: PORT
    },
    logging: {
      level: "info"
    }
  });
  
  // Registrar controllers
  applyDecorators(app, [UserController]);
  
  // Iniciar servidor
  await app.listen(PORT);
  console.log(`Worker ${process.pid} listening on port ${PORT}`);
}
```

## N√∫mero Ideal de Workers üìä

```typescript
// Usar todos os n√∫cleos
const numCPUs = cpus().length;

// Usar todos exceto um (deixar um core livre para o sistema)
const numWorkers = Math.max(1, numCPUs - 1);

// Usar metade dos n√∫cleos (para ambientes compartilhados)
const numWorkers = Math.max(1, Math.floor(numCPUs / 2));

// Usar n√∫mero configur√°vel
const numWorkers = process.env.WORKERS 
  ? parseInt(process.env.WORKERS) 
  : numCPUs;
```

## Comunica√ß√£o entre Workers üí¨

Workers podem se comunicar atrav√©s do processo primary:

```typescript
if (cluster.isPrimary) {
  const stats = {
    requests: 0,
    errors: 0
  };
  
  cluster.on("message", (worker, message) => {
    if (message.type === "request") {
      stats.requests++;
    } else if (message.type === "error") {
      stats.errors++;
    }
    
    // Broadcast stats para todos os workers
    for (const id in cluster.workers) {
      cluster.workers[id]?.send({ type: "stats", data: stats });
    }
  });
  
} else {
  // Worker
  const app = new AzuraClient();
  
  app.use((req, res, next) => {
    // Notificar primary sobre requisi√ß√£o
    process.send?.({ type: "request" });
    next();
  });
  
  // Receber mensagens do primary
  process.on("message", (message) => {
    if (message.type === "stats") {
      console.log("Global stats:", message.data);
    }
  });
}
```

## Estado Compartilhado üîÑ

Workers n√£o compartilham mem√≥ria. Use Redis ou banco de dados para estado compartilhado:

```typescript
import { createClient } from "redis";

const redis = createClient({ url: "redis://localhost:6379" });
await redis.connect();

@Controller("/api")
export class ApiController {
  @Get("/counter")
  async getCounter() {
    // Incrementar contador compartilhado
    const count = await redis.incr("global-counter");
    return { count, worker: process.pid };
  }

  @Post("/cache")
  async setCache(@Body() data: any) {
    // Cache compartilhado entre workers
    await redis.setEx(`cache:${data.key}`, 3600, JSON.stringify(data.value));
    return { cached: true };
  }
}
```

## Sess√µes em Cluster Mode üîê

Use Redis para armazenar sess√µes:

```typescript
import { createClient } from "redis";

const redis = createClient();
await redis.connect();

// Middleware de sess√£o
async function sessionMiddleware(
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const sessionId = req.cookies.sessionId;
  
  if (sessionId) {
    const sessionData = await redis.get(`session:${sessionId}`);
    if (sessionData) {
      req.session = JSON.parse(sessionData);
    }
  }
  
  // Salvar sess√£o ao finalizar
  const originalJson = res.json.bind(res);
  res.json = async function(data: any) {
    if (req.session) {
      await redis.setEx(
        `session:${sessionId}`,
        3600,
        JSON.stringify(req.session)
      );
    }
    return originalJson(data);
  };
  
  next();
}

app.use(sessionMiddleware);
```

## Monitoramento de Workers üìà

### Middleware de M√©tricas

```typescript
if (cluster.isPrimary) {
  const workerStats = new Map();
  
  // Coletar estat√≠sticas
  setInterval(() => {
    for (const id in cluster.workers) {
      const worker = cluster.workers[id];
      worker?.send({ type: "request-stats" });
    }
  }, 10000);  // A cada 10 segundos
  
  cluster.on("message", (worker, message) => {
    if (message.type === "stats") {
      workerStats.set(worker.id, message.data);
      
      // Calcular estat√≠sticas globais
      let totalRequests = 0;
      let totalErrors = 0;
      
      workerStats.forEach(stats => {
        totalRequests += stats.requests;
        totalErrors += stats.errors;
      });
      
      console.log(`üìä Total: ${totalRequests} requests, ${totalErrors} errors`);
    }
  });
  
} else {
  let workerRequests = 0;
  let workerErrors = 0;
  
  app.use((req, res, next) => {
    workerRequests++;
    next();
  });
  
  process.on("message", (message) => {
    if (message.type === "request-stats") {
      process.send?.({
        type: "stats",
        data: {
          requests: workerRequests,
          errors: workerErrors,
          pid: process.pid
        }
      });
    }
  });
}
```

## Graceful Shutdown üõë

Implemente shutdown gracioso para n√£o perder requisi√ß√µes:

```typescript
if (cluster.isPrimary) {
  process.on("SIGTERM", async () => {
    console.log("Iniciando graceful shutdown...");
    
    // Notificar workers para parar de aceitar novas conex√µes
    for (const id in cluster.workers) {
      cluster.workers[id]?.send({ type: "shutdown" });
    }
    
    // Aguardar workers finalizarem
    await new Promise((resolve) => {
      const timeout = setTimeout(resolve, 30000);  // Timeout de 30s
      
      let workersAlive = Object.keys(cluster.workers || {}).length;
      
      cluster.on("exit", () => {
        workersAlive--;
        if (workersAlive === 0) {
          clearTimeout(timeout);
          resolve(undefined);
        }
      });
    });
    
    console.log("Shutdown completo");
    process.exit(0);
  });
  
} else {
  let server: any;
  
  const app = new AzuraClient();
  server = await app.listen(3000);
  
  process.on("message", (message) => {
    if (message.type === "shutdown") {
      console.log(`Worker ${process.pid} iniciando shutdown...`);
      
      // Parar de aceitar novas conex√µes
      server.close(() => {
        console.log(`Worker ${process.pid} encerrado`);
        process.exit(0);
      });
      
      // For√ßar shutdown ap√≥s 10 segundos
      setTimeout(() => {
        console.log(`Worker ${process.pid} for√ßando shutdown`);
        process.exit(1);
      }, 10000);
    }
  });
}
```

## Zero-Downtime Deployments üöÄ

Reinicie workers um por vez para zero downtime:

```typescript
if (cluster.isPrimary) {
  let workers: any[] = [];
  
  // Fork inicial
  for (let i = 0; i < numCPUs; i++) {
    workers.push(cluster.fork());
  }
  
  // Reload gracioso
  process.on("SIGUSR2", () => {
    console.log("Iniciando reload gracioso...");
    
    const reloadWorker = (index: number) => {
      if (index >= workers.length) {
        console.log("Reload completo!");
        return;
      }
      
      const oldWorker = workers[index];
      const newWorker = cluster.fork();
      
      newWorker.once("listening", () => {
        // Matar worker antigo
        oldWorker.kill();
        workers[index] = newWorker;
        
        // Pr√≥ximo worker ap√≥s delay
        setTimeout(() => reloadWorker(index + 1), 1000);
      });
    };
    
    reloadWorker(0);
  });
}
```

## Exemplo Completo üéØ

```typescript
// server.ts
import cluster from "cluster";
import { cpus } from "os";
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { createClient } from "redis";
import { UserController } from "./controllers/UserController";

const numCPUs = cpus().length;
const PORT = 3000;

if (cluster.isPrimary) {
  console.log(`üöÄ AzuraJS Cluster Mode`);
  console.log(`üìä CPUs: ${numCPUs}`);
  console.log(`üî∑ Starting ${numCPUs} workers...`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  // Auto-restart
  cluster.on("exit", (worker, code, signal) => {
    console.log(`‚ùå Worker ${worker.process.pid} died`);
    const newWorker = cluster.fork();
    console.log(`‚úÖ Worker ${newWorker.process.pid} started`);
  });
  
  // Graceful shutdown
  process.on("SIGTERM", () => {
    for (const id in cluster.workers) {
      cluster.workers[id]?.send({ type: "shutdown" });
    }
  });
  
} else {
  // Worker
  const redis = createClient();
  await redis.connect();
  
  const app = new AzuraClient({
    environment: "production",
    server: { port: PORT },
    plugins: {
      cors: { enabled: true, origin: "*" },
      rateLimit: { enabled: true, windowMs: 60000, max: 100 }
    }
  });
  
  // Middleware de sess√£o compartilhada
  app.use(async (req, res, next) => {
    const sessionId = req.cookies.sessionId;
    if (sessionId) {
      const data = await redis.get(`session:${sessionId}`);
      req.session = data ? JSON.parse(data) : {};
    }
    next();
  });
  
  // Registrar controllers
  applyDecorators(app, [UserController]);
  
  // Iniciar servidor
  const server = await app.listen(PORT);
  console.log(`‚úÖ Worker ${process.pid} listening on port ${PORT}`);
  
  // Graceful shutdown
  process.on("message", (msg) => {
    if (msg.type === "shutdown") {
      server.close(() => process.exit(0));
      setTimeout(() => process.exit(1), 10000);
    }
  });
}
```

## Melhores Pr√°ticas ‚ú®

<Callout type="tip">
  **Use Redis para estado compartilhado**: Workers n√£o compartilham mem√≥ria
</Callout>

<Callout type="tip">
  **Implemente auto-restart**: Workers podem crashar, sempre reinicie automaticamente
</Callout>

<Callout type="tip">
  **Graceful shutdown**: Aguarde requisi√ß√µes finalizarem antes de matar workers
</Callout>

<Callout type="warn">
  **Cuidado com mem√≥ria**: Cada worker consome mem√≥ria, monitore uso total
</Callout>

## Pr√≥ximos Passos üìñ

<Cards>
  <Card title="Performance" href="performance" description="Otimize ainda mais" />
  <Card title="Error Handling" href="error-handling" description="Trate erros em cluster" />
  <Card title="Exemplos" href="examples" description="Veja exemplos completos" />
</Cards>
