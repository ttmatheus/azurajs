---
title: Rate Limiting
description: Guia completo para proteger sua API contra abuso com estratÃ©gias de rate limiting
icon: Shield
---

# Rate Limiting ğŸ›¡ï¸

Rate limiting Ã© uma prÃ¡tica essencial de seguranÃ§a que protege sua API contra abuso, ataques DDoS e consumo excessivo de recursos, limitando o nÃºmero de requisiÃ§Ãµes que um cliente pode fazer dentro de uma janela de tempo especÃ­fica.

## Por que Rate Limiting Ã© Importante ğŸ¯

### ProteÃ§Ã£o Contra Ataques
- **Ataques DDoS**: Previne ataques de negaÃ§Ã£o de serviÃ§o que sobrecarregam seus servidores
- **ForÃ§a Bruta**: Limita tentativas de login para prevenir ataques de adivinhaÃ§Ã£o de senha
- **Abuso de API**: Impede atores maliciosos de fazer scraping ou sobrecarregar seus endpoints

### Gerenciamento de Recursos
- **Uso Justo**: Garante que todos os usuÃ¡rios tenham acesso justo aos recursos da API
- **Controle de Custos**: Reduz custos de infraestrutura prevenindo chamadas excessivas
- **Performance**: MantÃ©m tempos de resposta consistentes para todos os usuÃ¡rios

### Objetivos de NegÃ³cio
- **Acesso por Camadas**: Implemente diferentes limites para usuÃ¡rios gratuitos, premium e enterprise
- **MonetizaÃ§Ã£o**: Incentive upgrades oferecendo limites maiores em planos pagos
- **Conformidade com SLA**: Atenda acordos de nÃ­vel de serviÃ§o prevenindo esgotamento de recursos

## EstratÃ©gias de Rate Limiting ğŸ“Š

### 1. Janela Fixa (Fixed Window)
Contador simples que reseta em intervalos fixos.

**Vantagens**: FÃ¡cil de implementar, previsÃ­vel
**Desvantagens**: Permite rajadas nos limites da janela

```typescript
// 100 requisiÃ§Ãµes por hora
// Janela: 12:00-13:00, 13:00-14:00, etc.
```

### 2. Janela Deslizante (Sliding Window)
Mais preciso, considera perÃ­odo de tempo mÃ³vel.

**Vantagens**: Previne rajadas nas bordas, mais justo
**Desvantagens**: Mais complexo, requer rastreamento de timestamps

```typescript
// 100 requisiÃ§Ãµes em qualquer perÃ­odo de 60 minutos
// Janela constantemente em movimento
```

### 3. Balde de Tokens (Token Bucket)
Tokens se regeneram a uma taxa fixa.

**Vantagens**: Permite rajadas controladas, flexÃ­vel
**Desvantagens**: Algoritmo mais complexo

```typescript
// Balde com 100 tokens
// Recarrega 10 tokens/minuto
// Cada requisiÃ§Ã£o custa 1 token
```

### 4. Balde Furado (Leaky Bucket)
RequisiÃ§Ãµes processadas a uma taxa constante.

**Vantagens**: Fluxo de trÃ¡fego suave, previne picos
**Desvantagens**: Pode atrasar requisiÃ§Ãµes legÃ­timas

```typescript
// Fila processa 10 requisiÃ§Ãµes/segundo
// RequisiÃ§Ãµes extras aguardam ou sÃ£o rejeitadas
```

## Plugin Rate Limit Embutido ğŸ“¦

AzuraJS inclui um plugin de rate limiting pronto para uso:

```typescript
import { AzuraClient } from "azurajs";

const app = new AzuraClient({
  plugins: {
    rateLimit: {
      enabled: true,
      windowMs: 60000,  // 1 minuto
      max: 100,  // 100 requisiÃ§Ãµes por janela
      message: "Muitas requisiÃ§Ãµes. Tente novamente mais tarde.",
      statusCode: 429,
      headers: true  // Adicionar cabeÃ§alhos X-RateLimit-*
    }
  }
});
```

## ConfiguraÃ§Ã£o do Plugin ğŸš¨

### OpÃ§Ãµes DisponÃ­veis

```typescript
interface RateLimitOptions {
  enabled: boolean;          // Ativar/desativar
  windowMs: number;          // Janela de tempo (ms)
  max: number;               // MÃ¡ximo de requisiÃ§Ãµes por janela
  message?: string;          // Mensagem de erro
  statusCode?: number;       // CÃ³digo de status (padrÃ£o: 429)
  headers?: boolean;         // Incluir cabeÃ§alhos X-RateLimit-*
  skipSuccessfulRequests?: boolean;  // NÃ£o contar requisiÃ§Ãµes bem-sucedidas
  skipFailedRequests?: boolean;      // NÃ£o contar requisiÃ§Ãµes com erro
  keyGenerator?: (req: RequestServer) => string;  // Gerar chave customizada
  skip?: (req: RequestServer) => boolean;         // Pular rate limit
}
```

### Exemplo Completo

```typescript
const app = new AzuraClient({
  plugins: {
    rateLimit: {
      enabled: true,
      windowMs: 900000,  // 15 minutos
      max: 100,
      message: "VocÃª atingiu o limite de requisiÃ§Ãµes. Aguarde antes de tentar novamente.",
      statusCode: 429,
      headers: true,
      skipSuccessfulRequests: false,
      skipFailedRequests: true
    }
  }
});
```

## Middleware Rate Limit Customizado ğŸ”¨

Crie seu prÃ³prio middleware de rate limiting:

```typescript
interface RateLimitRecord {
  count: number;
  resetAt: number;
}

const store = new Map<string, RateLimitRecord>();

function rateLimitMiddleware(
  windowMs: number,
  max: number
) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    const key = req.ip;  // Usar IP como chave
    const now = Date.now();
    
    let record = store.get(key);
    
    // Criar novo registro ou resetar se janela expirou
    if (!record || now > record.resetAt) {
      record = {
        count: 1,
        resetAt: now + windowMs
      };
      store.set(key, record);
      return next();
    }
    
    // Incrementar contador
    record.count++;
    
    // Adicionar cabeÃ§alhos
    res.setHeader("X-RateLimit-Limit", max.toString());
    res.setHeader("X-RateLimit-Remaining", Math.max(0, max - record.count).toString());
    res.setHeader("X-RateLimit-Reset", new Date(record.resetAt).toISOString());
    
    // Verificar limite
    if (record.count > max) {
      return res.status(429).json({
        error: "Muitas requisiÃ§Ãµes",
        retryAfter: Math.ceil((record.resetAt - now) / 1000)
      });
    }
    
    next();
  };
}

app.use(rateLimitMiddleware(60000, 100));  // 100 req/min
```

## Rate Limit por Rota ğŸ¯

Aplique diferentes limites a diferentes rotas:

```typescript
// Rate limit restrito para autenticaÃ§Ã£o
const authRateLimit = rateLimitMiddleware(900000, 5);  // 5 tentativas em 15 min

// Rate limit normal para API
const apiRateLimit = rateLimitMiddleware(60000, 100);  // 100 req/min

// Aplicar middlewares
app.use("/auth/login", authRateLimit);
app.use("/auth/register", authRateLimit);
app.use("/api", apiRateLimit);
```

## Rate Limit por UsuÃ¡rio ğŸ‘¤

Use ID de usuÃ¡rio em vez de IP:

```typescript
function userRateLimitMiddleware(
  windowMs: number,
  max: number
) {
  const store = new Map<string, RateLimitRecord>();
  
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    // Obter ID do usuÃ¡rio do token ou sessÃ£o
    const userId = req.user?.id || req.ip;  // Fallback para IP
    const now = Date.now();
    
    let record = store.get(userId);
    
    if (!record || now > record.resetAt) {
      record = { count: 1, resetAt: now + windowMs };
      store.set(userId, record);
      return next();
    }
    
    record.count++;
    
    if (record.count > max) {
      return res.status(429).json({
        error: "Limite de requisiÃ§Ãµes atingido",
        userId
      });
    }
    
    next();
  };
}

// Aplicar apÃ³s middleware de autenticaÃ§Ã£o
app.use(authMiddleware);
app.use(userRateLimitMiddleware(60000, 1000));  // 1000 req/min por usuÃ¡rio
```

## Rate Limit DistribuÃ­do com Redis ğŸ”´

Para aplicaÃ§Ãµes com mÃºltiplas instÃ¢ncias, use Redis:

```typescript
import { createClient } from "redis";

const redis = createClient({ url: "redis://localhost:6379" });
await redis.connect();

function redisRateLimitMiddleware(
  windowMs: number,
  max: number
) {
  return async (req: RequestServer, res: ResponseServer, next: () => void) => {
    const key = `rate-limit:${req.ip}`;
    const now = Date.now();
    
    try {
      // Obter contador atual
      const data = await redis.get(key);
      let record: RateLimitRecord;
      
      if (!data) {
        // Criar novo registro
        record = { count: 1, resetAt: now + windowMs };
        await redis.setEx(key, Math.ceil(windowMs / 1000), JSON.stringify(record));
        return next();
      }
      
      record = JSON.parse(data);
      
      // Verificar se janela expirou
      if (now > record.resetAt) {
        record = { count: 1, resetAt: now + windowMs };
        await redis.setEx(key, Math.ceil(windowMs / 1000), JSON.stringify(record));
        return next();
      }
      
      // Incrementar contador
      record.count++;
      await redis.setEx(key, Math.ceil((record.resetAt - now) / 1000), JSON.stringify(record));
      
      // Verificar limite
      if (record.count > max) {
        return res.status(429).json({
          error: "Muitas requisiÃ§Ãµes",
          retryAfter: Math.ceil((record.resetAt - now) / 1000)
        });
      }
      
      next();
    } catch (error) {
      console.error("Redis rate limit error:", error);
      next();  // Falhar aberto em caso de erro do Redis
    }
  };
}

app.use(redisRateLimitMiddleware(60000, 100));
```

## Rate Limit com Sliding Window ğŸ“Š

ImplementaÃ§Ã£o mais precisa com janela deslizante:

```typescript
interface SlidingWindowRecord {
  requests: number[];  // Timestamps das requisiÃ§Ãµes
}

const store = new Map<string, SlidingWindowRecord>();

function slidingWindowRateLimit(
  windowMs: number,
  max: number
) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    const key = req.ip;
    const now = Date.now();
    const windowStart = now - windowMs;
    
    let record = store.get(key);
    
    if (!record) {
      record = { requests: [] };
      store.set(key, record);
    }
    
    // Remover requisiÃ§Ãµes antigas
    record.requests = record.requests.filter(timestamp => timestamp > windowStart);
    
    // Adicionar requisiÃ§Ã£o atual
    record.requests.push(now);
    
    // Adicionar cabeÃ§alhos
    res.setHeader("X-RateLimit-Limit", max.toString());
    res.setHeader("X-RateLimit-Remaining", Math.max(0, max - record.requests.length).toString());
    
    // Verificar limite
    if (record.requests.length > max) {
      return res.status(429).json({
        error: "Muitas requisiÃ§Ãµes",
        current: record.requests.length,
        limit: max
      });
    }
    
    next();
  };
}

app.use(slidingWindowRateLimit(60000, 100));
```

## Rate Limit por Endpoint ğŸ›£ï¸

Diferentes limites para diferentes endpoints:

```typescript
@Controller("/api")
export class ApiController {
  @Post("/expensive-operation")
  expensiveOp(@Req() req: RequestServer, @Res() res: ResponseServer) {
    // Verificar rate limit especÃ­fico
    const key = `expensive:${req.ip}`;
    const limit = checkRateLimit(key, 600000, 5);  // 5 por 10 min
    
    if (!limit.allowed) {
      return res.status(429).json({
        error: "OperaÃ§Ã£o limitada a 5 por 10 minutos"
      });
    }
    
    // Executar operaÃ§Ã£o
    return { result: "ok" };
  }

  @Get("/public-data")
  publicData(@Req() req: RequestServer, @Res() res: ResponseServer) {
    // Rate limit mais permissivo
    const key = `public:${req.ip}`;
    const limit = checkRateLimit(key, 60000, 1000);  // 1000 por min
    
    if (!limit.allowed) {
      return res.status(429).json({ error: "Rate limit exceeded" });
    }
    
    return { data: "public" };
  }
}

function checkRateLimit(key: string, windowMs: number, max: number) {
  // ImplementaÃ§Ã£o similar aos exemplos anteriores
  // ...
  return { allowed: true, remaining: max };
}
```

## Whitelist e Blacklist ğŸ“

Skip rate limiting para IPs confiÃ¡veis:

```typescript
const WHITELISTED_IPS = new Set([
  "127.0.0.1",
  "::1",
  "10.0.0.1"  // IP interno
]);

const BLACKLISTED_IPS = new Set([
  "192.168.1.100"  // IP banido
]);

function rateLimitWithWhitelist(
  windowMs: number,
  max: number
) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    const ip = req.ip;
    
    // Bloquear IPs banidos
    if (BLACKLISTED_IPS.has(ip)) {
      return res.status(403).json({ error: "IP banido" });
    }
    
    // Pular rate limit para IPs confiÃ¡veis
    if (WHITELISTED_IPS.has(ip)) {
      return next();
    }
    
    // Aplicar rate limit normal
    // ... implementaÃ§Ã£o de rate limit
    next();
  };
}

app.use(rateLimitWithWhitelist(60000, 100));
```

## CabeÃ§alhos de Rate Limit ğŸ“‹

Adicione cabeÃ§alhos informativos:

```typescript
function addRateLimitHeaders(
  res: ResponseServer,
  limit: number,
  remaining: number,
  resetAt: number
) {
  res.setHeader("X-RateLimit-Limit", limit.toString());
  res.setHeader("X-RateLimit-Remaining", remaining.toString());
  res.setHeader("X-RateLimit-Reset", resetAt.toString());
  res.setHeader("Retry-After", Math.ceil((resetAt - Date.now()) / 1000).toString());
}
```

## Exemplos PrÃ¡ticos ğŸ¨

### Rate Limit para API REST

```typescript
const app = new AzuraClient({
  plugins: {
    rateLimit: {
      enabled: true,
      windowMs: 900000,  // 15 minutos
      max: 1000,
      headers: true
    }
  }
});

// Rate limit mais restrito para operaÃ§Ãµes de escrita
const writeRateLimit = rateLimitMiddleware(60000, 50);  // 50 escritas/min

app.use("/api", apiRateLimit);
app.post("*", writeRateLimit);
app.put("*", writeRateLimit);
app.delete("*", writeRateLimit);
```

### Rate Limit para AutenticaÃ§Ã£o

```typescript
const authRateLimit = rateLimitMiddleware(900000, 5);  // 5 tentativas/15min

@Controller("/auth")
export class AuthController {
  @Post("/login")
  async login(
    @Body() credentials: any,
    @Req() req: RequestServer,
    @Res() res: ResponseServer
  ) {
    // Verificar rate limit manualmente
    const key = `login:${req.ip}`;
    const limit = checkRateLimit(key, 900000, 5);
    
    if (!limit.allowed) {
      return res.status(429).json({
        error: "Muitas tentativas de login",
        retryAfter: limit.retryAfter
      });
    }
    
    // Tentar autenticar
    const user = await authenticate(credentials);
    
    if (!user) {
      return res.status(401).json({ error: "Credenciais invÃ¡lidas" });
    }
    
    res.json({ user });
  }
}
```

## Monitoramento e AnÃ¡lise ğŸ“Š

### Rastrear Atingimento de Limites

```typescript
import { Logger } from "azurajs/logger";

function createRateLimiterWithMonitoring(
  limit: number,
  windowMs: number
): RequestHandler {
  const store = new Map<string, RateLimitRecord>();
  
  return async (req, res, next) => {
    const ip = req.socket.remoteAddress || "unknown";
    const now = Date.now();
    
    let record = store.get(ip);
    
    if (!record || now > record.resetAt) {
      record = { count: 1, resetAt: now + windowMs };
      store.set(ip, record);
      await next();
      return;
    }
    
    record.count++;
    
    if (record.count > limit) {
      // Log para monitoramento
      Logger.warn("Rate limit excedido", {
        ip,
        path: req.url,
        method: req.method,
        count: record.count,
        limit,
        timestamp: new Date().toISOString()
      });
      
      res.status(429).json({
        error: "Muitas requisiÃ§Ãµes",
        retryAfter: Math.ceil((record.resetAt - now) / 1000)
      });
      return;
    }
    
    await next();
  };
}
```

### ColeÃ§Ã£o de MÃ©tricas

```typescript
interface RateLimitMetrics {
  totalRequests: number;
  blockedRequests: number;
  topOffenders: Map<string, number>;
}

const metrics: RateLimitMetrics = {
  totalRequests: 0,
  blockedRequests: 0,
  topOffenders: new Map()
};

function updateMetrics(ip: string, blocked: boolean) {
  metrics.totalRequests++;
  if (blocked) {
    metrics.blockedRequests++;
    const count = metrics.topOffenders.get(ip) || 0;
    metrics.topOffenders.set(ip, count + 1);
  }
}

// Expor endpoint de mÃ©tricas
@Get("/metrics/rate-limits")
getRateLimitMetrics(@Res() res: ResponseServer) {
  const topOffenders = Array.from(metrics.topOffenders.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);
  
  res.json({
    totalRequests: metrics.totalRequests,
    blockedRequests: metrics.blockedRequests,
    blockRate: (metrics.blockedRequests / metrics.totalRequests * 100).toFixed(2) + '%',
    topOffenders: Object.fromEntries(topOffenders)
  });
}
```

## Testando Rate Limits ğŸ§ª

### Teste Manual

```bash
# Testar com curl
for i in {1..150}; do
  curl -w "\\n%{http_code}" https://api.example.com/test
  sleep 0.1
done

# Deve ver:
# 200 (requisiÃ§Ãµes 1-100)
# 429 (requisiÃ§Ãµes 101+)
```

### Teste Automatizado

```typescript
import { describe, it, expect } from "@jest/globals";

describe("Rate Limiting", () => {
  it("deve permitir requisiÃ§Ãµes abaixo do limite", async () => {
    for (let i = 0; i < 10; i++) {
      const response = await fetch("http://localhost:3000/api/test");
      expect(response.status).toBe(200);
    }
  });
  
  it("deve bloquear requisiÃ§Ãµes acima do limite", async () => {
    // Fazer 100 requisiÃ§Ãµes para atingir limite
    for (let i = 0; i < 100; i++) {
      await fetch("http://localhost:3000/api/test");
    }
    
    // PrÃ³xima requisiÃ§Ã£o deve ser bloqueada
    const response = await fetch("http://localhost:3000/api/test");
    expect(response.status).toBe(429);
    
    // Verificar headers
    expect(response.headers.get("X-RateLimit-Remaining")).toBe("0");
    expect(response.headers.get("Retry-After")).toBeTruthy();
  });
  
  it("deve resetar apÃ³s janela de tempo", async () => {
    // Atingir limite
    for (let i = 0; i < 100; i++) {
      await fetch("http://localhost:3000/api/test");
    }
    
    // Aguardar reset da janela (ex: 60 segundos)
    await new Promise(resolve => setTimeout(resolve, 61000));
    
    // Deve funcionar novamente
    const response = await fetch("http://localhost:3000/api/test");
    expect(response.status).toBe(200);
  });
});
```

## Rate Limits DinÃ¢micos Baseados em Carga ğŸšï¸

```typescript
interface SystemLoad {
  cpu: number;
  memory: number;
}

function getSystemLoad(): SystemLoad {
  // Simplificado - use ferramentas reais de monitoramento em produÃ§Ã£o
  return {
    cpu: Math.random() * 100,
    memory: Math.random() * 100
  };
}

function createAdaptiveRateLimiter(
  baseLimit: number,
  windowMs: number
): RequestHandler {
  return async (req, res, next) => {
    const load = getSystemLoad();
    
    // Reduzir limite quando sistema estÃ¡ sob estresse
    let adjustedLimit = baseLimit;
    
    if (load.cpu > 80 || load.memory > 80) {
      adjustedLimit = Math.floor(baseLimit * 0.5);  // Reduzir para 50%
    } else if (load.cpu > 60 || load.memory > 60) {
      adjustedLimit = Math.floor(baseLimit * 0.75);  // Reduzir para 75%
    }
    
    // Aplicar rate limiting com limite ajustado
    const limiter = createRateLimiter(adjustedLimit, windowMs);
    await limiter(req, res, next);
  };
}

app.use(createAdaptiveRateLimiter(1000, 60000));
```

## Melhores PrÃ¡ticas âœ¨

<Callout type="tip">
  **Use Redis para ambientes distribuÃ­dos**: Garante limites consistentes em mÃºltiplas instÃ¢ncias
</Callout>

<Callout type="tip">
  **Diferentes limites para diferentes endpoints**: Proteja operaÃ§Ãµes sensÃ­veis com limites mais rigorosos
</Callout>

<Callout type="tip">
  **Sempre adicione cabeÃ§alhos**: Ajude clientes a entender os limites
</Callout>

<Callout type="warn">
  **Cuidado com proxies**: Use `req.ip` que considera cabeÃ§alhos X-Forwarded-For
</Callout>

<Callout type="warn">
  **NÃ£o bloqueie tudo**: Whitelist IPs internos e de monitoramento
</Callout>

## PrÃ³ximos Passos ğŸ“–

<Cards>
  <Card title="CORS" href="cors" description="Configure CORS" />
  <Card title="Middleware" href="middleware" description="Crie middleware customizado" />
  <Card title="Error Handling" href="error-handling" description="Trate erros de rate limit" />
</Cards>
