---
title: Examples
description: Practical and complete examples of AzuraJS applications
icon: BookOpen
---

# Examples üìö

Learn with practical and complete examples of real applications built with AzuraJS.

## Complete REST API üéØ

### Project Structure

```
src/
  controllers/
    UserController.ts
    PostController.ts
  models/
    User.ts
    Post.ts
  middleware/
    auth.ts
    errorHandler.ts
  config/
    database.ts
  server.ts
```

### User Model

```typescript
// models/User.ts
export interface User {
  id: string;
  name: string;
  email: string;
  password: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

export interface UpdateUserDto {
  name?: string;
  email?: string;
}
```

### User Controller

### TypeScript

```typescript
// controllers/UserController.ts
import { Controller, Get, Post, Put, Delete, Body, Param, Res } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";
import { hashPassword, comparePassword } from "../utils/crypto";

@Controller("/api/users")
export class UserController {
  @Get()
  async getAllUsers() {
    const users = await db.query("SELECT id, name, email, created_at FROM users");
    return { users };
  }

  @Get("/:id")
  async getUser(@Param("id") id: string) {
    const user = await db.query(
      "SELECT id, name, email, created_at FROM users WHERE id = $1",
      [id]
    );
    
    if (!user) {
      throw new HttpError(404, "User not found");
    }
    
    return { user };
  }

  @Post()
  async createUser(@Body() data: CreateUserDto, @Res() res: ResponseServer) {
    // Validate data
    if (!data.email || !data.password) {
      throw new HttpError(400, "Email and password are required");
    }
    
    // Check if email already exists
    const exists = await db.query("SELECT id FROM users WHERE email = $1", [data.email]);
    if (exists) {
      throw new HttpError(409, "Email is already in use");
    }
    
    // Hash password
    const hashedPassword = await hashPassword(data.password);
    
    // Create user
    const user = await db.query(
      "INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING id, name, email, created_at",
      [data.name, data.email, hashedPassword]
    );
    
    res.status(201).json({ user });
  }

  @Put("/:id")
  async updateUser(@Param("id") id: string, @Body() data: UpdateUserDto) {
    const user = await db.query(
      "UPDATE users SET name = COALESCE($1, name), email = COALESCE($2, email), updated_at = NOW() WHERE id = $3 RETURNING id, name, email",
      [data.name, data.email, id]
    );
    
    if (!user) {
      throw new HttpError(404, "User not found");
    }
    
    return { user };
  }

  @Delete("/:id")
  async deleteUser(@Param("id") id: string, @Res() res: ResponseServer) {
    const result = await db.query("DELETE FROM users WHERE id = $1", [id]);
    
    if (result.rowCount === 0) {
      throw new HttpError(404, "User not found");
    }
    
    res.status(204).end();
  }
}
```

### JavaScript

```javascript
// controllers/UserController.js
const { HttpError } = require("azurajs/http-error");
const { hashPassword } = require("../utils/crypto");

class UserController {
  async getAllUsers(req, res) {
    const users = await db.query("SELECT id, name, email, created_at FROM users");
    res.json({ users });
  }

  async getUser(req, res) {
    const { id } = req.params;
    const user = await db.query(
      "SELECT id, name, email, created_at FROM users WHERE id = $1",
      [id]
    );
    
    if (!user) {
      throw new HttpError(404, "User not found");
    }
    
    res.json({ user });
  }

  async createUser(req, res) {
    const data = req.body;
    
    // Validate data
    if (!data.email || !data.password) {
      throw new HttpError(400, "Email and password are required");
    }
    
    // Check if email already exists
    const exists = await db.query("SELECT id FROM users WHERE email = $1", [data.email]);
    if (exists) {
      throw new HttpError(409, "Email is already in use");
    }
    
    // Hash password
    const hashedPassword = await hashPassword(data.password);
    
    // Create user
    const user = await db.query(
      "INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING id, name, email, created_at",
      [data.name, data.email, hashedPassword]
    );
    
    res.status(201).json({ user });
  }

  async updateUser(req, res) {
    const { id } = req.params;
    const data = req.body;
    
    const user = await db.query(
      "UPDATE users SET name = COALESCE($1, name), email = COALESCE($2, email), updated_at = NOW() WHERE id = $3 RETURNING id, name, email",
      [data.name, data.email, id]
    );
    
    if (!user) {
      throw new HttpError(404, "User not found");
    }
    
    res.json({ user });
  }

  async deleteUser(req, res) {
    const { id } = req.params;
    const result = await db.query("DELETE FROM users WHERE id = $1", [id]);
    
    if (result.rowCount === 0) {
      throw new HttpError(404, "User not found");
    }
    
    res.status(204).end();
  }
}

// Register routes
const controller = new UserController();
app.get("/api/users", controller.getAllUsers);
app.get("/api/users/:id", controller.getUser);
app.post("/api/users", controller.createUser);
app.put("/api/users/:id", controller.updateUser);
app.delete("/api/users/:id", controller.deleteUser);

module.exports = { UserController };
```

## JWT Authentication üîê

### Auth Controller

```typescript
// controllers/AuthController.ts
import { Controller, Post, Get, Body, Headers, Res } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";
import type { ResponseServer } from "azurajs/types";
import { sign, verify } from "jsonwebtoken";

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";

@Controller("/auth")
export class AuthController {
  @Post("/register")
  async register(@Body() data: CreateUserDto, @Res() res: ResponseServer) {
    // Validate data
    if (!data.email || !data.password) {
      throw new HttpError(400, "Email and password are required");
    }
    
    // Check if user exists
    const exists = await db.query("SELECT id FROM users WHERE email = $1", [data.email]);
    if (exists) {
      throw new HttpError(409, "Email is already in use");
    }
    
    // Hash password
    const hashedPassword = await hashPassword(data.password);
    
    // Create user
    const user = await db.query(
      "INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING id, name, email",
      [data.name, data.email, hashedPassword]
    );
    
    // Generate JWT
    const token = sign(
      { userId: user.id, email: user.email },
      JWT_SECRET,
      { expiresIn: "7d" }
    );
    
    res.status(201).json({ user, token });
  }

  @Post("/login")
  async login(@Body() credentials: { email: string; password: string }) {
    // Find user
    const user = await db.query(
      "SELECT id, name, email, password FROM users WHERE email = $1",
      [credentials.email]
    );
    
    if (!user) {
      throw new HttpError(401, "Invalid credentials");
    }
    
    // Verify password
    const valid = await comparePassword(credentials.password, user.password);
    if (!valid) {
      throw new HttpError(401, "Invalid credentials");
    }
    
    // Generate JWT
    const token = sign(
      { userId: user.id, email: user.email },
      JWT_SECRET,
      { expiresIn: "7d" }
    );
    
    return {
      user: { id: user.id, name: user.name, email: user.email },
      token
    };
  }

  @Get("/me")
  async getCurrentUser(@Headers("authorization") auth: string) {
    if (!auth) {
      throw new HttpError(401, "Token not provided");
    }
    
    const token = auth.replace("Bearer ", "");
    
    try {
      const decoded = verify(token, JWT_SECRET) as any;
      
      const user = await db.query(
        "SELECT id, name, email FROM users WHERE id = $1",
        [decoded.userId]
      );
      
      if (!user) {
        throw new HttpError(404, "User not found");
      }
      
      return { user };
    } catch (error) {
      throw new HttpError(401, "Invalid token");
    }
  }
}
```

### Auth Middleware

```typescript
// middleware/auth.ts
import { verify } from "jsonwebtoken";
import type { RequestServer, ResponseServer } from "azurajs/types";

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";

export function authMiddleware(
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const auth = req.headers.authorization;
  
  if (!auth) {
    return res.status(401).json({ error: "Token not provided" });
  }
  
  const token = auth.replace("Bearer ", "");
  
  try {
    const decoded = verify(token, JWT_SECRET) as any;
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: "Invalid token" });
  }
}
```

## File Upload üì§

```typescript
import { Controller, Post, Req, Res } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";
import type { RequestServer, ResponseServer } from "azurajs/types";
import { writeFile } from "fs/promises";
import { randomUUID } from "crypto";

@Controller("/api/uploads")
export class UploadController {
  @Post("/image")
  async uploadImage(@Req() req: RequestServer, @Res() res: ResponseServer) {
    // Check Content-Type
    const contentType = req.headers["content-type"];
    if (!contentType?.includes("multipart/form-data")) {
      throw new HttpError(400, "Content-Type must be multipart/form-data");
    }
    
    // Parse multipart data (simplified example)
    const boundary = contentType.split("boundary=")[1];
    const parts = parseMultipart(req.body, boundary);
    
    const file = parts.find(p => p.name === "file");
    if (!file) {
      throw new HttpError(400, "File not found");
    }
    
    // Validate file type
    if (!file.contentType.startsWith("image/")) {
      throw new HttpError(400, "Only images are allowed");
    }
    
    // Validate size (max 5MB)
    if (file.data.length > 5 * 1024 * 1024) {
      throw new HttpError(400, "File too large (max 5MB)");
    }
    
    // Save file
    const filename = `${randomUUID()}.${file.extension}`;
    const path = `./uploads/${filename}`;
    
    await writeFile(path, file.data);
    
    // Save to database
    const upload = await db.query(
      "INSERT INTO uploads (filename, original_name, size, mime_type, user_id) VALUES ($1, $2, $3, $4, $5) RETURNING *",
      [filename, file.originalName, file.data.length, file.contentType, req.user.userId]
    );
    
    res.status(201).json({
      upload: {
        id: upload.id,
        url: `/uploads/${filename}`,
        originalName: file.originalName,
        size: file.data.length
      }
    });
  }

  @Get("/:filename")
  async getFile(@Param("filename") filename: string, @Res() res: ResponseServer) {
    const upload = await db.query(
      "SELECT * FROM uploads WHERE filename = $1",
      [filename]
    );
    
    if (!upload) {
      throw new HttpError(404, "File not found");
    }
    
    const file = await readFile(`./uploads/${filename}`);
    
    res.setHeader("Content-Type", upload.mime_type);
    res.setHeader("Content-Length", file.length.toString());
    res.send(file);
  }
}
```

## WebSocket with AzuraJS üîå

```typescript
import { AzuraClient } from "azurajs";
import { WebSocketServer } from "ws";

const app = new AzuraClient();
const server = await app.listen(3000);

// Create WebSocket server
const wss = new WebSocketServer({ server });

interface Client {
  id: string;
  ws: any;
  userId?: string;
}

const clients = new Map<string, Client>();

wss.on("connection", (ws, req) => {
  const clientId = randomUUID();
  
  clients.set(clientId, { id: clientId, ws });
  
  console.log(`Client connected: ${clientId}`);
  
  ws.on("message", (data: Buffer) => {
    try {
      const message = JSON.parse(data.toString());
      
      // Authenticate
      if (message.type === "auth") {
        const token = message.token;
        const decoded = verify(token, JWT_SECRET) as any;
        
        const client = clients.get(clientId);
        if (client) {
          client.userId = decoded.userId;
          ws.send(JSON.stringify({ type: "auth", success: true }));
        }
      }
      
      // Send message
      else if (message.type === "message") {
        const client = clients.get(clientId);
        
        if (!client?.userId) {
          return ws.send(JSON.stringify({ 
            type: "error", 
            message: "Not authenticated" 
          }));
        }
        
        // Broadcast to all clients
        const payload = {
          type: "message",
          from: client.userId,
          text: message.text,
          timestamp: new Date().toISOString()
        };
        
        clients.forEach(c => {
          if (c.userId) {
            c.ws.send(JSON.stringify(payload));
          }
        });
      }
    } catch (error) {
      console.error("WebSocket error:", error);
    }
  });
  
  ws.on("close", () => {
    clients.delete(clientId);
    console.log(`Client disconnected: ${clientId}`);
  });
});
```

## Database Integration üíæ

### PostgreSQL with Prisma

```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        String   @id @default(uuid())
  title     String
  content   String
  published Boolean  @default(false)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

```typescript
// controllers/PostController.ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

@Controller("/api/posts")
export class PostController {
  @Get()
  async getPosts(@Query("published") published: string) {
    const posts = await prisma.post.findMany({
      where: published ? { published: published === "true" } : undefined,
      include: {
        author: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    
    return { posts };
  }

  @Post()
  async createPost(@Body() data: any, @Req() req: RequestServer) {
    const post = await prisma.post.create({
      data: {
        title: data.title,
        content: data.content,
        published: data.published || false,
        authorId: req.user.userId
      },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    
    return { post };
  }

  @Put("/:id")
  async updatePost(@Param("id") id: string, @Body() data: any) {
    const post = await prisma.post.update({
      where: { id },
      data: {
        title: data.title,
        content: data.content,
        published: data.published
      }
    });
    
    return { post };
  }

  @Delete("/:id")
  async deletePost(@Param("id") id: string, @Res() res: ResponseServer) {
    await prisma.post.delete({
      where: { id }
    });
    
    res.status(204).end();
  }
}
```

## Complete Production Server üöÄ

```typescript
// server.ts
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import cluster from "cluster";
import { cpus } from "os";

// Controllers
import { UserController } from "./controllers/UserController";
import { AuthController } from "./controllers/AuthController";
import { PostController } from "./controllers/PostController";
import { UploadController } from "./controllers/UploadController";

// Middleware
import { authMiddleware } from "./middleware/auth";
import { errorHandler } from "./middleware/errorHandler";
import { LoggingMiddleware } from "azurajs/middleware";

const PORT = process.env.PORT || 3000;
const numCPUs = cpus().length;

if (cluster.isPrimary && process.env.NODE_ENV === "production") {
  console.log(`üöÄ Starting ${numCPUs} workers...`);
  
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on("exit", (worker) => {
    console.log(`Worker ${worker.process.pid} died, starting new worker...`);
    cluster.fork();
  });
} else {
  const app = new AzuraClient({
    environment: process.env.NODE_ENV as any || "development",
    server: {
      port: PORT
    },
    logging: {
      level: "info"
    },
    plugins: {
      cors: {
        enabled: true,
        origin: process.env.ALLOWED_ORIGINS?.split(",") || ["http://localhost:3000"],
        credentials: true
      },
      rateLimit: {
        enabled: true,
        windowMs: 60000,
        max: 100
      }
    }
  });
  
  // Global middleware
  app.use(LoggingMiddleware);
  
  // Public routes
  applyDecorators(app, [AuthController]);
  
  // Protected routes
  app.use("/api", authMiddleware);
  applyDecorators(app, [UserController, PostController, UploadController]);
  
  // Error handler (last!)
  app.use(errorHandler);
  
  await app.listen(PORT);
  console.log(`‚úÖ Worker ${process.pid} listening on port ${PORT}`);
}
```

## API Testing üß™

```typescript
// test/api.test.ts
import { describe, it, expect } from "vitest";

const BASE_URL = "http://localhost:3000";

describe("Auth API", () => {
  let token: string;
  
  it("should register a new user", async () => {
    const response = await fetch(`${BASE_URL}/auth/register`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        name: "Test User",
        email: "test@example.com",
        password: "password123"
      })
    });
    
    const data = await response.json();
    expect(response.status).toBe(201);
    expect(data.user).toBeDefined();
    expect(data.token).toBeDefined();
    
    token = data.token;
  });
  
  it("should login", async () => {
    const response = await fetch(`${BASE_URL}/auth/login`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        email: "test@example.com",
        password: "password123"
      })
    });
    
    const data = await response.json();
    expect(response.status).toBe(200);
    expect(data.token).toBeDefined();
  });
  
  it("should get current user", async () => {
    const response = await fetch(`${BASE_URL}/auth/me`, {
      headers: {
        "Authorization": `Bearer ${token}`
      }
    });
    
    const data = await response.json();
    expect(response.status).toBe(200);
    expect(data.user.email).toBe("test@example.com");
  });
});
```

## Best Practices ‚ú®

<Callout type="tip">
  **Organize your code**: Use controllers, services, repositories
</Callout>

<Callout type="tip">
  **Validate input**: Always validate client data
</Callout>

<Callout type="tip">
  **Use TypeScript**: Take advantage of type safety
</Callout>

<Callout type="tip">
  **Implement authentication**: Protect sensitive routes
</Callout>

<Callout type="tip">
  **Handle errors**: Use global error handlers
</Callout>

<Callout type="tip">
  **Log everything**: Makes debugging easier
</Callout>

<Callout type="tip">
  **Test your API**: Write automated tests
</Callout>

## Next Steps üìñ

<Cards>
  <Card title="GitHub" href="https://github.com/0xviny/azurajs" description="Contribute on GitHub" />
  <Card title="NPM" href="https://www.npmjs.com/package/azurajs" description="Install via NPM" />
  <Card title="Documentation" href="/docs" description="Explore the full documentation" />
</Cards>
  const { q } = req.query;
  
  if (!q) {
    throw new HttpError(400, "Search query required");
  }
  
  const results = posts.filter(
    (p) =>
      p.title.toLowerCase().includes(q.toLowerCase()) ||
      p.content.toLowerCase().includes(q.toLowerCase())
  );
  
  res.json({ posts: results, query: q });
});

// Start server
await app.listen();
```

## Authentication Example üîê

```typescript title="src/controllers/AuthController.ts"
import { AzuraClient } from "azurajs";
import { applyDecorators, Controller, Post, Get, Body, Headers, Res } from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";
import { HttpError } from "azurajs/http-error";
import { sign, verify } from "jsonwebtoken";
import { hash, compare } from "bcrypt";

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";

interface User {
  id: number;
  email: string;
  password: string;
  name: string;
}

const users: User[] = [];

@Controller("/api/auth")
export class AuthController {
  @Post("/register")
  async register(@Body() data: any, @Res() res: ResponseServer) {
    if (!data.email || !data.password || !data.name) {
      throw new HttpError(400, "Missing required fields");
    }
    
    // Check if user exists
    if (users.find((u) => u.email === data.email)) {
      throw new HttpError(409, "User already exists");
    }
    
    // Hash password
    const hashedPassword = await hash(data.password, 10);
    
    const user: User = {
      id: Date.now(),
      email: data.email,
      password: hashedPassword,
      name: data.name,
    };
    
    users.push(user);
    
    // Generate token
    const token = sign({ id: user.id, email: user.email }, JWT_SECRET, {
      expiresIn: "24h",
    });
    
    res.status(201).json({
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
      },
    });
  }

  @Post("/login")
  async login(@Body() data: any, @Res() res: ResponseServer) {
    if (!data.email || !data.password) {
      throw new HttpError(400, "Email and password required");
    }
    
    const user = users.find((u) => u.email === data.email);
    
    if (!user) {
      throw new HttpError(401, "Invalid credentials");
    }
    
    const valid = await compare(data.password, user.password);
    
    if (!valid) {
      throw new HttpError(401, "Invalid credentials");
    }
    
    const token = sign({ id: user.id, email: user.email }, JWT_SECRET, {
      expiresIn: "24h",
    });
    
    res.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
      },
    });
  }

  @Get("/me")
  getProfile(
    @Headers("authorization") auth: string,
    @Res() res: ResponseServer
  ) {
    if (!auth) {
      throw new HttpError(401, "No token provided");
    }
    
    const token = auth.replace("Bearer ", "");
    
    try {
      const decoded = verify(token, JWT_SECRET) as { id: number; email: string };
      const user = users.find((u) => u.id === decoded.id);
      
      if (!user) {
        throw new HttpError(404, "User not found");
      }
      
      res.json({
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
        },
      });
    } catch (error) {
      throw new HttpError(401, "Invalid token");
    }
  }
}
```

## File Upload Example üì§

```typescript title="src/controllers/UploadController.ts"
import { Controller, Post, Req, Res } from "azurajs/decorators";
import type { RequestServer, ResponseServer } from "azurajs/types";
import { writeFile, mkdir } from "fs/promises";
import { randomUUID } from "crypto";
import { join } from "path";

@Controller("/api/upload")
export class UploadController {
  @Post("/image")
  async uploadImage(@Req() req: RequestServer, @Res() res: ResponseServer) {
    const chunks: Buffer[] = [];
    
    req.on("data", (chunk) => {
      chunks.push(chunk);
    });
    
    await new Promise((resolve) => {
      req.on("end", resolve);
    });
    
    const buffer = Buffer.concat(chunks);
    const filename = `${randomUUID()}.jpg`;
    const uploadDir = join(process.cwd(), "uploads");
    
    await mkdir(uploadDir, { recursive: true });
    await writeFile(join(uploadDir, filename), buffer);
    
    res.status(201).json({
      filename,
      size: buffer.length,
      url: `/uploads/${filename}`,
    });
  }
}
```

## WebSocket Example üîå

```typescript title="src/index.ts"
import { AzuraClient } from "azurajs";
import { WebSocketServer } from "ws";

const app = new AzuraClient();

// HTTP routes...

const server = await app.listen(3000);

// Add WebSocket server
const wss = new WebSocketServer({ server });

wss.on("connection", (ws) => {
  console.log("Client connected");
  
  ws.on("message", (data) => {
    console.log("Received:", data.toString());
    
    // Broadcast to all clients
    wss.clients.forEach((client) => {
      if (client.readyState === 1) {
        client.send(data);
      }
    });
  });
  
  ws.on("close", () => {
    console.log("Client disconnected");
  });
});
```

## Database Integration Example üóÑÔ∏è

```typescript title="src/services/DatabaseService.ts"
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DB_HOST,
  port: 5432,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
});

export class UserService {
  async findAll() {
    const result = await pool.query("SELECT * FROM users");
    return result.rows;
  }
  
  async findById(id: number) {
    const result = await pool.query("SELECT * FROM users WHERE id = $1", [id]);
    return result.rows[0];
  }
  
  async create(data: { name: string; email: string }) {
    const result = await pool.query(
      "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *",
      [data.name, data.email]
    );
    return result.rows[0];
  }
  
  async update(id: number, data: Partial<{ name: string; email: string }>) {
    const fields = [];
    const values = [];
    let paramIndex = 1;
    
    if (data.name) {
      fields.push(`name = $${paramIndex++}`);
      values.push(data.name);
    }
    
    if (data.email) {
      fields.push(`email = $${paramIndex++}`);
      values.push(data.email);
    }
    
    values.push(id);
    
    const result = await pool.query(
      `UPDATE users SET ${fields.join(", ")} WHERE id = $${paramIndex} RETURNING *`,
      values
    );
    
    return result.rows[0];
  }
  
  async delete(id: number) {
    await pool.query("DELETE FROM users WHERE id = $1", [id]);
  }
}
```

## Complete Production Example üöÄ

Check the full example in the [examples folder](https://github.com/0xviny/azurajs/tree/main/examples) of the repository.

## Next Steps üìñ

<Cards>
  <Card title="Quick Start" href="quick-start" description="Start building your own API" />
  <Card title="Controllers" href="controllers" description="Learn more about controllers" />
  <Card title="Validation" href="validation" description="Add validation to your API" />
  <Card title="GitHub Repository" href="https://github.com/0xviny/azurajs" description="Explore the source code" />
</Cards>
