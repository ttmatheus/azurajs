---
title: Routing
description: Learn about route patterns, parameters, and matching
icon: Route
---

# Routing ğŸ›£ï¸

AzuraJS provides a powerful and flexible routing system. You can use decorators with TypeScript or the functional API with JavaScript.

## HTTP Methods Quick Reference ğŸ“‹

| Method | Purpose | Has Body | Idempotent | Safe | Common Use |
|--------|---------|----------|------------|------|------------|
| GET | Read resource | âŒ | âœ… | âœ… | Fetch data, list items |
| POST | Create resource | âœ… | âŒ | âŒ | Create records, submit forms |
| PUT | Update (full) | âœ… | âœ… | âŒ | Replace entire resource |
| PATCH | Update (partial) | âœ… | âŒ | âŒ | Modify specific fields |
| DELETE | Remove resource | âŒ | âœ… | âŒ | Delete records |
| HEAD | Headers only | âŒ | âœ… | âœ… | Check existence, metadata |
| OPTIONS | Allowed methods | âŒ | âœ… | âœ… | CORS preflight |

<Callout type="info">
  **Idempotent** means the same request can be made multiple times without changing the result beyond the first request.
</Callout>

<Callout type="info">
  **Safe** means the method doesn't modify data on the server.
</Callout>

## Route Basics ğŸ“

### TypeScript

Routes are defined using HTTP method decorators on controller methods:

```typescript
import { Controller, Get, Param } from "azurajs/decorators";

@Controller("/api/users")
export class UserController {
  @Get()  // Matches: GET /api/users
  getAllUsers() {}

  @Get("/:id")  // Matches: GET /api/users/123
  getUser(@Param("id") id: string) {}
}
```

### JavaScript

Routes are defined using functional methods:

```javascript
const { AzuraClient } = require("azurajs");

const app = new AzuraClient();

app.get("/api/users", ({ req, res }) => {
  // GET /api/users
  res.json({ users: [] });
});

app.get("/api/users/:id", ({ req, res }) => {
  // GET /api/users/123
  const { id } = req.params;
  res.json({ id });
});
```

## Route Paths ğŸ—ºï¸

### Static Paths

#### TypeScript

```typescript
@Get("/users")  // Exact match only
getUsers() {}

@Get("/users/active")  // Exact match
getActiveUsers() {}
```

#### JavaScript

```javascript
app.get("/users", ({ req, res }) => {
  res.json({ users: [] });
});

app.get("/users/active", ({ req, res }) => {
  res.json({ activeUsers: [] });
});
```

### Dynamic Parameters

Use `:paramName` for route parameters:

#### TypeScript

```typescript
@Get("/:id")  // Matches /123, /abc, etc.
getOne(@Param("id") id: string) {}

@Get("/:userId/posts/:postId")  // Multiple parameters
getPost(
  @Param("userId") userId: string,
  @Param("postId") postId: string
) {}
```

#### JavaScript

```javascript
app.get("/:id", ({ req, res }) => {
  const { id } = req.params;  // Matches /123, /abc, etc.
  res.json({ id });
});

app.get("/:userId/posts/:postId", ({ req, res }) => {
  const { userId, postId } = req.params;
  res.json({ userId, postId });
});
```

### Query Parameters

Query parameters are not part of the route path:

#### TypeScript

```typescript
import { Get, Query } from "azurajs/decorators";

// Route: GET /search
// URL: GET /search?q=john&limit=10
@Get("/search")
search(@Query("q") query: string, @Query("limit") limit: string) {
  return { query, limit };
}
```

#### JavaScript

```javascript
// Route: GET /search
// URL: GET /search?q=john&limit=10
app.get("/search", ({ req, res }) => {
  const { q, limit } = req.query;
  res.json({ query: q, limit });
});
```

## Route Patterns ğŸ¨

### Combining Static and Dynamic

```typescript
@Controller("/api")
export class ApiController {
  @Get("/users/:id/profile")  // GET /api/users/123/profile
  getProfile(@Param("id") id: string) {}

  @Get("/posts/:id/comments/:commentId")  // Multiple params
  getComment(
    @Param("id") postId: string,
    @Param("commentId") commentId: string
  ) {}
}
```

### Nested Routes

```typescript
import { Controller, Get, Param } from "azurajs/decorators";

@Controller("/api/organizations")
export class OrgController {
  @Get("/:orgId/teams/:teamId/members")
  getMembers(
    @Param("orgId") orgId: string,
    @Param("teamId") teamId: string
  ) {
    return { orgId, teamId };
  }
}
```

## Route Matching Rules ğŸ¯

### Exact Matching

```typescript
// Route: /users
GET /users        // âœ… Matches
GET /users/       // âŒ Doesn't match (trailing slash)
GET /users/123    // âŒ Doesn't match
```

### Parameter Matching

Route parameters match any value in that segment:

```typescript
// Route: /users/:id
GET /users/123         // âœ… Matches (id = "123")
GET /users/abc         // âœ… Matches (id = "abc")
GET /users/abc-123     // âœ… Matches (id = "abc-123")
GET /users/123/posts   // âŒ Doesn't match
GET /users/            // âŒ Doesn't match (empty segment)
```

### Multiple Parameters

```typescript
// Route: /:category/:id
GET /books/123         // âœ… Matches (category="books", id="123")
GET /users/john        // âœ… Matches (category="users", id="john")
GET /books/123/pages   // âŒ Doesn't match (extra segment)
```

### Path Precedence Rules

1. **Static paths** have highest priority
2. **Paths with parameters** are checked next
3. **Longer paths** are matched before shorter ones
4. **Registration order** matters for same-length routes

```typescript
@Controller("/api")
export class ApiController {
  // Priority order (highest to lowest):
  @Get("/users/admin")         // 1. Static - exact match
  @Get("/users/me")            // 2. Static - exact match
  @Get("/users/:id/profile")   // 3. Longer path with param
  @Get("/users/:id")           // 4. Shorter path with param
}
```

## Wildcards and Advanced Patterns ğŸŒŸ

### Wildcard Routes

Catch-all routes for unmatched requests:

```typescript
@Controller()
export class CatchAllController {
  // Handles all unmatched routes
  @Get("*")
  notFound(@Req() req: RequestServer, @Res() res: ResponseServer) {
    res.status(404).json({
      error: "Not Found",
      path: req.url,
      message: `Route ${req.url} does not exist`
    });
  }
}
```

### File Extension Matching

```typescript
// Match routes with file extensions
@Get("/images/:filename")
serveImage(@Param("filename") filename: string) {
  // filename can be: "avatar.jpg", "logo.png", etc.
  return { filename };
}

// Extract extension in handler
@Get("/files/:name")
serveFile(@Param("name") name: string) {
  const ext = name.split('.').pop();
  return { name, extension: ext };
}
```

### Optional Segments Pattern

```typescript
// To make segments optional, create multiple routes
@Get("/posts")
@Get("/posts/:id")
getPosts(@Param("id") id?: string) {
  if (id) {
    return { post: getPostById(id) };
  }
  return { posts: getAllPosts() };
}
```

### Regex-Like Patterns

```typescript
// Handle versioned APIs
@Controller("/api/v1")
export class V1Controller {}

@Controller("/api/v2")
export class V2Controller {}

// Numeric IDs only (validate in handler)
@Get("/users/:id")
getUser(@Param("id") id: string) {
  if (!/^\d+$/.test(id)) {
    throw new HttpError(400, "ID must be numeric");
  }
  return { id };
}
```

## Query String Handling ğŸ”

### Basic Query Parameters

```typescript
// URL: /search?q=azura&limit=10&sort=desc
@Get("/search")
search(@Query() query: Record<string, string>) {
  // query = { q: "azura", limit: "10", sort: "desc" }
  return { query };
}
```

### Individual Query Parameters

```typescript
@Get("/search")
search(
  @Query("q") searchTerm: string,
  @Query("limit") limit: string,
  @Query("offset") offset: string
) {
  return {
    searchTerm,
    limit: Number(limit) || 10,
    offset: Number(offset) || 0
  };
}
```

### Default Values for Query Parameters

```typescript
@Get("/posts")
getPosts(
  @Query("page") page?: string,
  @Query("limit") limit?: string
) {
  const pageNum = Number(page) || 1;
  const limitNum = Number(limit) || 20;
  
  return {
    posts: [],
    page: pageNum,
    limit: limitNum
  };
}
```

### Array Query Parameters

```typescript
// URL: /filter?tags=javascript&tags=typescript&tags=nodejs
@Get("/filter")
filter(@Query() query: Record<string, any>) {
  // Handle array parameters
  const tags = Array.isArray(query.tags) 
    ? query.tags 
    : [query.tags];
  
  return { tags };
}
```

### Complex Query Objects

```typescript
// URL: /search?filter[status]=active&filter[role]=admin&sort[by]=date&sort[order]=desc
@Get("/search")
search(@Query() query: Record<string, any>) {
  // Parse nested query parameters
  const filters = {
    status: query['filter[status]'],
    role: query['filter[role]']
  };
  
  const sorting = {
    by: query['sort[by]'],
    order: query['sort[order]']
  };
  
  return { filters, sorting };
}
```

### Boolean Query Parameters

```typescript
// URL: /products?available=true&featured=false
@Get("/products")
getProducts(
  @Query("available") available?: string,
  @Query("featured") featured?: string
) {
  const isAvailable = available === 'true';
  const isFeatured = featured === 'true';
  
  return {
    available: isAvailable,
    featured: isFeatured
  };
}
```

## Route Priority âš¡

Routes are matched in the order they're registered. More specific routes should be defined first:

```typescript
@Controller("/api/users")
export class UserController {
  // âœ… Correct order
  @Get("/me")  // Specific route first
  getCurrentUser() {}

  @Get("/:id")  // Generic route after
  getUser(@Param("id") id: string) {}

  // âŒ Wrong order
  @Get("/:id")  // This would match /me
  getUser2(@Param("id") id: string) {}

  @Get("/me")  // Never reached!
  getCurrentUser2() {}
}
```

## HTTP Methods ğŸ”§

All standard HTTP methods are supported:

### TypeScript

```typescript
@Controller("/api/posts")
export class PostController {
  @Get()  // Read all
  getAll() {}

  @Get("/:id")  // Read one
  getOne(@Param("id") id: string) {}

  @Post()  // Create
  create(@Body() data: any) {}

  @Put("/:id")  // Update (full)
  update(@Param("id") id: string, @Body() data: any) {}

  @Patch("/:id")  // Update (partial)
  patch(@Param("id") id: string, @Body() data: any) {}

  @Delete("/:id")  // Delete
  remove(@Param("id") id: string) {}

  @Head("/:id")  // Check existence
  exists(@Param("id") id: string, @Res() res: ResponseServer) {
    res.status(200).end();
  }

  @Options()  // CORS preflight
  options(@Res() res: ResponseServer) {
    res.set("Allow", "GET, POST").end();
  }
}
```

### JavaScript

```javascript
// Read all
app.get("/api/posts", ({ req, res }) => {
  res.json({ posts: [] });
});

// Read one
app.get("/api/posts/:id", ({ req, res }) => {
  const { id } = req.params;
  res.json({ id });
});

// Create
app.post("/api/posts", ({ req, res }) => {
  const data = req.body;
  res.status(201).json({ data });
});

// Update (full)
app.put("/api/posts/:id", ({ req, res }) => {
  const { id } = req.params;
  const data = req.body;
  res.json({ id, data });
});

// Update (partial)
app.patch("/api/posts/:id", ({ req, res }) => {
  const { id } = req.params;
  const data = req.body;
  res.json({ id, data });
});

// Delete
app.delete("/api/posts/:id", ({ req, res }) => {
  const { id } = req.params;
  res.status(204).send();
});

// Check existence
app.head("/api/posts/:id", ({ req, res }) => {
  res.status(200).end();
});

// CORS preflight
app.options("/api/posts", ({ req, res }) => {
  res.set("Allow", "GET, POST").end();
});
```

## Programmatic Routes ğŸ”¨

You can also define routes programmatically without decorators:

```typescript
const app = new AzuraClient();

app.get("/api/health", ({ req, res }) => {
  res.json({ status: "ok" });
});

app.post("/api/webhook", ({ req, res }) => {
  console.log("Webhook received:", req.body);
  res.status(200).send("OK");
});

app.put("/api/items/:id", ({ req, res }) => {
  res.json({ id: req.params.id });
});
```

## Route Helpers ğŸ› ï¸

### Multiple Routes per Method

```typescript
// Not directly supported, but you can create a wrapper
@Controller("/api/posts")
export class PostController {
  private getPostsLogic() {
    return { posts: [] };
  }

  @Get()
  getPosts() {
    return this.getPostsLogic();
  }

  @Get("/all")
  getAllPosts() {
    return this.getPostsLogic();
  }
}
```

### Route Groups

Use controllers to group related routes:

```typescript
// Auth routes
@Controller("/auth")
export class AuthController {
  @Post("/login")
  login() {}

  @Post("/register")
  register() {}

  @Post("/logout")
  logout() {}
}

// Public API routes
@Controller("/api/public")
export class PublicController {}

// Admin routes
@Controller("/api/admin")
export class AdminController {}
```

## Router with Prefix ğŸ¯

AzuraJS allows you to create modular routers and mount them with specific prefixes, making it easier to organize routes in larger applications.

### Basic Example

```javascript
const { AzuraClient, Router } = require('azurajs');

// Create modular routers
const aboutRouter = new Router();
aboutRouter.add('GET', '/', ({ req, res }) => {
  res.end('About Home');
});
aboutRouter.add('GET', '/team', ({ req, res }) => {
  res.end('Our Team');
});

const apiRouter = new Router();
apiRouter.add('GET', '/', ({ req, res }) => {
  res.json({ message: 'API Home' });
});
apiRouter.add('GET', '/users', ({ req, res }) => {
  res.json({ users: [] });
});

// Mount routers with prefixes
const app = new AzuraClient();
app.use('/about', aboutRouter);
app.use('/api', apiRouter);

app.listen(3000);
```

### Available Routes

- `GET /about` â†’ "About Home"
- `GET /about/team` â†’ "Our Team"
- `GET /api` â†’ JSON with message
- `GET /api/users` â†’ JSON with user list

### Benefits

- **Modularity**: Organize related routes into separate modules
- **Reusability**: Use the same router in different applications
- **Maintainability**: Easy to find and modify specific routes
- **Scalability**: Add new modules without modifying existing code

### Complete Example

See the complete example at [examples/servers/router/prefix.js](https://github.com/azurajsjs/azurajs/tree/main/examples/servers/router/prefix.js)

## RESTful Routing ğŸ¯

Follow REST conventions for resource-based APIs:

```typescript
@Controller("/api/users")
export class UserController {
  @Get()  // GET /api/users - List all users
  index() {}

  @Post()  // POST /api/users - Create user
  store(@Body() data: any) {}

  @Get("/:id")  // GET /api/users/:id - Get one user
  show(@Param("id") id: string) {}

  @Put("/:id")  // PUT /api/users/:id - Update user
  update(@Param("id") id: string, @Body() data: any) {}

  @Delete("/:id")  // DELETE /api/users/:id - Delete user
  destroy(@Param("id") id: string) {}
}
```

## Route Testing ğŸ§ª

Test your routes:

```typescript
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();
applyDecorators(app, [UserController]);

// Start server
await app.listen(3000);

// Test endpoints
const response = await fetch("http://localhost:3000/api/users/123");
const data = await response.json();
console.log(data);
```

## Common Use Cases ğŸ’¡

### Pagination Pattern

```typescript
@Get("/posts")
getPosts(
  @Query("page") page?: string,
  @Query("limit") limit?: string
) {
  const pageNum = Math.max(1, Number(page) || 1);
  const limitNum = Math.min(100, Number(limit) || 20);
  
  const offset = (pageNum - 1) * limitNum;
  const posts = getPostsFromDB(offset, limitNum);
  const total = getTotalPosts();
  
  return {
    data: posts,
    pagination: {
      page: pageNum,
      limit: limitNum,
      total,
      totalPages: Math.ceil(total / limitNum)
    }
  };
}
```

### Search and Filter Pattern

```typescript
@Get("/products/search")
searchProducts(
  @Query("q") query?: string,
  @Query("category") category?: string,
  @Query("minPrice") minPrice?: string,
  @Query("maxPrice") maxPrice?: string,
  @Query("sort") sort?: string
) {
  const filters = {
    query: query || '',
    category: category || 'all',
    priceRange: {
      min: Number(minPrice) || 0,
      max: Number(maxPrice) || Infinity
    },
    sortBy: sort || 'relevance'
  };
  
  const products = searchProductsDB(filters);
  return { products, filters };
}
```

### File Upload Route

```typescript
@Post("/upload")
async uploadFile(
  @Req() req: RequestServer,
  @Res() res: ResponseServer
) {
  const files = await parseMultipartForm(req);
  
  return res.json({
    message: "Files uploaded",
    files: files.map(f => ({
      name: f.name,
      size: f.size,
      url: `/uploads/${f.id}`
    }))
  });
}
```

### API Versioning Pattern

```typescript
// Version 1
@Controller("/api/v1/users")
export class UsersV1Controller {
  @Get()
  getUsers() {
    return { version: 1, users: [] };
  }
}

// Version 2 with new features
@Controller("/api/v2/users")
export class UsersV2Controller {
  @Get()
  getUsers(@Query("include") include?: string) {
    return {
      version: 2,
      users: [],
      included: include ? parseIncludes(include) : []
    };
  }
}
```

### Soft Delete Pattern

```typescript
@Delete("/:id")
deleteUser(
  @Param("id") id: string,
  @Query("permanent") permanent?: string
) {
  if (permanent === 'true') {
    // Hard delete
    permanentlyDeleteUser(id);
    return { message: "User permanently deleted" };
  }
  
  // Soft delete
  softDeleteUser(id);
  return { message: "User deleted (recoverable)" };
}
```

### Bulk Operations Pattern

```typescript
@Post("/bulk")
bulkCreate(@Body() items: any[]) {
  if (!Array.isArray(items)) {
    throw new HttpError(400, "Expected array of items");
  }
  
  const created = items.map(item => createItem(item));
  return { created: created.length, items: created };
}

@Delete("/bulk")
bulkDelete(@Body() ids: string[]) {
  if (!Array.isArray(ids)) {
    throw new HttpError(400, "Expected array of IDs");
  }
  
  const deleted = ids.filter(id => deleteItem(id));
  return { deleted: deleted.length, ids: deleted };
}
```

## Route Organization Best Practices âœ¨

### 1. Consistent Naming Conventions

```typescript
// âœ… Good: RESTful conventions
@Controller("/api/articles")
export class ArticleController {
  @Get()           // GET /api/articles - index/list
  @Post()          // POST /api/articles - store/create
  @Get("/:id")     // GET /api/articles/:id - show/read
  @Put("/:id")     // PUT /api/articles/:id - update/replace
  @Patch("/:id")   // PATCH /api/articles/:id - partial update
  @Delete("/:id")  // DELETE /api/articles/:id - destroy/delete
}

// âŒ Bad: Inconsistent naming
@Get("/getArticle/:id")     // Don't include method in path
@Post("/article/new")        // Use plural nouns
@Delete("/removeArticle")    // Don't use verbs in RESTful paths
```

### 2. Use Plural Resource Names

```typescript
// âœ… Good
/api/users
/api/posts
/api/comments

// âŒ Bad
/api/user
/api/post
/api/comment
```

### 3. Keep Routes Flat

```typescript
// âœ… Good: Max 2-3 levels
/api/users/:userId/posts
/api/posts/:postId/comments

// âŒ Bad: Too deeply nested
/api/organizations/:orgId/departments/:deptId/teams/:teamId/members/:memberId/tasks

// âœ… Better: Use query parameters or separate endpoints
/api/tasks?memberId=123&teamId=456
/api/members/:memberId/tasks
```

### 4. Group Related Routes

```typescript
// Group by resource
@Controller("/api/auth")
export class AuthController {
  @Post("/login")
  @Post("/register")
  @Post("/logout")
  @Post("/refresh")
  @Get("/me")
}

@Controller("/api/users")
export class UserController {
  @Get()           // List
  @Post()          // Create
  @Get("/:id")     // Read
  @Put("/:id")     // Update
  @Delete("/:id")  // Delete
}
```

### 5. Specific Routes First

```typescript
@Controller("/api/users")
export class UserController {
  // âœ… Correct order
  @Get("/me")          // Most specific
  @Get("/active")
  @Get("/search")
  @Get("/:id")         // Most generic
  
  // âŒ Wrong order
  @Get("/:id")         // This catches /me, /active, /search!
  @Get("/me")          // Never reached
  @Get("/active")      // Never reached
}
```

### 6. Use Sub-controllers for Complex Resources

```typescript
// Main resource
@Controller("/api/posts")
export class PostController {}

// Sub-resources
@Controller("/api/posts/:postId/comments")
export class PostCommentController {
  @Get()
  getComments(@Param("postId") postId: string) {}
  
  @Post()
  createComment(@Param("postId") postId: string) {}
}

@Controller("/api/posts/:postId/likes")
export class PostLikeController {}
```

## Performance Tips âš¡

### 1. Route Registration Order

Register most frequently accessed routes first:

```typescript
// âœ… Good: Most accessed routes first
@Get("/health")      // Health check (most frequent)
@Get("/api/users")   // Common API endpoint
@Get("/:slug")       // Catch-all (least frequent)
```

### 2. Avoid Complex Route Patterns

```typescript
// âœ… Fast: Simple patterns
@Get("/users/:id")
@Get("/posts/:postId/comments/:commentId")

// âŒ Slower: Complex validation in routes
@Get("/users/:id")   // Don't validate ID format in route
getUser(@Param("id") id: string) {
  // Validate here instead
  if (!/^\d+$/.test(id)) {
    throw new HttpError(400, "Invalid ID");
  }
}
```

### 3. Use Static Routes When Possible

```typescript
// âœ… Faster: Static routes
@Get("/api/status")
@Get("/api/health")
@Get("/api/version")

// âŒ Slower: Everything dynamic
@Get("/api/:action")
handleAction(@Param("action") action: string) {
  switch (action) {
    case 'status': return getStatus();
    case 'health': return getHealth();
    // ...
  }
}
```

### 4. Limit Parameter Extraction

```typescript
// âœ… Good: Only extract what you need
@Get("/:id")
getUser(@Param("id") id: string) {}

// âŒ Less efficient: Extract everything
@Get("/:id")
getUser(
  @Param() params: any,
  @Query() query: any,
  @Headers() headers: any,
  @Req() req: any
) {
  // Only using params.id
}
```

### 5. Cache Route Metadata

```typescript
// Use decorators efficiently
const commonMetadata = { /* ... */ };

@Controller("/api/cached")
export class CachedController {
  @Get("/data")
  @Cache(60) // Cache for 60 seconds
  getData() {
    return expensiveOperation();
  }
}
```

## Troubleshooting Routes ğŸ”§

### Route Not Matching

**Problem**: Route doesn't match expected URLs

```typescript
// âŒ Problem
@Get("/users/:id")      // Expects: /users/123
getUser() {}            // But URL is: /api/users/123

// âœ… Solution: Check controller prefix
@Controller("/api")     // Add missing prefix
export class UserController {
  @Get("/users/:id")    // Now matches: /api/users/123
  getUser() {}
}
```

### Parameters Not Extracted

**Problem**: Parameters are undefined

```typescript
// âŒ Problem
@Get("/users/:userId")                 // Route has :userId
getUser(@Param("id") id: string) {}    // But decorator uses "id"

// âœ… Solution: Match parameter names
@Get("/users/:userId")
getUser(@Param("userId") userId: string) {}

// Or
@Get("/users/:id")
getUser(@Param("id") id: string) {}
```

### 404 for Valid Routes

**Problem**: Getting 404 for routes that should exist

```typescript
// Check these issues:

// 1. Controller not registered
const app = new AzuraClient();
applyDecorators(app, [UserController]); // âœ… Don't forget this

// 2. Wrong HTTP method
GET /api/users     // âœ… Defined
POST /api/users    // âŒ Not defined

// 3. Route order
@Get("/:id")       // âŒ This catches /me
@Get("/me")        // âŒ Never reached
```

### Query Parameters Not Working

**Problem**: Query params are undefined

```typescript
// âŒ Problem: Using wrong decorator
@Get("/search")
search(@Param("q") query: string) {}  // Param is for :param, not ?q=

// âœ… Solution: Use Query decorator
@Get("/search")
search(@Query("q") query: string) {}  // Now works with ?q=value
```

### Route Conflicts

**Problem**: Two routes match the same URL

```typescript
// âŒ Problem: Ambiguous routes
@Controller("/api")
export class Controller1 {
  @Get("/users/:id")
  getUser() {}        // Matches /api/users/123
}

@Controller("/api")
export class Controller2 {
  @Get("/users/:name")
  getUserByName() {}  // Also matches /api/users/123 !
}

// âœ… Solution: Use distinct paths
@Get("/users/by-name/:name")  // /api/users/by-name/john
getUserByName() {}

@Get("/users/:id")             // /api/users/123
getUser() {}
```

### Trailing Slash Issues

**Problem**: Route works with or without trailing slash inconsistently

```typescript
// By default, trailing slashes matter
@Get("/users")     // Matches: /users
                   // Doesn't match: /users/

// To handle both
function normalizeRoutes(app: AzuraClient) {
  app.use(({ req, res, next }) => {
    if (req.url !== '/' && req.url.endsWith('/')) {
      req.url = req.url.slice(0, -1);
    }
    next();
  });
}
```

### Parameters Contains Special Characters

**Problem**: Route params with special characters break

```typescript
// URL: /users/john@example.com
@Get("/users/:email")
getUser(@Param("email") email: string) {
  // email might be cut off at @
}

// âœ… Solution: URL encode parameters
// Client side:
const email = encodeURIComponent('john@example.com');
fetch(`/users/${email}`);

// Server side:
@Get("/users/:email")
getUser(@Param("email") email: string) {
  const decoded = decodeURIComponent(email);
  return { email: decoded };
}
```

### Debugging Tips

```typescript
// Log all registered routes at startup
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";

const app = new AzuraClient();

// Add debug middleware
app.use(({ req, res, next }) => {
  console.log(`${req.method} ${req.url}`);
  console.log('Params:', req.params);
  console.log('Query:', req.query);
  next();
});

applyDecorators(app, [UserController, PostController]);

app.listen(3000, () => {
  console.log('Server started');
  console.log('Test routes:');
  console.log('- GET http://localhost:3000/api/users');
  console.log('- GET http://localhost:3000/api/users/123');
});
```

## Next Steps ğŸ“–

<Cards>
  <Card title="Decorators" href="decorators" description="Master all decorators" />
  <Card title="Middleware" href="middleware" description="Add middleware to routes" />
  <Card title="Validation" href="validation" description="Validate route parameters" />
</Cards>
