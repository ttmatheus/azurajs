---
title: Error Handling
description: Trate erros de forma elegante no AzuraJS
icon: TriangleAlert
---

# Error Handling üö®

AzuraJS fornece ferramentas poderosas para tratar erros de forma consistente e elegante.

## Classe HttpError üí•

Use `HttpError` para lan√ßar erros HTTP com c√≥digos de status:

### TypeScript

```typescript
import { Get, Param } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";

@Get("/:id")
getUser(@Param("id") id: string) {
  const user = findUserById(id);
  
  if (!user) {
    throw new HttpError(404, "Usu√°rio n√£o encontrado");
  }
  
  return { user };
}
```

### JavaScript

```javascript
const { HttpError } = require("azurajs/http-error");

app.get("/:id", ({ req, res }) => {
  const { id } = req.params;
  const user = findUserById(id);
  
  if (!user) {
    throw new HttpError(404, "Usu√°rio n√£o encontrado");
  }
  
  res.json({ user });
});
```

### C√≥digos de Status Comuns

```typescript
// 400 Bad Request
throw new HttpError(400, "Dados inv√°lidos");

// 401 Unauthorized
throw new HttpError(401, "N√£o autorizado");

// 403 Forbidden
throw new HttpError(403, "Acesso negado");

// 404 Not Found
throw new HttpError(404, "Recurso n√£o encontrado");

// 409 Conflict
throw new HttpError(409, "Usu√°rio j√° existe");

// 422 Unprocessable Entity
throw new HttpError(422, "Valida√ß√£o falhou");

// 500 Internal Server Error
throw new HttpError(500, "Erro interno do servidor");
```

## Middleware de Tratamento de Erros ‚öôÔ∏è

Crie um middleware global para capturar todos os erros:

```typescript
function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  console.error("Error:", error);
  
  // HttpError
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message,
      statusCode: error.statusCode
    });
  }
  
  // Erro de valida√ß√£o (Zod)
  if (error.name === "ZodError") {
    return res.status(400).json({
      error: "Valida√ß√£o falhou",
      details: error.errors
    });
  }
  
  // Erro gen√©rico
  res.status(500).json({
    error: "Erro interno do servidor",
    message: process.env.NODE_ENV === "development" ? error.message : undefined
  });
}

// Registrar por √∫ltimo
app.use(errorHandler);
```

## Try-Catch em Async Handlers üîÑ

Sempre envolva c√≥digo ass√≠ncrono em try-catch:

```typescript
@Get("/posts")
async getPosts(@Res() res: ResponseServer) {
  try {
    const posts = await fetchPostsFromDB();
    res.json({ posts });
  } catch (error) {
    console.error("Error fetching posts:", error);
    throw new HttpError(500, "Erro ao buscar posts");
  }
}
```

## Wrapper de Async Handler üéÅ

Crie um wrapper para evitar repeti√ß√£o de try-catch:

```typescript
function asyncHandler(fn: Function) {
  return async (req: RequestServer, res: ResponseServer, next: () => void) => {
    try {
      await fn(req, res, next);
    } catch (error) {
      next(error);
    }
  };
}

// Usar como middleware
app.get("/users", asyncHandler(async ({ req, res }) => {
  const users = await getUsersFromDB();
  res.json({ users });
}));
```

## Classes de Erro Customizadas üé®

Crie classes de erro espec√≠ficas para seu dom√≠nio:

```typescript
class ValidationError extends HttpError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(422, message);
    this.name = "ValidationError";
  }
}

class AuthenticationError extends HttpError {
  constructor(message = "N√£o autenticado") {
    super(401, message);
    this.name = "AuthenticationError";
  }
}

class AuthorizationError extends HttpError {
  constructor(message = "Acesso negado") {
    super(403, message);
    this.name = "AuthorizationError";
  }
}

class NotFoundError extends HttpError {
  constructor(resource: string) {
    super(404, `${resource} n√£o encontrado`);
    this.name = "NotFoundError";
  }
}

class ConflictError extends HttpError {
  constructor(message: string) {
    super(409, message);
    this.name = "ConflictError";
  }
}

// Usar nos controllers
@Get("/:id")
getUser(@Param("id") id: string) {
  const user = findUserById(id);
  
  if (!user) {
    throw new NotFoundError("Usu√°rio");
  }
  
  return { user };
}

@Post()
createUser(@Body() data: any) {
  const exists = userExists(data.email);
  
  if (exists) {
    throw new ConflictError("Email j√° est√° em uso");
  }
  
  return createUser(data);
}
```

## Tratamento de Erros de Valida√ß√£o ‚úÖ

Integre com Zod para valida√ß√£o type-safe:

```typescript
import { z } from "zod";

const CreateUserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().int().positive()
});

@Post("/users")
createUser(@Body() data: unknown, @Res() res: ResponseServer) {
  try {
    const validData = CreateUserSchema.parse(data);
    const user = saveUser(validData);
    res.status(201).json({ user });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: "Valida√ß√£o falhou",
        details: error.errors.map(e => ({
          field: e.path.join("."),
          message: e.message
        }))
      });
    }
    throw error;
  }
}
```

## Logging de Erros üìù

Log erros para an√°lise posterior:

```typescript
import { Logger } from "azurajs/logger";

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Log detalhes do erro
  Logger.error("Request error", {
    error: error.message,
    stack: error.stack,
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.headers["user-agent"],
    timestamp: new Date().toISOString()
  });
  
  // Responder cliente
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message
    });
  }
  
  res.status(500).json({
    error: "Erro interno do servidor"
  });
}

app.use(errorHandler);
```

## Rastreamento de Erros üîç

Integre com servi√ßos de rastreamento como Sentry:

```typescript
import * as Sentry from "@sentry/node";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0
});

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Enviar para Sentry
  Sentry.captureException(error, {
    extra: {
      method: req.method,
      url: req.url,
      ip: req.ip
    }
  });
  
  // Responder cliente
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message
    });
  }
  
  res.status(500).json({
    error: "Erro interno do servidor"
  });
}

app.use(errorHandler);
```

## Erros em Middleware üîå

Passe erros para o pr√≥ximo middleware usando `next()`:

```typescript
function authMiddleware(
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      throw new AuthenticationError("Token n√£o fornecido");
    }
    
    const decoded = verifyJWT(token);
    req.user = decoded;
    next();
  } catch (error) {
    next(error);  // Passar erro para error handler
  }
}

app.use(authMiddleware);
app.use(errorHandler);
```

## Erros de Banco de Dados üíæ

Trate erros espec√≠ficos de banco de dados:

```typescript
class DatabaseError extends HttpError {
  constructor(message: string, public originalError?: any) {
    super(500, message);
    this.name = "DatabaseError";
  }
}

@Get("/users")
async getUsers(@Res() res: ResponseServer) {
  try {
    const users = await db.query("SELECT * FROM users");
    res.json({ users });
  } catch (error: any) {
    // Erro de conex√£o
    if (error.code === "ECONNREFUSED") {
      throw new DatabaseError("Banco de dados indispon√≠vel", error);
    }
    
    // Erro de sintaxe SQL
    if (error.code === "42P01") {
      throw new DatabaseError("Tabela n√£o existe", error);
    }
    
    // Erro gen√©rico
    throw new DatabaseError("Erro ao consultar banco de dados", error);
  }
}
```

## Formato Consistente de Resposta de Erro üìã

Use um formato padr√£o para todas as respostas de erro:

```typescript
interface ErrorResponse {
  error: {
    message: string;
    code: string;
    statusCode: number;
    details?: any;
    timestamp: string;
    path: string;
  };
}

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  
  const response: ErrorResponse = {
    error: {
      message: error.message || "Erro interno do servidor",
      code: error.name || "INTERNAL_ERROR",
      statusCode,
      timestamp: new Date().toISOString(),
      path: req.url
    }
  };
  
  // Adicionar detalhes em desenvolvimento
  if (process.env.NODE_ENV === "development") {
    response.error.details = {
      stack: error.stack,
      ...error
    };
  }
  
  res.status(statusCode).json(response);
}
```

## Tratamento de Erros de Rede üåê

Trate erros ao fazer requisi√ß√µes externas:

```typescript
@Get("/external-data")
async getExternalData(@Res() res: ResponseServer) {
  try {
    const response = await fetch("https://api.example.com/data");
    
    if (!response.ok) {
      throw new HttpError(
        502,
        `API externa retornou ${response.status}`
      );
    }
    
    const data = await response.json();
    res.json({ data });
  } catch (error: any) {
    if (error.code === "ENOTFOUND") {
      throw new HttpError(503, "Servi√ßo externo indispon√≠vel");
    }
    
    if (error.code === "ETIMEDOUT") {
      throw new HttpError(504, "Timeout ao conectar ao servi√ßo externo");
    }
    
    throw error;
  }
}
```

## Circuit Breaker Pattern üîå

Implemente circuit breaker para falhas em cascata:

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailTime = 0;
  private state: "CLOSED" | "OPEN" | "HALF_OPEN" = "CLOSED";
  
  constructor(
    private threshold = 5,
    private timeout = 60000
  ) {}
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === "OPEN") {
      if (Date.now() - this.lastFailTime > this.timeout) {
        this.state = "HALF_OPEN";
      } else {
        throw new HttpError(503, "Servi√ßo temporariamente indispon√≠vel");
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess() {
    this.failures = 0;
    this.state = "CLOSED";
  }
  
  private onFailure() {
    this.failures++;
    this.lastFailTime = Date.now();
    
    if (this.failures >= this.threshold) {
      this.state = "OPEN";
    }
  }
}

const dbCircuitBreaker = new CircuitBreaker(5, 60000);

@Get("/users")
async getUsers(@Res() res: ResponseServer) {
  try {
    const users = await dbCircuitBreaker.execute(async () => {
      return await db.query("SELECT * FROM users");
    });
    
    res.json({ users });
  } catch (error) {
    if (error instanceof HttpError && error.statusCode === 503) {
      return res.status(503).json({
        error: "Servi√ßo temporariamente indispon√≠vel. Tente novamente em alguns minutos."
      });
    }
    throw error;
  }
}
```

## Exemplo Completo üéØ

```typescript
// errors/CustomErrors.ts
export class ValidationError extends HttpError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(422, message);
    this.name = "ValidationError";
  }
}

export class NotFoundError extends HttpError {
  constructor(resource: string) {
    super(404, `${resource} n√£o encontrado`);
    this.name = "NotFoundError";
  }
}

export class ConflictError extends HttpError {
  constructor(message: string) {
    super(409, message);
    this.name = "ConflictError";
  }
}

// middleware/errorHandler.ts
import { Logger } from "azurajs/logger";
import * as Sentry from "@sentry/node";

export function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Log erro
  Logger.error("Request error", {
    error: error.message,
    stack: error.stack,
    method: req.method,
    url: req.url,
    ip: req.ip
  });
  
  // Enviar para Sentry em produ√ß√£o
  if (process.env.NODE_ENV === "production") {
    Sentry.captureException(error);
  }
  
  // Responder cliente
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  
  const response = {
    error: {
      message: error.message,
      code: error.name,
      statusCode,
      timestamp: new Date().toISOString()
    }
  };
  
  // Detalhes em desenvolvimento
  if (process.env.NODE_ENV === "development") {
    response.error.details = error.stack;
  }
  
  res.status(statusCode).json(response);
}

// controllers/UserController.ts
import { NotFoundError, ConflictError } from "../errors/CustomErrors";

@Controller("/api/users")
export class UserController {
  @Get("/:id")
  async getUser(@Param("id") id: string) {
    const user = await findUserById(id);
    
    if (!user) {
      throw new NotFoundError("Usu√°rio");
    }
    
    return { user };
  }

  @Post()
  async createUser(@Body() data: CreateUserDto) {
    const exists = await userExists(data.email);
    
    if (exists) {
      throw new ConflictError("Email j√° est√° em uso");
    }
    
    try {
      const user = await saveUser(data);
      return { user };
    } catch (error) {
      throw new HttpError(500, "Erro ao criar usu√°rio");
    }
  }
}

// server.ts
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { errorHandler } from "./middleware/errorHandler";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();

// Registrar controllers
applyDecorators(app, [UserController]);

// Error handler (por √∫ltimo!)
app.use(errorHandler);

await app.listen(3000);
```

## Melhores Pr√°ticas ‚ú®

<Callout type="tip">
  **Sempre use try-catch em c√≥digo ass√≠ncrono**: Evite crashes n√£o tratados
</Callout>

<Callout type="tip">
  **Crie classes de erro customizadas**: Facilita identifica√ß√£o e tratamento
</Callout>

<Callout type="tip">
  **Log todos os erros**: Essencial para debugging e monitoramento
</Callout>

<Callout type="warn">
  **Nunca exponha stack traces em produ√ß√£o**: Pode vazar informa√ß√µes sens√≠veis
</Callout>

<Callout type="warn">
  **Registre error handler por √∫ltimo**: Deve capturar erros de todos os middlewares anteriores
</Callout>

## Pr√≥ximos Passos üìñ

<Cards>
  <Card title="Middleware" href="middleware" description="Crie middleware customizado" />
  <Card title="TypeScript" href="typescript-support" description="Type-safe error handling" />
  <Card title="Examples" href="examples" description="Veja exemplos completos" />
</Cards>
