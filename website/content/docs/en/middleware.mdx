---
title: Middleware
description: Complete guide to middleware in AzuraJS - lifecycle, types, patterns, and best practices
icon: Plug
---

# Middleware ðŸ”Œ

Middleware functions are the backbone of request processing in AzuraJS, allowing you to intercept, transform, and control the flow of requests and responses throughout your application.

## What is Middleware? ðŸ“š

Middleware is a function that executes during the request-response cycle, sitting between the incoming request and your route handler. Think of middleware as a series of layers that every request passes through before reaching its final destination.

### Middleware Signature

```typescript
import type { RequestHandler } from "azurajs/types";

type RequestHandler = (
  req: RequestServer,
  res: ResponseServer,
  next: (err?: unknown) => void
) => void | Promise<void>;
```

Each middleware has access to:

- **Request object** (`req`) - Read and modify incoming data
- **Response object** (`res`) - Control the response
- **Next function** (`next`) - Pass control to the next middleware

### Core Capabilities

- âœ… Execute code before route handlers
- âœ… Modify request/response objects
- âœ… End the request-response cycle early
- âœ… Call the next middleware in the stack
- âœ… Handle errors globally
- âœ… Implement cross-cutting concerns (auth, logging, CORS, rate limiting)

## Middleware Lifecycle ðŸ”„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Request   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Middleware 1 (e.g., Logging)           â”‚
â”‚  - Log request details                  â”‚
â”‚  - Set request ID                       â”‚
â”‚  - Call next() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
       â”‚                                    â”‚
       â–¼                                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  Middleware 2 (e.g., CORS)              â”‚ â”‚
â”‚  - Set CORS headers                     â”‚ â”‚
â”‚  - Handle preflight requests            â”‚ â”‚
â”‚  - Call next() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
       â”‚                                    â”‚ â”‚
       â–¼                                    â”‚ â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  Middleware 3 (e.g., Authentication)    â”‚ â”‚ â”‚
â”‚  - Verify token                         â”‚ â”‚ â”‚
â”‚  - Attach user to request               â”‚ â”‚ â”‚
â”‚  - Call next() or reject â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚
       â”‚                                    â”‚ â”‚ â”‚
       â–¼                                    â”‚ â”‚ â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚
â”‚  Route Handler                          â”‚ â”‚ â”‚ â”‚
â”‚  - Process business logic               â”‚ â”‚ â”‚ â”‚
â”‚  - Send response                        â”‚ â”‚ â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚
       â”‚                                    â”‚ â”‚ â”‚
       â”‚    Response flows back             â”‚ â”‚ â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
                                              â”‚ â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
       â”‚                                        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Response  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Middleware Types ðŸŽ¯
â”‚  Middleware 3 (e.g., Authentication)    â”‚
â”‚  - Verify token                         â”‚
â”‚  - Call next() or reject                â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Route Handler                          â”‚
â”‚  - Process request                      â”‚
â”‚  - Send response                        â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Response  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Middleware Types ðŸŽ¯

### 1. Global Middleware

Applies to **all routes** in your application:

```typescript
import { AzuraClient } from "azurajs";

const app = new AzuraClient();

// Runs for every single request
app.use(async (req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  await next();
});

// Add custom header to all responses
app.use(async (req, res, next) => {
  res.setHeader("X-Powered-By", "AzuraJS");
  await next();
});
```

### 2. Route-Specific Middleware

Apply middleware to specific paths or route groups:

```typescript
// Apply to all /api/admin routes
app.use("/api/admin", adminAuthMiddleware);

// Apply to all /api/users routes  
app.use("/api/users", rateLimitMiddleware);

// Multiple middleware for a path
app.use("/api/protected", [authMiddleware, rbacMiddleware]);
```

### 3. Error Handling Middleware

Special middleware that wraps everything to catch errors:

```typescript
import { HttpError } from "azurajs/http-error";
import type { RequestHandler } from "azurajs/types";

const errorMiddleware: RequestHandler = async (req, res, next) => {
  try {
    await next();
  } catch (error: any) {
    console.error("âŒ Error:", error);
    
    if (error instanceof HttpError) {
      res.status(error.status).json({
        error: error.message,
        code: error.code
      });
    } else {
      res.status(500).json({
        error: "Internal server error"
      });
    }
  }
};

// Register error middleware first (wraps everything)
app.use(errorMiddleware);
```

## Creating Middleware ðŸ› ï¸

### Basic Middleware

#### TypeScript

```typescript
import type { RequestHandler } from "azurajs/types";

// Simple logging middleware
const loggingMiddleware: RequestHandler = async (req, res, next) => {
  const start = Date.now();
  console.log(`âž¡ï¸  ${req.method} ${req.url}`);
  
  await next();
  
  const duration = Date.now() - start;
  console.log(`âœ… ${req.method} ${req.url} - ${duration}ms`);
};
```

#### JavaScript

```javascript
// Simple logging middleware
const loggingMiddleware = async (req, res, next) => {
  const start = Date.now();
  console.log(`âž¡ï¸  ${req.method} ${req.url}`);
  
  await next();
  
  const duration = Date.now() - start;
  console.log(`âœ… ${req.method} ${req.url} - ${duration}ms`);
};
```

### Middleware with Configuration

Create factory functions for configurable middleware:

#### TypeScript

```typescript
function createAuthMiddleware(options: { secret: string; issuer: string }): RequestHandler {
  return async (req, res, next) => {
    const token = req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      res.status(401).json({ error: "No token provided" });
      return;
    }
    
    try {
      const payload = await verifyJWT(token, options.secret, options.issuer);
      (req as any).user = payload;
      await next();
    } catch (error) {
      res.status(401).json({ error: "Invalid token" });
    }
  };
}

// Usage
const authMiddleware = createAuthMiddleware({
  secret: process.env.JWT_SECRET!,
  issuer: "azurajs-app"
});

app.use(authMiddleware);
```

#### JavaScript

```javascript
function createAuthMiddleware(options) {
  return async (req, res, next) => {
    const token = req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      res.status(401).json({ error: "No token provided" });
      return;
    }
    
    try {
      const payload = await verifyJWT(token, options.secret, options.issuer);
      req.user = payload;
      await next();
    } catch (error) {
      res.status(401).json({ error: "Invalid token" });
    }
  };
}

// Usage
const authMiddleware = createAuthMiddleware({
  secret: process.env.JWT_SECRET,
  issuer: "azurajs-app"
});

app.use(authMiddleware);
```

## Practical Examples ðŸ’¡

### 1. Authentication Middleware

Verify JWT tokens and attach user to request:

```typescript
import { HttpError } from "azurajs/http-error";
import type { RequestHandler } from "azurajs/types";
import jwt from "jsonwebtoken";

export const authMiddleware: RequestHandler = async (req, res, next) => {
  const token = req.headers.authorization?.replace("Bearer ", "");
  
  if (!token) {
    res.status(401).json({ error: "Authentication required" });
    return;
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    (req as any).user = {
      id: decoded.userId,
      email: decoded.email,
      role: decoded.role
    };
    await next();
  } catch (error) {
    res.status(401).json({ error: "Invalid or expired token" });
  }
};
```

### 2. Logging Middleware with Colors

Enhanced logging with request timing:

```typescript
const colors = {
  reset: "\\x1b[0m",
  green: "\\x1b[32m",
  yellow: "\\x1b[33m",
  blue: "\\x1b[34m",
  red: "\\x1b[31m"
};

const loggingMiddleware: RequestHandler = async (req, res, next) => {
  const start = Date.now();
  const timestamp = new Date().toISOString();
  
  console.log(
    `${colors.blue}[${timestamp}]${colors.reset} ` +
    `${colors.yellow}${req.method}${colors.reset} ${req.url}`
  );
  
  await next();
  
  const duration = Date.now() - start;
  const color = duration < 100 ? colors.green : duration < 500 ? colors.yellow : colors.red;
  
  console.log(
    `${colors.blue}[${timestamp}]${colors.reset} ` +
    `${colors.yellow}${req.method}${colors.reset} ${req.url} - ` +
    `${color}${duration}ms${colors.reset}`
  );
};
```

### 3. CORS Middleware

Handle Cross-Origin Resource Sharing:

```typescript
interface CorsOptions {
  origin: string | string[];
  methods?: string[];
  allowedHeaders?: string[];
  credentials?: boolean;
  maxAge?: number;
}

function createCorsMiddleware(options: CorsOptions): RequestHandler {
  return async (req, res, next) => {
    const origin = Array.isArray(options.origin) 
      ? options.origin.join(", ")
      : options.origin;
    
    res.setHeader("Access-Control-Allow-Origin", origin);
    res.setHeader(
      "Access-Control-Allow-Methods",
      (options.methods || ["GET", "POST", "PUT", "DELETE", "PATCH"]).join(", ")
    );
    res.setHeader(
      "Access-Control-Allow-Headers",
      (options.allowedHeaders || ["Content-Type", "Authorization"]).join(", ")
    );
    
    if (options.credentials) {
      res.setHeader("Access-Control-Allow-Credentials", "true");
    }
    
    if (options.maxAge) {
      res.setHeader("Access-Control-Max-Age", String(options.maxAge));
    }
    
    // Handle preflight requests
    if (req.method === "OPTIONS") {
      res.status(204).end();
      return;
    }
    
    await next();
  };
}

// Usage
app.use(createCorsMiddleware({
  origin: ["http://localhost:3000", "https://myapp.com"],
  methods: ["GET", "POST", "PUT", "DELETE"],
  credentials: true,
  maxAge: 86400
}));
```

### 4. Rate Limiting Middleware

Protect your API from abuse:

```typescript
interface RateLimitStore {
  count: number;
  resetAt: number;
}

function createRateLimitMiddleware(
  maxRequests: number,
  windowMs: number
): RequestHandler {
  const store = new Map<string, RateLimitStore>();
  
  // Cleanup old entries every minute
  setInterval(() => {
    const now = Date.now();
    for (const [key, value] of store.entries()) {
      if (now > value.resetAt) {
        store.delete(key);
      }
    }
  }, 60000);
  
  return async (req, res, next) => {
    const ip = req.socket.remoteAddress || "unknown";
    const now = Date.now();
    
    let record = store.get(ip);
    
    if (!record || now > record.resetAt) {
      record = { count: 1, resetAt: now + windowMs };
      store.set(ip, record);
      await next();
      return;
    }
    
    record.count++;
    
    if (record.count > maxRequests) {
      res.setHeader("X-RateLimit-Limit", String(maxRequests));
      res.setHeader("X-RateLimit-Remaining", "0");
      res.setHeader("X-RateLimit-Reset", String(record.resetAt));
      
      res.status(429).json({
        error: "Too many requests",
        retryAfter: Math.ceil((record.resetAt - now) / 1000)
      });
      return;
    }
    
    res.setHeader("X-RateLimit-Limit", String(maxRequests));
    res.setHeader("X-RateLimit-Remaining", String(maxRequests - record.count));
    res.setHeader("X-RateLimit-Reset", String(record.resetAt));
    
    await next();
  };
}

// Usage: 100 requests per minute
app.use(createRateLimitMiddleware(100, 60000));
```

### 5. Request Timing Middleware

Add response time header:

```typescript
const timingMiddleware: RequestHandler = async (req, res, next) => {
  const start = process.hrtime.bigint();
  
  await next();
  
  const end = process.hrtime.bigint();
  const duration = Number(end - start) / 1000000; // Convert to milliseconds
  
  res.setHeader("X-Response-Time", `${duration.toFixed(2)}ms`);
};
```

### 6. Request ID Middleware

Track requests with unique IDs:

```typescript
import { randomUUID } from "crypto";

const requestIdMiddleware: RequestHandler = async (req, res, next) => {
  const requestId = req.headers["x-request-id"] || randomUUID();
  
  (req as any).id = requestId;
  res.setHeader("X-Request-ID", requestId);
  
  await next();
};
```

### 7. Body Size Limit Middleware

Prevent large payload attacks:

```typescript
function createBodySizeLimitMiddleware(maxSize: number): RequestHandler {
  return async (req, res, next) => {
    const contentLength = parseInt(req.headers["content-length"] || "0", 10);
    
    if (contentLength > maxSize) {
      res.status(413).json({
        error: "Payload too large",
        maxSize,
        received: contentLength
      });
      return;
    }
    
    await next();
  };
}

// Usage: 10MB limit
app.use(createBodySizeLimitMiddleware(10 * 1024 * 1024));
```

### 8. Compression Middleware

Compress responses to save bandwidth:

```typescript
import { gzipSync, brotliCompressSync } from "zlib";

const compressionMiddleware: RequestHandler = async (req, res, next) => {
  const acceptEncoding = req.headers["accept-encoding"] || "";
  
  // Store original send method
  const originalSend = res.send?.bind(res);
  
  if (!originalSend) {
    await next();
    return;
  }
  
  // Override send method
  res.send = function(data: any) {
    if (typeof data !== "string" && !Buffer.isBuffer(data)) {
      return originalSend(data);
    }
    
    const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data);
    
    // Only compress if size > 1KB
    if (buffer.length < 1024) {
      return originalSend(data);
    }
    
    if (acceptEncoding.includes("br")) {
      const compressed = brotliCompressSync(buffer);
      res.setHeader("Content-Encoding", "br");
      return originalSend(compressed);
    } else if (acceptEncoding.includes("gzip")) {
      const compressed = gzipSync(buffer);
      res.setHeader("Content-Encoding", "gzip");
      return originalSend(compressed);
    }
    
    return originalSend(data);
  };
  
  await next();
};
```

## Execution Order and Precedence âš¡

Middleware executes in the order it's registered:

```typescript
const app = new AzuraClient();

// 1. Error wrapper (first to catch everything)
app.use(errorMiddleware);

// 2. Request ID
app.use(requestIdMiddleware);

// 3. Timing
app.use(timingMiddleware);

// 4. Logging
app.use(loggingMiddleware);

// 5. Compression
app.use(compressionMiddleware);

// 6. CORS
app.use(corsMiddleware);

// 7. Body size limit
app.use(createBodySizeLimitMiddleware(10 * 1024 * 1024));

// 8. Rate limiting
app.use(createRateLimitMiddleware(100, 60000));

// 9. Authentication (optional for some routes)
app.use(conditionalAuthMiddleware);

// 10. Your routes
applyDecorators(app, [UserController, ProductController]);

// The order ensures:
// - Errors are caught first
// - Requests are logged with IDs
// - Rate limiting before heavy processing
// - Auth last before routes
```

## Custom Middleware Patterns ðŸŽ¨

### Conditional Middleware

Apply middleware based on conditions:

```typescript
const conditionalAuthMiddleware: RequestHandler = async (req, res, next) => {
  // Skip auth for public routes
  const publicRoutes = ["/api/public", "/health", "/metrics"];
  
  if (publicRoutes.some(route => req.url?.startsWith(route))) {
    await next();
    return;
  }
  
  // Apply auth for other routes
  await authMiddleware(req, res, next);
};
```

### Middleware Composition

Combine multiple middleware:

```typescript
function composeMiddleware(...middlewares: RequestHandler[]): RequestHandler {
  return async (req, res, next) => {
    let index = 0;
    
    const dispatch = async (): Promise<void> => {
      if (index >= middlewares.length) {
        await next();
        return;
      }
      
      const middleware = middlewares[index++];
      await middleware(req, res, dispatch);
    };
    
    await dispatch();
  };
}

// Usage
const protectedRoute = composeMiddleware(
  authMiddleware,
  rbacMiddleware,
  auditMiddleware
);

app.use("/api/admin", protectedRoute);
```

## Express Middleware Compatibility ðŸ”„

AzuraJS middleware is compatible with Express middleware:

```typescript
import helmet from "helmet";
import compression from "compression";
import cookieParser from "cookie-parser";

const app = new AzuraClient();

// Use Express middleware directly
app.use(helmet());
app.use(compression());
app.use(cookieParser());
```

## Error Handling in Middleware âš ï¸

### Try-Catch Pattern

```typescript
const safeMiddleware: RequestHandler = async (req, res, next) => {
  try {
    // Your middleware logic
    const data = await fetchExternalData();
    (req as any).externalData = data;
    await next();
  } catch (error) {
    console.error("Middleware error:", error);
    res.status(500).json({ error: "Middleware failed" });
  }
};
```

### Error Propagation

Pass errors to error handling middleware:

```typescript
const middlewareWithErrors: RequestHandler = async (req, res, next) => {
  try {
    const user = await database.getUser(userId);
    if (!user) {
      throw new HttpError(404, "User not found");
    }
    (req as any).user = user;
    await next();
  } catch (error) {
    // Error will be caught by error middleware
    throw error;
  }
};
```

## Async Middleware Patterns ðŸ”„

### Sequential Async Operations

```typescript
const dataFetchMiddleware: RequestHandler = async (req, res, next) => {
  try {
    // Run sequentially
    const user = await database.getUser(userId);
    const permissions = await database.getPermissions(user.id);
    const settings = await database.getSettings(user.id);
    
    (req as any).user = user;
    (req as any).permissions = permissions;
    (req as any).settings = settings;
    
    await next();
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch data" });
  }
};
```

### Parallel Async Operations

```typescript
const parallelDataMiddleware: RequestHandler = async (req, res, next) => {
  try {
    // Run in parallel for better performance
    const [user, permissions, settings] = await Promise.all([
      database.getUser(userId),
      database.getPermissions(userId),
      database.getSettings(userId)
    ]);
    
    (req as any).user = user;
    (req as any).permissions = permissions;
    (req as any).settings = settings;
    
    await next();
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch data" });
  }
};
```

## Best Practices & Performance Tips ðŸ’Ž

### 1. Always Call `next()`

```typescript
// âŒ Bad - request hangs
const badMiddleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  // Forgot to call next()!
};

// âœ… Good
const goodMiddleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  await next(); // Always call next
};
```

### 2. Use Async/Await

```typescript
// âŒ Bad - no await
const badMiddleware: RequestHandler = async (req, res, next) => {
  fetchData().then(() => next()); // Promise not awaited
};

// âœ… Good  
const goodMiddleware: RequestHandler = async (req, res, next) => {
  await fetchData();
  await next();
};
```

### 3. Order Matters

```typescript
// âŒ Bad - auth before CORS
app.use(authMiddleware);  // May fail on OPTIONS
app.use(corsMiddleware);

// âœ… Good - CORS first
app.use(corsMiddleware);  // Handle OPTIONS first
app.use(authMiddleware);
```

### 4. Keep Middleware Focused

```typescript
// âŒ Bad - doing too much
const godMiddleware: RequestHandler = async (req, res, next) => {
  // Logging, auth, validation, transformation...
  // 100 lines of code
};

// âœ… Good - single responsibility
const loggingMiddleware: RequestHandler = async (req, res, next) => {
  console.log(req.method, req.url);
  await next();
};

const authMiddleware: RequestHandler = async (req, res, next) => {
  await verifyAuth(req);
  await next();
};
```

### 5. Use Caching for Expensive Operations

```typescript
const cache = new Map<string, any>();

const cachedMiddleware: RequestHandler = async (req, res, next) => {
  const key = req.url;
  
  if (cache.has(key)) {
    (req as any).cached = cache.get(key);
    await next();
    return;
  }
  
  const data = await expensiveOperation();
  cache.set(key, data);
  (req as any).cached = data;
  
  await next();
};
```

### 6. Cleanup Resources

```typescript
const resourceMiddleware: RequestHandler = async (req, res, next) => {
  const connection = await database.connect();
  
  try {
    (req as any).db = connection;
    await next();
  } finally {
    // Always cleanup
    await connection.close();
  }
};
```

## Testing Middleware ðŸ§ª

### Unit Testing

```typescript
import { describe, it, expect, mock } from "bun:test";

describe("Auth Middleware", () => {
  it("should reject requests without token", async () => {
    const req = {
      headers: {}
    } as any;
    
    const res = {
      status: mock((code: number) => res),
      json: mock((data: any) => res)
    } as any;
    
    const next = mock(async () => {});
    
    await authMiddleware(req, res, next);
    
    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({ error: "Authentication required" });
    expect(next).not.toHaveBeenCalled();
  });
  
  it("should accept valid tokens", async () => {
    const req = {
      headers: {
        authorization: "Bearer valid-token"
      }
    } as any;
    
    const res = {} as any;
    const next = mock(async () => {});
    
    await authMiddleware(req, res, next);
    
    expect(req.user).toBeDefined();
    expect(next).toHaveBeenCalled();
  });
});
```

## Troubleshooting Common Issues ðŸ”§

### Issue: Request Hangs

**Cause**: Forgot to call `next()`

```typescript
// âŒ Bad
const middleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  // Forgot next()!
};

// âœ… Fix
const middleware: RequestHandler = async (req, res, next) => {
  console.log("Processing...");
  await next();
};
```

### Issue: Headers Already Sent

**Cause**: Calling `res.json()` before `next()`

```typescript
// âŒ Bad
const middleware: RequestHandler = async (req, res, next) => {
  res.json({ data: "something" });
  await next(); // Headers already sent!
};

// âœ… Fix  
const middleware: RequestHandler = async (req, res, next) => {
  if (someCondition) {
    res.json({ data: "something" });
    return; // Don't call next
  }
  await next();
};
```

### Issue: Middleware Not Executing

**Cause**: Registered after routes

```typescript
// âŒ Bad
applyDecorators(app, [Controllers]);
app.use(middleware); // Too late!

// âœ… Fix
app.use(middleware);
applyDecorators(app, [Controllers]);
```

## Complete Example: Production-Ready Setup ðŸš€

```typescript
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import type { RequestHandler } from "azurajs/types";

const app = new AzuraClient();

// 1. Error handling wrapper
app.use(errorMiddleware);

// 2. Request ID and timing
app.use(requestIdMiddleware);
app.use(timingMiddleware);

// 3. Logging
app.use(loggingMiddleware);

// 4. Security
app.use(createCorsMiddleware({
  origin: process.env.ALLOWED_ORIGINS!.split(","),
  credentials: true
}));

app.use(helmet());

// 5. Body size limit
app.use(createBodySizeLimitMiddleware(10 * 1024 * 1024));

// 6. Rate limiting
app.use(createRateLimitMiddleware(100, 60000));

// 7. Compression
app.use(compressionMiddleware);

// 8. Conditional auth
app.use(conditionalAuthMiddleware);

// 9. Your routes
applyDecorators(app, [
  UserController,
  ProductController,
  OrderController
]);

// Start server
app.listen(3000, () => {
  console.log("ðŸš€ Server running on http://localhost:3000");
});
```

## Next Steps ðŸ“–

Now that you understand middleware, explore these related topics:

- [**Validation**](validation) - Validate request data with middleware
- [**Cookies**](cookies) - Handle cookies in middleware
- [**Error Handling**](error-handling) - Advanced error handling patterns
- [**CORS**](cors) - Deep dive into CORS configuration

---

**Pro Tip**: Middleware order is crucial. Place error handling first, logging second, security third, and authentication last before your routes.
