---
title: Validation
description: Comprehensive validation system with Zod-like API - DTOs, schemas, custom rules, and best practices
icon: CircleCheck
---

# Validation âœ…

AzuraJS provides a powerful **Zod-inspired validation system** with full TypeScript type inference, automatic transformations, and production-ready error handling.

## Why Azura Validator? ğŸš€

- âœ¨ **Clean, Familiar Syntax** - If you know Zod, you already know Azura Validator
- ğŸ¯ **Formatted Errors** - `.format()` returns errors organized by field for easy display
- âš¡ **High Performance** - Optimized validation engine
- ğŸ”§ **Built-in Transformations** - `.trim()`, `.toLowerCase()`, `.toUpperCase()` included
- ğŸ“ **Perfect TypeScript** - Automatic type inference with `Infer<T>`
- ğŸ› ï¸ **Extensible** - Easy custom validations with `.refine()`
- ğŸ’ª **Production Ready** - Battle-tested in real applications

## Quick Start ğŸƒ

```typescript
import { v, type Infer } from 'azurajs/validators';

// 1. Define your schema
const userSchema = v.object({
  name: v.string().min(3).max(50),
  email: v.string().email(),
  age: v.number().int().positive().min(18)
});

// 2. Validate data (throws on error)
const user = userSchema.parse(req.body);

// 3. Or use safe validation (returns result)
const result = userSchema.safeParse(req.body);
if (result.success) {
  console.log("Valid:", result.data);
} else {
  console.log("Errors:", result.error.format());
}

// 4. TypeScript type inference
type User = Infer<typeof userSchema>;
// Result: { name: string; email: string; age: number }
```

## Validation Strategies ğŸ¯

### 1. DTO (Data Transfer Object) Pattern

Create reusable validation schemas:

```typescript
// user.dto.ts
import { v, type Infer } from 'azurajs/validators';

export const CreateUserDTO = v.object({
  name: v.string().min(3).max(50),
  email: v.string().email(),
  password: v.string().min(8),
  age: v.number().int().min(18).max(120).optional(),
  role: v.enum(['user', 'admin', 'moderator']).default('user')
});

export const UpdateUserDTO = CreateUserDTO.partial();

export const LoginDTO = v.object({
  email: v.string().email(),
  password: v.string()
});

export type CreateUser = Infer<typeof CreateUserDTO>;
export type UpdateUser = Infer<typeof UpdateUserDTO>;
export type Login = Infer<typeof LoginDTO>;
```

### 2. Schema-First Approach

Define schemas before implementing routes:

```typescript
// schemas/product.schema.ts
export const productSchemas = {
  create: v.object({
    name: v.string().min(1).max(200),
    description: v.string().max(1000).optional(),
    price: v.number().positive(),
    stock: v.number().int().min(0),
    category: v.enum(['electronics', 'clothing', 'food', 'other']),
    tags: v.array(v.string()).max(10).default([])
  }),
  
  update: v.object({
    name: v.string().min(1).max(200).optional(),
    description: v.string().max(1000).optional(),
    price: v.number().positive().optional(),
    stock: v.number().int().min(0).optional(),
    category: v.enum(['electronics', 'clothing', 'food', 'other']).optional()
  }),
  
  query: v.object({
    category: v.string().optional(),
    minPrice: v.number().positive().optional(),
    maxPrice: v.number().positive().optional(),
    search: v.string().trim().optional(),
    page: v.number().int().positive().default(1),
    limit: v.number().int().positive().max(100).default(20)
  })
};
```

### 3. Manual Validation

For simple cases, validate inline:

```typescript
app.post('/users', (req, res) => {
  const schema = v.object({
    username: v.string().min(3),
    email: v.string().email()
  });
  
  const result = schema.safeParse(req.body);
  if (!result.success) {
    return res.status(400).json({ errors: result.error.format() });
  }
  
  const user = createUser(result.data);
  res.json(user);
});
```

## Complete Validation Examples ğŸ’¡

### User Registration with Complex Rules

```typescript
import { v, ValidationError, type Infer } from 'azurajs/validators';

// Password validation with multiple rules
const passwordSchema = v.string()
  .min(8, 'Password must be at least 8 characters')
  .refine(
    (val) => /[A-Z]/.test(val),
    'Password must contain at least one uppercase letter'
  )
  .refine(
    (val) => /[a-z]/.test(val),
    'Password must contain at least one lowercase letter'
  )
  .refine(
    (val) => /[0-9]/.test(val),
    'Password must contain at least one number'
  )
  .refine(
    (val) => /[!@#$%^&*(),.?":{}|<>]/.test(val),
    'Password must contain at least one special character'
  );

// Registration schema
const registerSchema = v.object({
  username: v.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be at most 20 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),
  email: v.string().email('Invalid email address'),
  password: passwordSchema,
  confirmPassword: v.string(),
  terms: v.boolean().refine(val => val === true, 'You must accept the terms and conditions')
}).refine(
  (data) => data.password === data.confirmPassword,
  {
    message: 'Passwords do not match',
    path: ['confirmPassword'] // Error will be attached to confirmPassword field
  }
);

// Usage in route
app.post('/auth/register', (req, res) => {
  try {
    const userData = registerSchema.parse(req.body);
    
    // Password and confirmPassword match, terms accepted
    const user = await createUser({
      username: userData.username,
      email: userData.email,
      password: userData.password // Hash this before saving!
    });
    
    res.status(201).json({ user, message: 'Registration successful' });
  } catch (error) {
    if (error instanceof ValidationError) {
      return res.status(400).json({
        error: 'Validation failed',
        issues: error.format()
        // Returns: { confirmPassword: ['Passwords do not match'], terms: [...] }
      });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

### Validating Body, Query, and Params

```typescript
// Validate all parts of the request
app.put('/api/users/:id', async (req, res) => {
  // Validate params
  const paramsSchema = v.object({
    id: v.string().uuid('Invalid user ID format')
  });
  
  // Validate query
  const querySchema = v.object({
    notify: v.boolean().optional(),
    reason: v.string().max(200).optional()
  });
  
  // Validate body
  const bodySchema = v.object({
    name: v.string().min(1).max(100).optional(),
    email: v.string().email().optional(),
    bio: v.string().max(500).optional()
  });
  
  try {
    const params = paramsSchema.parse(req.params);
    const query = querySchema.parse(req.query);
    const body = bodySchema.parse(req.body);
    
    const user = await updateUser(params.id, body, { 
      notify: query.notify,
      reason: query.reason 
    });
    
    res.json({ user });
  } catch (error) {
    if (error instanceof ValidationError) {
      return res.status(400).json({
        error: 'Validation failed',
        issues: error.format()
      });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

## Custom Validation Rules ğŸ¨

### Simple Custom Validation

```typescript
// Validate CPF (Brazilian ID)
function isValidCPF(cpf: string): boolean {
  // Remove non-digits
  cpf = cpf.replace(/[^\\d]/g, '');
  
  if (cpf.length !== 11) return false;
  if (/^(\\d)\\1{10}$/.test(cpf)) return false; // All same digits
  
  // Validation algorithm
  let sum = 0;
  for (let i = 0; i < 9; i++) {
    sum += parseInt(cpf.charAt(i)) * (10 - i);
  }
  let remainder = 11 - (sum % 11);
  let digit1 = remainder >= 10 ? 0 : remainder;
  
  if (digit1 !== parseInt(cpf.charAt(9))) return false;
  
  sum = 0;
  for (let i = 0; i < 10; i++) {
    sum += parseInt(cpf.charAt(i)) * (11 - i);
  }
  remainder = 11 - (sum % 11);
  let digit2 = remainder >= 10 ? 0 : remainder;
  
  return digit2 === parseInt(cpf.charAt(10));
}

const cpfSchema = v.string()
  .refine(isValidCPF, 'Invalid CPF format');

// Usage
const userSchema = v.object({
  name: v.string(),
  cpf: cpfSchema
});
```

### Advanced Custom Validation with Context

```typescript
// Validate date is in the future
const futureDateSchema = v.date().refine(
  (date) => date > new Date(),
  'Date must be in the future'
);

// Validate file size
const fileSizeSchema = v.number().refine(
  (size) => size <= 5 * 1024 * 1024, // 5MB
  'File size must be less than 5MB'
);

// Validate URL with specific domain
const domainUrlSchema = v.string().url().refine(
  (url) => {
    try {
      const parsed = new URL(url);
      return ['example.com', 'test.com'].includes(parsed.hostname);
    } catch {
      return false;
    }
  },
  'URL must be from allowed domains (example.com, test.com)'
);
```

## Custom Error Messages ğŸ“

### Field-Level Messages

```typescript
const userSchema = v.object({
  name: v.string()
    .min(3, 'Name is too short! Must be at least 3 characters')
    .max(50, 'Whoa! Name is too long. Maximum 50 characters'),
  
  email: v.string()
    .email('Please enter a valid email address'),
  
  age: v.number()
    .int('Age must be a whole number')
    .min(18, 'You must be at least 18 years old')
    .max(120, 'Please enter a valid age')
});
```

### Dynamic Error Messages

```typescript
function createMinLengthValidator(min: number, fieldName: string) {
  return v.string().min(min, `${fieldName} must be at least ${min} characters`);
}

const schema = v.object({
  username: createMinLengthValidator(3, 'Username'),
  bio: createMinLengthValidator(10, 'Bio')
});
```

## Validation Groups (Create vs Update) ğŸ”„

### Using `.partial()` for Updates

```typescript
const createUserSchema = v.object({
  name: v.string().min(3),
  email: v.string().email(),
  password: v.string().min(8),
  role: v.enum(['user', 'admin'])
});

// All fields become optional for updates
const updateUserSchema = createUserSchema.partial();

// Or make specific fields optional
const updateUserSchemaCustom = createUserSchema.pick('name', 'email').partial();
```

### Separate Schemas for Different Operations

```typescript
const userSchemas = {
  create: v.object({
    name: v.string().min(3),
    email: v.string().email(),
    password: v.string().min(8),
    role: v.enum(['user', 'admin']).default('user')
  }),
  
  update: v.object({
    name: v.string().min(3).optional(),
    email: v.string().email().optional(),
    bio: v.string().max(500).optional()
    // Note: no password or role in updates
  }),
  
  changePassword: v.object({
    currentPassword: v.string(),
    newPassword: v.string().min(8),
    confirmPassword: v.string()
  }).refine(
    (data) => data.newPassword === data.confirmPassword,
    'Passwords do not match'
  )
};

// Usage
app.post('/users', validateBody(userSchemas.create), createUserHandler);
app.patch('/users/:id', validateBody(userSchemas.update), updateUserHandler);
app.post('/users/password', validateBody(userSchemas.changePassword), changePasswordHandler);
```

## Transform and Sanitization ğŸ§¹

### Automatic Transformations

```typescript
const searchSchema = v.object({
  // Automatically trim and lowercase
  query: v.string()
    .trim()
    .toLowerCase()
    .min(1, 'Search query cannot be empty'),
  
  // Transform to uppercase
  category: v.string()
    .toUpperCase()
    .optional(),
  
  // Coerce to number with default
  page: v.number().int().positive().default(1),
  limit: v.number().int().positive().max(100).default(20),
  
  // Parse boolean from string
  includeInactive: v.boolean().default(false)
});

// Input: { query: "  Hello World  ", page: "2" }
// Output: { query: "hello world", page: 2, limit: 20, includeInactive: false }
```

### Custom Transformations

```typescript
const phoneSchema = v.string()
  .regex(/^[\\d\\s\\-\\(\\)]+$/, 'Invalid phone format')
  .transform((val) => val.replace(/[\\s\\-\\(\\)]/g, '')); // Remove formatting

const emailSchema = v.string()
  .email()
  .transform((val) => val.toLowerCase().trim()); // Normalize email

const userSchema = v.object({
  email: emailSchema,
  phone: phoneSchema
});

// Input: { email: "  User@EXAMPLE.COM  ", phone: "(555) 123-4567" }
// Output: { email: "user@example.com", phone: "5551234567" }
```

## Performance Considerations âš¡

### 1. Reuse Schemas

```typescript
// âŒ Bad - creates new schema on every request
app.post('/users', (req, res) => {
  const schema = v.object({ name: v.string() });
  const data = schema.parse(req.body);
});

// âœ… Good - reuse schema
const userSchema = v.object({ name: v.string() });

app.post('/users', (req, res) => {
  const data = userSchema.parse(req.body);
});
```

### 2. Use `.safeParse()` for Expected Failures

```typescript
// âŒ Bad - using try/catch for control flow
app.post('/users', (req, res) => {
  try {
    const data = userSchema.parse(req.body);
  } catch (error) {
    // Exceptions are expensive
  }
});

// âœ… Good - safe parse returns result
app.post('/users', (req, res) => {
  const result = userSchema.safeParse(req.body);
  if (!result.success) {
    return res.status(400).json({ errors: result.error.format() });
  }
});
```

### 3. Lazy Validation for Large Objects

```typescript
// Only validate what you need
const partialSchema = fullSchema.pick('name', 'email');

// Or use .passthrough() to allow extra fields
const flexibleSchema = userSchema.passthrough();
```

## Best Practices ğŸ’

### 1. **Type Inference Over Manual Types**

```typescript
// âŒ Bad - manual typing
interface User {
  name: string;
  email: string;
  age: number;
}
const userSchema = v.object({ /* ... */ });

// âœ… Good - infer from schema
const userSchema = v.object({
  name: v.string(),
  email: v.string().email(),
  age: v.number()
});
type User = Infer<typeof userSchema>;
```

### 2. **Centralize Validation Logic**

```typescript
// validation/index.ts
export const schemas = {
  user: {
    create: CreateUserDTO,
    update: UpdateUserDTO
  },
  product: {
    create: CreateProductDTO,
    update: UpdateProductDTO
  }
};

// controllers/user.controller.ts
import { schemas } from '../validation';

app.post('/users', validateBody(schemas.user.create), handler);
```

### 3. **Provide Clear Error Messages**

```typescript
// âŒ Bad - generic messages
v.string().min(3)

// âœ… Good - specific, helpful messages
v.string().min(3, 'Username must be at least 3 characters long')
```

### 4. **Use Enums for Fixed Values**

```typescript
// âŒ Bad - string without constraints
status: v.string()

// âœ… Good - enum with valid values
status: v.enum(['pending', 'active', 'suspended', 'deleted'])
```

### 5. **Validate Early**

```typescript
// âŒ Bad - validate after processing
app.post('/users', async (req, res) => {
  const user = await createUser(req.body); // May fail in DB
  const validated = userSchema.parse(user); // Too late!
});

// âœ… Good - validate first
app.post('/users', async (req, res) => {
  const validated = userSchema.parse(req.body);
  const user = await createUser(validated); // Safe data
});
```

## Validation Middleware ğŸ› ï¸

Create reusable validation middleware:

```typescript
import { BaseValidator, ValidationError } from 'azurajs/validators';
import type { RequestHandler } from 'azurajs/types';

export function validateBody<T>(schema: BaseValidator<T>): RequestHandler {
  return (req, res, next) => {
    const result = schema.safeParse(req.body);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'Validation failed',
        issues: result.error.format()
      });
    }
    
    // Attach validated data to request
    (req as any).validated = result.data;
    next();
  };
}

export function validateQuery<T>(schema: BaseValidator<T>): RequestHandler {
  return (req, res, next) => {
    const result = schema.safeParse(req.query);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'Invalid query parameters',
        issues: result.error.format()
      });
    }
    
    (req as any).validatedQuery = result.data;
    next();
  };
}

export function validateParams<T>(schema: BaseValidator<T>): RequestHandler {
  return (req, res, next) => {
    const result = schema.safeParse(req.params);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'Invalid URL parameters',
        issues: result.error.format()
      });
    }
    
    (req as any).validatedParams = result.data;
    next();
  };
}

// Usage
app.post(
  '/users',
  validateBody(CreateUserDTO),
  (req, res) => {
    const userData = (req as any).validated;
    // userData is typed and validated!
    const user = createUser(userData);
    res.json(user);
  }
);
```

## Troubleshooting Common Issues ğŸ”§

### Issue: Type Inference Not Working

**Solution**: Make sure to use `Infer` type helper:

```typescript
import { type Infer } from 'azurajs/validators';

const schema = v.object({ name: v.string() });
type Data = Infer<typeof schema>; // âœ… Correct
```

### Issue: Validation Too Strict

**Solution**: Use `.passthrough()` or make fields optional:

```typescript
// Allow extra fields
const flexibleSchema = userSchema.passthrough();

// Or make specific fields optional
const schema = v.object({
  required: v.string(),
  optional: v.string().optional()
});
```

### Issue: Error Messages Not Showing

**Solution**: Use `.format()` to get structured errors:

```typescript
const result = schema.safeParse(data);
if (!result.success) {
  console.log(result.error.format()); // âœ… Structured errors by field
  // Not: result.error.errors // âŒ Raw error array
}
```

### Issue: Performance Problems

**Solution**: Reuse schemas and use `.safeParse()`:

```typescript
// âœ… Define once, reuse many times
const userSchema = v.object({ /* ... */ });

app.post('/users', (req, res) => {
  const result = userSchema.safeParse(req.body);
});
```

## Complete API Reference ğŸ“–

### Primitive Types

```typescript
v.string()    // String validator
v.number()    // Number validator  
v.boolean()   // Boolean validator
v.date()      // Date validator
v.null()      // Null validator
v.undefined() // Undefined validator
v.any()       // Any type (bypass validation)
```

### Complex Types

```typescript
v.array(schema)           // Array of type
v.object({ })             // Object with shape
v.enum([...])             // Enum values
v.literal(value)          // Exact value
v.union(schema1, schema2) // One of multiple types
v.tuple([s1, s2])         // Fixed-length array
v.record(schema)          // Object with dynamic keys
v.map(keySchema, valSchema) // Map type
```

### String Methods

```typescript
.min(n)           // Minimum length
.max(n)           // Maximum length
.length(n)        // Exact length
.email()          // Valid email
.url()            // Valid URL
.uuid()           // Valid UUID
.regex(pattern)   // Match pattern
.trim()           // Trim whitespace
.toLowerCase()    // Convert to lowercase
.toUpperCase()    // Convert to uppercase
.startsWith(str)  // Must start with
.endsWith(str)    // Must end with
.includes(str)    // Must contain
```

### Number Methods

```typescript
.min(n)          // Minimum value
.max(n)          // Maximum value
.int()           // Must be integer
.positive()      // Must be > 0
.negative()      // Must be < 0
.multipleOf(n)   // Must be multiple of n
```

### Common Methods (All Types)

```typescript
.optional()      // Make optional
.nullable()      // Allow null
.default(value)  // Default value
.refine(fn, msg) // Custom validation
.transform(fn)   // Transform value
```

## Migration from Zod ğŸ”„

Azura Validator is nearly API-compatible with Zod:

```typescript
// Zod
import { z } from 'zod';
const schema = z.object({
  name: z.string().min(3)
});

// Azura (just change z to v!)
import { v } from 'azurajs/validators';
const schema = v.object({
  name: v.string().min(3)
});
```

**Key Differences**:
- Azura has built-in `.format()` for errors
- Azura includes transformations like `.trim()` by default
- Azura is optimized for AzuraJS ecosystem

## Next Steps ğŸ“–

- [**Middleware**](middleware) - Use validation in middleware
- [**Error Handling**](error-handling) - Handle validation errors
- [**TypeScript Support**](typescript-support) - Advanced TypeScript patterns

---

**Pro Tip**: Always validate user input at the boundary of your application. Trust nothing from the client!


## Available Types ğŸ“š

### String

```typescript
v.string()
  .min(3)                    // Minimum 3 characters
  .max(50)                   // Maximum 50 characters
  .length(10)                // Exactly 10 characters
  .email()                   // Validate email
  .url()                     // Validate URL
  .uuid()                    // Validate UUID
  .regex(/^[A-Z]/)          // Custom pattern
  .trim()                    // Remove whitespace
  .toLowerCase()             // Convert to lowercase
  .toUpperCase()             // Convert to uppercase
  .startsWith('prefix')      // Must start with
  .endsWith('suffix')        // Must end with
  .includes('substring')     // Must contain
  .optional()                // Optional field
  .nullable()                // Accept null
  .default('value')          // Default value
```

### Number

```typescript
v.number()
  .min(0)                    // Minimum
  .max(100)                  // Maximum
  .int()                     // Must be integer
  .positive()                // Must be positive
  .negative()                // Must be negative
  .multipleOf(5)             // Multiple of N
  .optional()
  .default(0)
```

### Boolean

```typescript
v.boolean()
  .optional()
  .default(false)
```

### Date

```typescript
v.date()
  .min(new Date('2020-01-01'))
  .max(new Date())
  .optional()
```

### Array

```typescript
v.array(v.string())
  .min(1)                    // Minimum items
  .max(10)                   // Maximum items
  .length(5)                 // Exactly N items
  .nonempty()                // Cannot be empty
  .optional()
```

### Object

```typescript
v.object({
  name: v.string(),
  age: v.number()
})
  .strict()                  // No extra fields
  .passthrough()             // Pass extra fields
  .partial()                 // All fields optional
  .pick('name', 'age')       // Select fields
  .omit('password')          // Omit fields
```

### Enum

```typescript
v.enum(['admin', 'user', 'guest'])
v.enum([1, 2, 3, 4, 5])
```

### Literal

```typescript
v.literal('exact-value')
v.literal(42)
v.literal(true)
```

### Union

```typescript
v.union(
  v.string(),
  v.number(),
  v.boolean()
)
```

## Practical Examples ğŸ’¡

### User Validation

```typescript
import { v, ValidationError, type Infer } from 'azurajs/validators';

const userSchema = v.object({
  name: v.string().min(3).max(50),
  email: v.string().email(),
  age: v.number().int().min(18).max(120),
  bio: v.string().max(500).optional(),
  active: v.boolean().default(true)
});

app.post('/users', (req, res) => {
  try {
    const userData = userSchema.parse(req.body);
    const user = await createUser(userData);
    res.json(user);
  } catch (error) {
    if (error instanceof ValidationError) {
      return res.status(400).json({
        error: 'Validation failed',
        issues: error.format()
      });
    }
  }
});
```

### Secure Password

```typescript
const passwordSchema = v.string()
  .min(8)
  .refine(
    (val) => /[A-Z]/.test(val),
    'Must contain uppercase letter'
  )
  .refine(
    (val) => /[a-z]/.test(val),
    'Must contain lowercase letter'
  )
  .refine(
    (val) => /[0-9]/.test(val),
    'Must contain number'
  )
  .refine(
    (val) => /[!@#$%^&*]/.test(val),
    'Must contain special character'
  );

const registerSchema = v.object({
  email: v.string().email(),
  password: passwordSchema,
  confirmPassword: v.string()
}).refine(
  (data) => data.password === data.confirmPassword,
  'Passwords do not match'
);
```

### Nested Objects

```typescript
const addressSchema = v.object({
  street: v.string(),
  city: v.string(),
  state: v.string().length(2),
  zipCode: v.string().regex(/^\d{5}(-\d{4})?$/)
});

const userWithAddressSchema = v.object({
  name: v.string(),
  email: v.string().email(),
  mainAddress: addressSchema,
  shippingAddress: addressSchema.optional()
});
```

### Complex Arrays

```typescript
const productSchema = v.object({
  id: v.string().uuid(),
  name: v.string().min(1),
  price: v.number().positive(),
  tags: v.array(v.string()).max(10)
});

const orderSchema = v.object({
  customerId: v.string().uuid(),
  items: v.array(v.object({
    productId: v.string().uuid(),
    quantity: v.number().int().positive(),
    price: v.number().positive()
  })).min(1),
  total: v.number().positive(),
  status: v.enum(['pending', 'paid', 'shipped', 'delivered'])
});
```

### Union Types (Payment)

```typescript
const paymentSchema = v.union(
  v.object({
    type: v.literal('card'),
    cardNumber: v.string().length(16),
    cvv: v.string().length(3),
    expiryDate: v.string().regex(/^\d{2}\/\d{2}$/)
  }),
  v.object({
    type: v.literal('pix'),
    key: v.string().email()
  }),
  v.object({
    type: v.literal('boleto'),
    document: v.string().length(11)
  })
);

app.post('/payment', (req, res) => {
  const payment = paymentSchema.parse(req.body) as any;
  
  // TypeScript knows the types!
  if (payment.type === 'card') {
    // payment.cardNumber is available
  } else if (payment.type === 'pix') {
    // payment.key is available
  }
  
  res.json(payment);
});
```

### Automatic Transformations

```typescript
const searchSchema = v.object({
  query: v.string().trim().toLowerCase().min(1),
  category: v.string().optional(),
  page: v.number().int().positive().default(1),
  limit: v.number().int().positive().max(100).default(20)
});

app.get('/search', (req, res) => {
  const params = searchSchema.parse(req.query);
  
  // params.query is already trimmed and lowercase!
  console.log(params.query); // "hello world"
  console.log(params.page);  // 1 (default)
  
  res.json(params);
});
```

### Conditional Validation

```typescript
const orderSchema = v.object({
  type: v.enum(['pickup', 'delivery']),
  items: v.array(v.object({
    id: v.string(),
    qty: v.number().int().positive()
  })),
  address: v.object({
    street: v.string(),
    city: v.string()
  }).optional()
}).refine(
  (data) => {
    // If delivery, address is required
    if (data.type === 'delivery') {
      return !!data.address;
    }
    return true;
  },
  'Address is required for delivery'
);
```

## Type Inference ğŸ”§

```typescript
const schema = v.object({
  name: v.string(),
  age: v.number(),
  active: v.boolean().optional()
});

// Infer type automatically
type User = Infer<typeof schema>;
// Result: { name: string; age: number; active?: boolean }

// Use the type
function createUser(data: User) {
  // TypeScript knows all fields!
}
```

## Error Formatting ğŸ“

```typescript
const result = userSchema.safeParse(invalidData);

if (!result.success) {
  console.log(result.error.format());
  
  // Returns:
  // {
  //   "name": ["String must be at least 3 characters"],
  //   "email": ["Invalid email address"],
  //   "age": ["Number must be at least 18"]
  // }
}
```

## Validation Middleware ğŸ› ï¸

```typescript
import { BaseValidator, ValidationError } from 'azurajs/validators';

function validate<T>(schema: BaseValidator<T>) {
  return (req: any, res: any, next: any) => {
    const result = schema.safeParse(req.body);
    
    if (!result.success) {
      return res.status(400).json({
        error: 'Validation failed',
        issues: result.error.format()
      });
    }
    
    (req as any).validated = result.data;
    next();
  };
}

// Usage
app.post('/users', validate(userSchema), (req, res) => {
  const user = (req as any).validated; // Already validated!
  res.json(user);
});
```

## Advanced Patterns ğŸ¯

### Reusable Schemas

```typescript
// Base schemas
const idSchema = v.string().uuid();
const timestampsSchema = v.object({
  createdAt: v.date(),
  updatedAt: v.date()
});

// Reuse
const userSchema = v.object({
  id: idSchema,
  name: v.string(),
  ...timestampsSchema
});
```

### Custom Validators

```typescript
function isValidCPF(cpf: string): boolean {
  // Validation logic
  return true;
}

const cpfSchema = v.string()
  .length(11)
  .refine(isValidCPF, 'Invalid CPF');
```

## Comparison with Zod ğŸ“Š

| Feature | Azura | Zod |
|---------|-------|-----|
| Syntax | `v.string().email()` | `z.string().email()` |
| Transformations | âœ… Built-in | âŒ Need `.transform()` |
| Formatted Errors | âœ… `.format()` | âŒ Manual |
| Performance | âš¡ Faster | ğŸ¢ Slower |
| Bundle Size | ğŸ“¦ Smaller | ğŸ“¦ Larger |
| TypeScript | âœ… Perfect | âœ… Good |

## API Reference ğŸ“–

### Main Factory

```typescript
import { v } from 'azurajs/validators';

v.string()     // String validator
v.number()     // Number validator
v.boolean()    // Boolean validator
v.date()       // Date validator
v.array(type)  // Array validator
v.object({})   // Object validator
v.enum([])     // Enum validator
v.literal(val) // Literal validator
v.union(...)   // Union validator
```

## Best Practices ğŸ’

1. **Use TypeScript inference**: `type User = Infer<typeof userSchema>`
2. **Safe parse for user input**: Use `.safeParse()` instead of `.parse()`
3. **Reuse schemas**: Create reusable validation components
4. **Custom error messages**: Provide clear validation feedback
5. **Transform data**: Use `.trim()`, `.toLowerCase()` for automatic transformations

## Migration from Zod ğŸ”„

```typescript
// Zod
import { z } from 'zod';
const schema = z.object({
  name: z.string().min(3)
});

// Azura (just change z to v!)
import { v } from 'azurajs/validators';
const schema = v.object({
  name: v.string().min(3)
});
```

Almost the same API! ğŸ‰
