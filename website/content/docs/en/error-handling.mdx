---
title: Error Handling
description: Complete guide to handling errors gracefully and building robust APIs in AzuraJS
icon: TriangleAlert
---

# Error Handling üö®

Robust error handling is the foundation of production-ready applications. AzuraJS provides powerful tools and patterns for handling errors consistently, logging them appropriately, and providing meaningful feedback to clients.

## Error Handling Philosophy üéØ

### Why Proper Error Handling Matters

1. **User Experience**: Clear, helpful error messages guide users to fix issues
2. **Security**: Never expose internal details, stack traces, or sensitive data
3. **Debugging**: Comprehensive logging helps track down production issues
4. **Monitoring**: Structured errors enable effective application monitoring
5. **Reliability**: Graceful degradation keeps your application running

### Error Handling Principles

<Callout type="tip">
**Fail Fast, Fail Gracefully**: Detect errors early but handle them elegantly to prevent cascading failures.
</Callout>

<Callout type="warn">
**Security First**: Never expose sensitive information like database queries, API keys, or file paths in error messages sent to clients.
</Callout>

<Callout type="info">
**Consistent Format**: Use a standard error response structure across your entire API for easier client-side handling.
</Callout>

## Error Types in Web Applications üóÇÔ∏è

### 1. Client Errors (4xx)
Caused by invalid input or requests from the client.

| Code | Type | Description | Example |
|------|------|-------------|---------|
| 400 | Bad Request | Invalid syntax or data | Missing required field |
| 401 | Unauthorized | Authentication required | No token provided |
| 403 | Forbidden | Authenticated but no permission | Regular user accessing admin |
| 404 | Not Found | Resource doesn't exist | User ID not in database |
| 409 | Conflict | Request conflicts with current state | Email already registered |
| 422 | Unprocessable Entity | Valid syntax but semantic errors | Age cannot be negative |
| 429 | Too Many Requests | Rate limit exceeded | More than 100 req/min |

### 2. Server Errors (5xx)
Caused by issues on the server side.

| Code | Type | Description | Example |
|------|------|-------------|---------|
| 500 | Internal Server Error | Unexpected server error | Unhandled exception |
| 502 | Bad Gateway | Invalid response from upstream | External API timeout |
| 503 | Service Unavailable | Server temporarily down | Database connection lost |
| 504 | Gateway Timeout | Upstream didn't respond in time | Slow external service |

## HttpError Class üí•

Use `HttpError` to throw HTTP errors with status codes:

### TypeScript

```typescript
import { Get, Param } from "azurajs/decorators";
import { HttpError } from "azurajs/http-error";

@Get("/:id")
getUser(@Param("id") id: string) {
  const user = findUserById(id);
  
  if (!user) {
    throw new HttpError(404, "User not found");
  }
  
  return { user };
}
```

### JavaScript

```javascript
const { HttpError } = require("azurajs/http-error");

app.get("/:id", ({ req, res }) => {
  const { id } = req.params;
  const user = findUserById(id);
  
  if (!user) {
    throw new HttpError(404, "User not found");
  }
  
  res.json({ user });
});
```

### Common Status Codes

```typescript
// 400 Bad Request
throw new HttpError(400, "Invalid data");

// 401 Unauthorized
throw new HttpError(401, "Unauthorized");

// 403 Forbidden
throw new HttpError(403, "Access denied");

// 404 Not Found
throw new HttpError(404, "Resource not found");

// 409 Conflict
throw new HttpError(409, "User already exists");

// 422 Unprocessable Entity
throw new HttpError(422, "Validation failed");

// 500 Internal Server Error
throw new HttpError(500, "Internal server error");
```

## Error Handling Middleware ‚öôÔ∏è

Create a global middleware to catch all errors:

```typescript
function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  console.error("Error:", error);
  
  // HttpError
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message,
      statusCode: error.statusCode
    });
  }
  
  // Validation error (Zod)
  if (error.name === "ZodError") {
    return res.status(400).json({
      error: "Validation failed",
      details: error.errors
    });
  }
  
  // Generic error
  res.status(500).json({
    error: "Internal server error",
    message: process.env.NODE_ENV === "development" ? error.message : undefined
  });
}

// Register last
app.use(errorHandler);
```

## Try-Catch in Async Handlers üîÑ

Always wrap async code in try-catch:

```typescript
@Get("/posts")
async getPosts(@Res() res: ResponseServer) {
  try {
    const posts = await fetchPostsFromDB();
    res.json({ posts });
  } catch (error) {
    console.error("Error fetching posts:", error);
    throw new HttpError(500, "Error fetching posts");
  }
}
```

## Async Handler Wrapper üéÅ

Create a wrapper to avoid repetitive try-catch:

```typescript
function asyncHandler(fn: Function) {
  return async (req: RequestServer, res: ResponseServer, next: () => void) => {
    try {
      await fn(req, res, next);
    } catch (error) {
      next(error);
    }
  };
}

// Use as middleware
app.get("/users", asyncHandler(async ({ req, res }) => {
  const users = await getUsersFromDB();
  res.json({ users });
}));
```

## Custom Error Classes üé®

Create domain-specific error classes:

```typescript
class ValidationError extends HttpError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(422, message);
    this.name = "ValidationError";
  }
}

class AuthenticationError extends HttpError {
  constructor(message = "Not authenticated") {
    super(401, message);
    this.name = "AuthenticationError";
  }
}

class AuthorizationError extends HttpError {
  constructor(message = "Access denied") {
    super(403, message);
    this.name = "AuthorizationError";
  }
}

class NotFoundError extends HttpError {
  constructor(resource: string) {
    super(404, `${resource} not found`);
    this.name = "NotFoundError";
  }
}

class ConflictError extends HttpError {
  constructor(message: string) {
    super(409, message);
    this.name = "ConflictError";
  }
}

// Use in controllers
@Get("/:id")
getUser(@Param("id") id: string) {
  const user = findUserById(id);
  
  if (!user) {
    throw new NotFoundError("User");
  }
  
  return { user };
}

@Post()
createUser(@Body() data: any) {
  const exists = userExists(data.email);
  
  if (exists) {
    throw new ConflictError("Email already in use");
  }
  
  return createUser(data);
}
```

## Validation Error Handling ‚úÖ

Integrate with Zod for type-safe validation:

```typescript
import { z } from "zod";

const CreateUserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().int().positive()
});

@Post("/users")
createUser(@Body() data: unknown, @Res() res: ResponseServer) {
  try {
    const validData = CreateUserSchema.parse(data);
    const user = saveUser(validData);
    res.status(201).json({ user });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: "Validation failed",
        details: error.errors.map(e => ({
          field: e.path.join("."),
          message: e.message
        }))
      });
    }
    throw error;
  }
}
```

## Error Logging üìù

Log errors for later analysis:

```typescript
import { Logger } from "azurajs/logger";

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Log error details
  Logger.error("Request error", {
    error: error.message,
    stack: error.stack,
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.headers["user-agent"],
    timestamp: new Date().toISOString()
  });
  
  // Respond to client
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message
    });
  }
  
  res.status(500).json({
    error: "Internal server error"
  });
}

app.use(errorHandler);
```

## Error Tracking üîç

Integrate with tracking services like Sentry:

```typescript
import * as Sentry from "@sentry/node";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0
});

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Send to Sentry
  Sentry.captureException(error, {
    extra: {
      method: req.method,
      url: req.url,
      ip: req.ip
    }
  });
  
  // Respond to client
  if (error instanceof HttpError) {
    return res.status(error.statusCode).json({
      error: error.message
    });
  }
  
  res.status(500).json({
    error: "Internal server error"
  });
}

app.use(errorHandler);
```

## Errors in Middleware üîå

Pass errors to the next middleware using `next()`:

```typescript
function authMiddleware(
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    
    if (!token) {
      throw new AuthenticationError("Token not provided");
    }
    
    const decoded = verifyJWT(token);
    req.user = decoded;
    next();
  } catch (error) {
    next(error);  // Pass error to error handler
  }
}

app.use(authMiddleware);
app.use(errorHandler);
```

## Database Errors üíæ

Handle database-specific errors:

```typescript
class DatabaseError extends HttpError {
  constructor(message: string, public originalError?: any) {
    super(500, message);
    this.name = "DatabaseError";
  }
}

@Get("/users")
async getUsers(@Res() res: ResponseServer) {
  try {
    const users = await db.query("SELECT * FROM users");
    res.json({ users });
  } catch (error: any) {
    // Connection error
    if (error.code === "ECONNREFUSED") {
      throw new DatabaseError("Database unavailable", error);
    }
    
    // SQL syntax error
    if (error.code === "42P01") {
      throw new DatabaseError("Table does not exist", error);
    }
    
    // Generic error
    throw new DatabaseError("Error querying database", error);
  }
}
```

## Consistent Error Response Format üìã

Use a standard format for all error responses:

```typescript
interface ErrorResponse {
  error: {
    message: string;
    code: string;
    statusCode: number;
    details?: any;
    timestamp: string;
    path: string;
  };
}

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  
  const response: ErrorResponse = {
    error: {
      message: error.message || "Internal server error",
      code: error.name || "INTERNAL_ERROR",
      statusCode,
      timestamp: new Date().toISOString(),
      path: req.url
    }
  };
  
  // Add details in development
  if (process.env.NODE_ENV === "development") {
    response.error.details = {
      stack: error.stack,
      ...error
    };
  }
  
  res.status(statusCode).json(response);
}
```

## Network Error Handling üåê

Handle errors when making external requests:

```typescript
@Get("/external-data")
async getExternalData(@Res() res: ResponseServer) {
  try {
    const response = await fetch("https://api.example.com/data");
    
    if (!response.ok) {
      throw new HttpError(
        502,
        `External API returned ${response.status}`
      );
    }
    
    const data = await response.json();
    res.json({ data });
  } catch (error: any) {
    if (error.code === "ENOTFOUND") {
      throw new HttpError(503, "External service unavailable");
    }
    
    if (error.code === "ETIMEDOUT") {
      throw new HttpError(504, "Timeout connecting to external service");
    }
    
    throw error;
  }
}
```

## Circuit Breaker Pattern üîå

Implement circuit breaker for cascading failures:

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailTime = 0;
  private state: "CLOSED" | "OPEN" | "HALF_OPEN" = "CLOSED";
  
  constructor(
    private threshold = 5,
    private timeout = 60000
  ) {}
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === "OPEN") {
      if (Date.now() - this.lastFailTime > this.timeout) {
        this.state = "HALF_OPEN";
      } else {
        throw new HttpError(503, "Service temporarily unavailable");
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess() {
    this.failures = 0;
    this.state = "CLOSED";
  }
  
  private onFailure() {
    this.failures++;
    this.lastFailTime = Date.now();
    
    if (this.failures >= this.threshold) {
      this.state = "OPEN";
    }
  }
}

const dbCircuitBreaker = new CircuitBreaker(5, 60000);

@Get("/users")
async getUsers(@Res() res: ResponseServer) {
  try {
    const users = await dbCircuitBreaker.execute(async () => {
      return await db.query("SELECT * FROM users");
    });
    
    res.json({ users });
  } catch (error) {
    if (error instanceof HttpError && error.statusCode === 503) {
      return res.status(503).json({
        error: "Service temporarily unavailable. Please try again in a few minutes."
      });
    }
    throw error;
  }
}
```

## Production-Ready Error Response Format üìã

### Standardized Error Structure

```typescript
interface ApiErrorResponse {
  success: false;
  error: {
    code: string;           // Machine-readable error code
    message: string;        // Human-readable message
    statusCode: number;     // HTTP status code
    timestamp: string;      // ISO 8601 timestamp
    path: string;           // Request path
    requestId?: string;     // For tracking across services
    details?: any;          // Additional context (dev only)
  };
}

interface ApiSuccessResponse<T> {
  success: true;
  data: T;
  metadata?: {
    page?: number;
    limit?: number;
    total?: number;
  };
}

type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;
```

### Implementation

```typescript
function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  const requestId = req.headers["x-request-id"] as string || generateId();
  
  const errorResponse: ApiErrorResponse = {
    success: false,
    error: {
      code: error.name || "INTERNAL_ERROR",
      message: error.message || "An unexpected error occurred",
      statusCode,
      timestamp: new Date().toISOString(),
      path: req.url,
      requestId
    }
  };
  
  // Add details in development
  if (process.env.NODE_ENV === "development") {
    errorResponse.error.details = {
      stack: error.stack,
      ...error
    };
  }
  
  // Log error
  Logger.error("Request error", {
    ...errorResponse.error,
    ip: req.ip,
    userAgent: req.headers["user-agent"]
  });
  
  res.status(statusCode).json(errorResponse);
}
```

## Error Recovery Strategies üîÑ

### Retry Logic with Exponential Backoff

```typescript
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 1000
): Promise<T> {
  let lastError: any;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      // Don't retry client errors
      if (error instanceof HttpError && error.statusCode < 500) {
        throw error;
      }
      
      // Don't retry on last attempt
      if (attempt === maxRetries - 1) {
        break;
      }
      
      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, delay));
      
      Logger.info(`Retrying request (attempt ${attempt + 2}/${maxRetries})`);
    }
  }
  
  throw lastError;
}

// Usage
@Get("/external-data")
async getExternalData(@Res() res: ResponseServer) {
  try {
    const data = await retryWithBackoff(async () => {
      const response = await fetch("https://api.example.com/data");
      if (!response.ok) throw new Error("External API error");
      return response.json();
    });
    
    res.json({ data });
  } catch (error) {
    throw new HttpError(503, "External service unavailable");
  }
}
```

### Graceful Degradation

```typescript
@Get("/dashboard")
async getDashboard(@Res() res: ResponseServer) {
  const dashboard: any = {
    status: "ok"
  };
  
  // Try to fetch user stats
  try {
    dashboard.stats = await getUserStats();
  } catch (error) {
    Logger.warn("Failed to load stats", error);
    dashboard.stats = null;  // Degrade gracefully
    dashboard.warnings = ["Stats temporarily unavailable"];
  }
  
  // Try to fetch notifications
  try {
    dashboard.notifications = await getNotifications();
  } catch (error) {
    Logger.warn("Failed to load notifications", error);
    dashboard.notifications = [];  // Empty array as fallback
  }
  
  // Return partial data rather than complete failure
  res.json(dashboard);
}
```

## Error Monitoring Integration üì°

### Sentry Integration (Production-Grade)

```typescript
import * as Sentry from "@sentry/node";
import { ProfilingIntegration } from "@sentry/profiling-node";

// Initialize Sentry
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  profilesSampleRate: 1.0,
  integrations: [
    new ProfilingIntegration(),
  ],
  beforeSend(event, hint) {
    // Don't send 4xx errors to Sentry
    const error = hint.originalException;
    if (error instanceof HttpError && error.statusCode < 500) {
      return null;
    }
    return event;
  }
});

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Add context to Sentry
  Sentry.setContext("request", {
    method: req.method,
    url: req.url,
    headers: req.headers,
    ip: req.ip
  });
  
  // Add user context if available
  if ((req as any).user) {
    Sentry.setUser({
      id: (req as any).user.id,
      email: (req as any).user.email
    });
  }
  
  // Capture exception
  if (!(error instanceof HttpError) || error.statusCode >= 500) {
    Sentry.captureException(error);
  }
  
  // Send response
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  res.status(statusCode).json({
    error: {
      message: error.message,
      code: error.name,
      statusCode
    }
  });
}
```

### Custom Error Tracking

```typescript
interface ErrorLog {
  timestamp: Date;
  error: string;
  stack?: string;
  statusCode: number;
  path: string;
  method: string;
  ip: string;
  userId?: string;
}

class ErrorTracker {
  private errors: ErrorLog[] = [];
  private readonly maxSize = 1000;
  
  track(error: any, req: RequestServer) {
    const log: ErrorLog = {
      timestamp: new Date(),
      error: error.message,
      stack: error.stack,
      statusCode: error instanceof HttpError ? error.statusCode : 500,
      path: req.url,
      method: req.method,
      ip: req.ip || "unknown",
      userId: (req as any).user?.id
    };
    
    this.errors.push(log);
    
    // Keep only recent errors
    if (this.errors.length > this.maxSize) {
      this.errors.shift();
    }
    
    // Alert on repeated errors
    this.checkForPatterns(log);
  }
  
  private checkForPatterns(log: ErrorLog) {
    const recentErrors = this.errors.filter(e => 
      Date.now() - e.timestamp.getTime() < 60000 // Last minute
    );
    
    // Alert if same error occurs 10+ times in 1 minute
    const sameErrors = recentErrors.filter(e => 
      e.error === log.error && e.path === log.path
    );
    
    if (sameErrors.length >= 10) {
      Logger.critical("Error spike detected", {
        error: log.error,
        path: log.path,
        count: sameErrors.length
      });
      
      // Send alert to ops team
      this.sendAlert(log, sameErrors.length);
    }
  }
  
  private sendAlert(log: ErrorLog, count: number) {
    // Implement alerting (Slack, email, PagerDuty, etc.)
  }
  
  getRecentErrors(limit = 100): ErrorLog[] {
    return this.errors.slice(-limit);
  }
}

const errorTracker = new ErrorTracker();

function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  errorTracker.track(error, req);
  
  // ... rest of error handling
}
```

## Complete Example üéØ

```typescript
// errors/CustomErrors.ts
export class ValidationError extends HttpError {
  constructor(message: string, public fields?: Record<string, string>) {
    super(422, message);
    this.name = "ValidationError";
  }
}

export class NotFoundError extends HttpError {
  constructor(resource: string) {
    super(404, `${resource} not found`);
    this.name = "NotFoundError";
  }
}

export class ConflictError extends HttpError {
  constructor(message: string) {
    super(409, message);
    this.name = "ConflictError";
  }
}

// middleware/errorHandler.ts
import { Logger } from "azurajs/logger";
import * as Sentry from "@sentry/node";

export function errorHandler(
  error: any,
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  // Log error
  Logger.error("Request error", {
    error: error.message,
    stack: error.stack,
    method: req.method,
    url: req.url,
    ip: req.ip
  });
  
  // Send to Sentry in production
  if (process.env.NODE_ENV === "production") {
    Sentry.captureException(error);
  }
  
  // Respond to client
  const statusCode = error instanceof HttpError ? error.statusCode : 500;
  
  const response = {
    error: {
      message: error.message,
      code: error.name,
      statusCode,
      timestamp: new Date().toISOString()
    }
  };
  
  // Details in development
  if (process.env.NODE_ENV === "development") {
    response.error.details = error.stack;
  }
  
  res.status(statusCode).json(response);
}

// controllers/UserController.ts
import { NotFoundError, ConflictError } from "../errors/CustomErrors";

@Controller("/api/users")
export class UserController {
  @Get("/:id")
  async getUser(@Param("id") id: string) {
    const user = await findUserById(id);
    
    if (!user) {
      throw new NotFoundError("User");
    }
    
    return { user };
  }

  @Post()
  async createUser(@Body() data: CreateUserDto) {
    const exists = await userExists(data.email);
    
    if (exists) {
      throw new ConflictError("Email already in use");
    }
    
    try {
      const user = await saveUser(data);
      return { user };
    } catch (error) {
      throw new HttpError(500, "Error creating user");
    }
  }
}

// server.ts
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { errorHandler } from "./middleware/errorHandler";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();

// Register controllers
applyDecorators(app, [UserController]);

// Error handler (last!)
app.use(errorHandler);

await app.listen(3000);
```

## Best Practices ‚ú®

<Callout type="tip">
  **Always use try-catch in async code**: Avoid unhandled crashes
</Callout>

<Callout type="tip">
  **Create custom error classes**: Makes identification and handling easier
</Callout>

<Callout type="tip">
  **Log all errors**: Essential for debugging and monitoring
</Callout>

<Callout type="warn">
  **Never expose stack traces in production**: Can leak sensitive information
</Callout>

<Callout type="warn">
  **Register error handler last**: Must catch errors from all previous middleware
</Callout>

## Next Steps üìñ

<Cards>
  <Card title="Middleware" href="middleware" description="Create custom middleware" />
  <Card title="TypeScript" href="typescript-support" description="Type-safe error handling" />
  <Card title="Examples" href="examples" description="See complete examples" />
</Cards>
